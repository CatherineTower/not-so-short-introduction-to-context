%%% File:        b02_FirstDoc.mkiv
%%% Author:      Joaquín Ataz-López
%%% Begun:       March 2020
%%% Concluded:   April 2020
%
% Contents:    It seemed to me appropriate for an introduction to offer an
%              example. In «The TeX Book» Knuth begins by showing some
%              examples of how to execute tex. The problem is that
%              ConTeXt when compiling does not   expect the user to
%              resolve potential errors _during the compilation_, which
%              leaves me almost without material for the chapter. I have
%              also failed to verify what many of the ConTeXt options
%              do. And as for errors andhow to deal with them, other
%              than the  case of non-existentcommands, I am never sure
%              if a fault will generate a compilation error or not. As
%              far as I can tell, non-existent options or inadequate
%              values never generate compilation errors, and unsuitable
%              environments that are not properly closed only do so
%              sometimes. I drew my inspiration for this chapter partly
%              from chapter II of «El libro de LaTeX», by Bernardo, José
%              Manual y compañía.
%
%%% Edited with: Emacs + AuTeX - And at times with vim + context-plugin
%%%

\environment ../introCTX_env.mkiv

\startcomponent b02_FirstDoc.mkiv

\startchapter
  [reference=cap:firstdoc, title=Наш первый исходный файл]

\TocChap

Эта глава посвящена нашему первому эксперименту и объяснит основную структуру документа \ConTeXt, а также лучшие стратегии для работы с потенциальными ошибками.


\startsection
  [title=Подготовка к эксперименту:\\ основные инструменты:]

Чтобы написать и скомпилировать первый исходный файл, в нашей системе должны быть установлены следующие инструменты.

\startitemize[n]

{\bf Текстовый редактор} для записи нашего тестового файла. Существует множество текстовых редакторов, и трудно представить себе операционную систему, в которой один из них еще не установлен. Мы можем использовать любой из них: есть простые, более сложные, более мощные, за некоторые вы платите, некоторые бесплатные (как {\em gratis}), некоторые бесплатные (как  {\em libre}), некоторые специализируются на системах \TeX, другие -- общего характера и т. д. Если мы привыкли работать с конкретным редактором, лучше продолжать работать с ним; Если мы до сих пор не привыкли работать с одним из них, я советую сначала найти простой редактор, чтобы не усложнять изучение \ConTeXt задачей обучения работе с текстовым редактором. Хотя это правда, что часто самые сложные для изучения программы оказываются самыми мощными.

Я написал этот текст с помощью GNU Emacs, который является одним из самых мощных и универсальных редакторов общего назначения из существующих; правда, у него есть свои особенности и недоброжелатели, но в целом «любителей Emacs» больше, чем «ненавистников Emacs». Существует расширение GNU Emacs под названием AucTeX для работы с файлами \TeX\ или одной из его производных, которое предоставляет редактору несколько очень интересных дополнительных утилит, хотя AucTeX в целом лучше подготовлен к работе с  \LaTeX, чем с файлами \ConTeXt. GNU Emacs в сочетании с AucTeX может быть хорошим вариантом, если мы не знаем, какой редактор выбрать; обе программы являются свободно распространяемыми, поэтому существуют их версии для всех операционных систем. Фактически, заявление о том, что GNU Emacs является {\em свободным программным обеспечением}, является преуменьшением, поскольку эта программа лучше, чем любая другая, воплощает в себе дух того, что такое {\em свободное программное обеспечение} и что оно означает. В конце концов, его основным разработчиком стал {\sc Richard Stallman}, основатель и идеолог проекта GNU и  {\em Free Software Foundation}.

Помимо GNU Emacs + AucTeX, другие хорошие варианты, если вы не знаете, что выбрать, - это  {\em Scite} и {\em TexWorks}. Первый, хотя редактор общего назначения, не предназначенный специально для работы с файлами \ConTeXt, легко настраивается, и, поскольку это редактор, который обычно используют разработчики \ConTeXt, \suite- содержит файлы конфигурации для этого редактора, написанные самим Хансом Хагеном. TexWorks, с другой стороны, является быстрым текстовым редактором и специализируется на обработке файлов \TeX\ и его производных языков. Настроить его для работы с \ConTeXt\ достаточно просто, и  \suite- также предусматривает его настройку.

Каким бы ни был редактор, мы не должны использовать в качестве текстового редактора {\em текстовый процессор}, например, OpenOffice Writer или Microsoft Word. Эти программы, также слишком медленные и тяжелые, на мой взгляд, могут, если это явно указано, сохранить файл как «только текст (txt)», но они не были предназначены для этого, и мы, скорее всего, в конечном итоге сохраним наш файл в двоичном формате, несовместимом с \ConTeXt.



  \item {\bf Дистрибутив \ConTeXt} для обработки нашего тестового файла. Если в нашей системе уже есть установка \TeX\ (или \LaTeX), возможно, уже установлена версия \ConTeXt. Чтобы проверить это, достаточно открыть терминал и набрать


  {\tt \$> }\type{context --version}

  \startSmallPrint

{\bf ПРИМЕЧАНИЕ} для тех, кто плохо знаком с работой с терминала -- первые два символа, которые я написал (\quotation{\$>}), не нужно писать в терминале. Я просто представил то, что называется подсказкой терминала: маленький мигающий знак, указывающий на то, что терминал ожидает инструкций.

  \stopSmallPrint

 Если уже установлена версия \ConTeXt, появится что-то вроде следующего:

{\tfx\vbox{\starttyping
  mtx-context     | ConTeXt Process Management 1.03
  mtx-context     |
  mtx-context     | main context file: /home/jq/context/LMTX/tex/texmf-context/
                  | tex/context/base/mkiv/context.mkiv
  mtx-context     | current version: 2020.04.30 11:15
  mtx-context     | main context file: /home/jq/context/LMTX/tex/texmf-context/
                  | tex/context/base/mkiv/context.mkxl
  mtx-context     | current version: 2020.04.30 11:15
  stoptyping}}

Последняя строка сообщает нам дату выпуска установленной версии. Если он слишком старый, мы должны либо обновить его, либо установить новую версию. Я рекомендую установить дистрибутив под названием \suite-, инструкции по установке которого можно найти на \goto{\ConTeXt\ wiki}[url(wiki)]. Вы можете найти краткое изложение всего этого в \in{Appendix}[installation_suite].

{\bf Программа для чтения PDF-файлов}, чтобы мы могли видеть результат нашего эксперимента на экране. В Windows и Mac OS всегда есть Adobe Acrobat Reader. Он не устанавливается по умолчанию (или не устанавливался, когда я перестал использовать Microsoft Windows более 15 лет назад), но он устанавливается, когда вы впервые пытаетесь открыть файл PDF, поэтому, скорее всего, он уже установлен. В системах Linux / Unix нет текущей версии Acrobat Reader, но она вам и не нужна, поскольку доступны буквально десятки бесплатных и очень хороших программ для чтения PDF. Кроме того, в этих системах почти всегда один из них установлен по умолчанию. Мне больше всего нравится по скорости и простоте использования MuPDF; хотя у него есть некоторые недостатки, если вы используете языки, отличные от английского, с диакритическими знаками, и он не позволяет вам выделять текст или отправлять документ на принтер; это просто читатель; но пользоваться им очень быстро и удобно. Когда мне нужны некоторые средства, которые не работают в MuPDF, я обычно использую Okular или qPdfView. Но опять же, это дело вкуса: каждый может выбрать то, что ему больше нравится.

\stopitemize

Мы можем выбрать наш редактор, наш PDF-ридер, наш дистрибутив \ConTeXt\  ... Добро пожаловать в мир {\em free libre software}!

\stopsection

\startsection
  [title=Сам эксперимент]

\startsubsubsubject
  [title=Запись исходного файла]

Если упомянутые выше инструменты уже доступны, нам нужно открыть наш текстовый редактор и создать с ним файл, который мы назовем \quotation{rain.tex}. В качестве содержимого этого файла мы напишем следующее:

\startframedtext
\starttyping
% Первая строка документа

\mainlanguage[en] % Language = English

\setuppapersize[S5] % paper size

\setupbodyfont
  [modern,12pt] % Font = Latin Modern, 12 point

\setuphead      % Format of chapters
  [chapter]
  [style=\bfc]

\starttext  % Begin document contents

\startchapter
  [title=The rain in Spain...]

How kind of you to let me come.
Now once again, where does it rain?
On the plain, on the plain.
And where's that blasted plain?
In Spain, in Spain.
The rain in Spain stays mainly in the plain.
The rain in Spain stays mainly in the plain.

\stopchapter

\stoptext % End of document

\stoptyping
\stopframedtext

Во время написания не имеет значения, изменится ли что-либо, особенно при добавлении или удалении пробелов или разрывов строк. Важно то, что слова, следующие за \quotation{\tt \backslash{}}, написаны точно так же, как и их содержание в фигурных скобках. В остальном возможны вариации.

\stopsubsubsubject

\startsubsubsubject
  [title=Кодировка символов файла]

После того, как мы написали то, что указано выше, мы сохраняем файл на диск, убедившись, что кодировка символов -- UTF-8. Эта кодировка символов является сегодня стандартной. В любом случае, если мы не уверены, мы можем увидеть кодировку из самого текстового редактора и при необходимости изменить ее. Как это сделать, очевидно, зависит от используемого текстового редактора. В GNU Emacs, например, при одновременном нажатии обеих клавиш CTRL-X, затем Return, за которым следует \quote{f}, в последней строке окна (которое GNU Emacs называет мини-буфером) появится сообщение с запросом для новой кодировки и сообщает нам, какая текущая кодировка. В других редакторах мы обычно можем получить доступ к кодировке в меню «Сохранить как».

После того, как мы проверили правильность кодировки и сохранили файл на диске, мы закрываем редактор и сосредотачиваемся на анализе написанного.

\stopsubsubsubject

\startsubsubsubject
  [title={Взглянем на содержимое нашего первого исходного файла, написанного для \ConTeXt}]

Первая строка начинается с символа \quotation{{\tt \%}}. Это зарезервированный символ, указывающий \ConTeXt\ не обрабатывать текст между этим символом и концом строки, в которой он находится. Это помогает, когда мы хотим написать комментарий к исходному файлу, который может прочитать только автор, поскольку он не становится частью окончательного документа. В этом примере я использовал этот символ, чтобы привлечь внимание к определенным строкам, объясняя, что они делают.

Следующие строки начинаются с символа \quotation{{\tt \backslash}}, еще одного из зарезервированных символов \ConTeXt, указывающих на то, что то, что за ним следует, является именем команды. В этом примере показан ряд команд, содержащихся в исходном файле \ConTeXt: язык, на котором написан документ, размер бумаги, шрифт, который будет использоваться в документе, и способ форматирования глав. Далее в других главах мы увидим детали этих команд, но на данный момент меня интересует только то, что читатель видит, как они выглядят: они всегда начинаются с символа \quotation{{\tt \backslash}}, затем идет имя команды, а затем, между изогнутыми скобками (также известные как фигурные скобки, но мы будем использовать фигурные скобки в этом документе, чтобы прояснить разницу) или квадратные скобки, в зависимости от ситуации, данные, необходимые команде для выполнения своих действий. Между названием команды и квадратными или фигурными скобками, которые его сопровождают, могут быть пробелы или разрывы строк.

В 9-й строке нашего примера (я считаю только строки с каким-либо текстом в них) стоит важная команда \tex{starttext}: она сообщает \ConTeXt, что содержимое документа начинается с этой точки; и в последней строке нашего примера мы видим команду \tex{stoptext}, которая говорит, что здесь заканчивается документ. Это две очень важные команды, о которых я скоро скажу больше. Между ними лежит фактическое содержание нашего документа, который, в нашем примере, состоит из знаменитого диалога из  \quotation{My Fair Lady} \quotation{The Rain in Spain...}. Я написал это в форме прозы, чтобы мы могли видеть, как \ConTeXt\ форматирует абзац.

\stopsubsubsubject

\startsubsubsubject
  [title=Обработка исходного файла]

На следующем этапе, убедившись, что \ConTeXt\ правильно установлен в нашей системе, нам нужно открыть терминал в том же каталоге, в котором был сохранен наш исходный файл \quotation{rain.tex}.

\startSmallPrint

Многие текстовые редакторы позволяют нам скомпилировать документ, над которым мы работали, без необходимости открывать терминал. Однако {\em каноническая} процедура обработки документа с помощью \ConTeXt\ подразумевает выполнение её из терминала путём непосредственного выполнения программы. Я собираюсь делать это таким образом (или предполагать, что это делается так) в этом документе по разным причинам; во-первых, я не могу знать, какой текстовый редактор использует читатель. Но наиболее важным является то, что, используя терминал, мы будем иметь доступ к экранному выводу из  \MyKey{context} и можем видеть сообщения, поступающие из программы.

\stopSmallPrint

Если дистрибутив \ConTeXt, который мы установили, является \suite-, прежде всего нам нужно выполнить сценарий, который сообщает терминалу путь и расположение файлов, которые \ConTeXt\ должен запускать. В системах Linux / Unix для этого нужно написать следующую команду:

{\tt \$> }\type{source ~/context/tex/setuptex}

предполагая, что мы установили \ConTeXt\ в каталог с именем \MyKey{context}.

\startSmallPrint

Что касается выполнения {\em script}, о котором мы только что говорили, посмотрите, что говорится в \in{Appendix}[installation_suite] относительно установки \suite-.

\stopSmallPrint

После того, как переменные, необходимые для запуска \MyKey{context}, были загружены в память, мы можем запустить его. Мы делаем это, набирая

{\tt \$> }\type{context rain}

в терминале. Обратите внимание, что хотя исходный файл называется \MyKey{rain.tex}, при вызове \MyKey{context} мы опускаем расширение файла. Если бы мы назвали исходный файл, например, \MyKey{rain.mkiv} (что я обычно делаю, чтобы сказать, что этот файл был написан для Mark~IV), нам пришлось бы прямо указать расширение файла, написав \MyKey{context rain.mkiv}.

После запуска \MyKey{context} в терминале на экране появятся несколько десятков строк, сообщающих нам, что делает \ConTeXt. Эта информация появляется со скоростью, за которой человек не может уследить, но нам не следует беспокоиться об этом, поскольку эта информация сохраняется не только на экране, но и во вспомогательном файле с расширением \MyKey{.log}. Он создается во время обработки, и при необходимости мы можем спокойно проконсультироваться с ним позже.

Через несколько секунд, если мы записали текст в исходный файл, не допустив серьёзных ошибок, сообщения терминала закончатся. Последнее сообщение сообщит нам, сколько времени потребовалось для компиляции файла. При первой компиляции документа требуется немного больше времени, поскольку \ConTeXt\ должен загрузить в память любые файлы, сообщающие ему, какие шрифты используются, а для дальнейшей обработки они уже загружены. Когда появится последнее сообщение о затраченном времени, обработка будет завершена. Если все прошло хорошо, каталог, в котором мы запустили \MyKey{context}, теперь будет содержать три дополнительных файла:

\startitemize[packed]

\item rain.pdf
\item rain.log
\item rain.tuc

\stopitemize

Первый из них - это результат нашей обработки, или, другими словами, это получившийся отформатированный PDF-файл. Второй -- это файл \MyKey{.log}, в котором хранится вся информация, отображаемая на экране во время обработки файла; третий -- вспомогательный файл, который \Context генерирует при компиляции и используется для построения индексов и перекрестных ссылок. А пока, если всё прошло, как ожидалось, мы можем удалить оба файла ({\tt rain.log} и {\tt rain.tuc}). Если возникла какая-либо проблема, информация в этих файлах поможет нам узнать, где она находится, и поможет найти решение.

Если мы не получили этих результатов, вероятно, это связано с:

\startitemize [packed]

\item либо неправильно установили наш дистрибутив \ConTeXt, и в этом случае при написании команды «\MyKey{context}» в терминале мы увидели бы сообщение \quotation{command unknown}.

\item или наш файл не был закодирован как UTF-8, и это привело к ошибке обработки.

\item или, возможно, \ConTeXt, установленный в нашей системе, был Mark II. В этой версии мы не можем использовать кодировку UTF-8 без явного указания этого в исходном файле. Мы могли бы настроить исходный файл так, чтобы он компилировался должным образом, но, учитывая, что это введение относится к Mark IV, нет смысла продолжать работу с Mark II: для нас было бы лучше установить \suite-.

\item или мы допустили ошибку в исходном файле при записи имени команды или связанных с ней данных.

\stopitemize

\startSmallPrint

Если после запуска \MyKey{context} терминал начал выдавать сообщения, а затем остановился без повторного появления подсказки, перед продолжением нам нужно нажать CTRL-X, чтобы прервать выполнение \ConTeXt, которое было прервано из-за ошибки.

\stopSmallPrint

Затем нам нужно проверить, что произошло, и разрешить это, пока мы не получим правильную компиляцию.

\placefigure
  [here]
  [rain]
  {The rain in Spain...}
  {\midaligned{\framed{\externalfigure[rain.pdf][width=13cm]}}}

На \in{figure}[rain] мы видим содержимое \MyKey{rain.pdf}. Мы также видим, что \ConTeXt\ пронумеровал страницу и главу и написал текст указанным шрифтом. В этом случае не происходит переноса слов, но по умолчанию \ConTeXt\ будет переносить слова в конце строки в соответствии с правилами расстановки переносов для выбранного языка, и в нашем случае первая строка нашего исходного файла указывает (\tex{mainlanguage[en]}).

Подводя итог: \ConTeXt\ преобразовал исходный файл и сгенерировал файл, в котором у нас есть документ, отформатированный в соответствии с инструкциями в исходном файле. Все комментарии в нем исчезли, и что касается команд, то теперь у нас есть не их имена, а результаты их выполнения.

\stopsubsubsubject

\stopsection

\startsection
  [title=Структура нашего\\ тестового файла]

В проекте, разработанном только в одном исходном файле, структура очень проста и помечена командами \tex{starttext} ... \tex{stoptext}. Все, что находится между первой строкой файла и командой \tex{starttext}, называется преамбулой. Содержимое фактического документа вставляется между командами  \tex{starttext} и \tex{stoptext}. В нашем примере преамбула включает три команды глобальной конфигурации: одна для указания языка нашего документа (\tex{mainlanguage}), другая для указания размера страниц (\tex{setuppapersize}), который в нашем случае равен \quotation{S5}, представляя размеры экрана компьютера и третья команда (\tex{setuphead}), которая позволяет нам настроить, как будут выглядеть заголовки глав.

Тело документа заключено между командами \tex{starttext} и \tex{stoptext}. Эти команды указывают начало и конец обрабатываемого текста соответственно: между ними нам нужно включить весь текст, который мы хотим обработать \ConTeXt, вместе с командами, которые не должны влиять на весь документ, а только на его части. А пока отметим, что команды \tex{starttext} и \tex{stoptext} обязательны в каждом документе \ConTeXt, хотя в дальнейшем, говоря о многофайловых проектах (\in{section}[sec-projects]), мы увидим, что есть некоторые исключения из этого.

\stopsection

\startsection
  [title={Некоторые дополнительные сведения о том, как запустить \quotation{\tt context}}]

Команда \MyKey{context}, с которой мы начали обрабатывать наш первый исходный файл ранее, на самом деле является сценарием Lua {\sc Lua} {\em script}, то есть небольшой программы {\sc Lua}, которая после выполнения некоторых проверок вызывает \LuaTeX, поскольку именно она обрабатывает исходный файл.

Мы могли бы вызвать \MyKey{context} различными вариантами. Параметры вводятся сразу после имени команды с двумя дефисами. Если мы хотим ввести более одного варианта, мы разделяем их пробелом. Опция \MyKey{help} дает нам список всех опций с кратким объяснением каждой из них:

{\sc \$>}\type{context --help}

Некоторые наиболее интересные опции следующие:

\description{{\tt interface}:}

Как я уже сказал во вводной главе, интерфейс \ConTeXt\ переведен на разные языки. По умолчанию интерфейс на английском языке, однако эта опция позволяет нам указать ему использовать голландский (nl), французский (fr), итальянский (it), немецкий (de) или румынский (ro).

\description{{\tt purge, purgeall}:}

 Удалить вспомогательные файлы, созданные в процессе обработки.

\description{{\tt result=Name}:}

Указывает имя, которое должен иметь результирующий файл PDF. По умолчанию он будет таким же, как обрабатываемый исходный файл, с расширением .PDF.

\description{{\tt usemodule=list:}}

Загрузить указанные модули перед запуском \ConTeXt\ (модуль - это расширение \ConTeXt, которое не является частью его ядра и предоставляет некоторую дополнительную утилиту).

\description{{\tt useenvironment=list:}}

Загрузить указанные файлы среды перед запуском \ConTeXt\ (файл среды - это файл с инструкциями по настройке).

\description{{\tt version}:}

Показать версию \ConTeXt.

\description{{\tt help}:} напечатать информацию помощи опций программы.

\description{{\tt noconsole}:}

Запретить отправку сообщений на экран во время компиляции. Однако эти сообщения по-прежнему сохраняются в файле .log.

\description{{\tt nonstopmode}:} Выполнить компиляцию без остановки при возникновении ошибок. Это не означает, что ошибка не возникает, но когда \ConTeXt\ обнаруживает ошибку, даже если он может исправить, он будет продолжать компиляцию до конца или до тех пор, пока не обнаружит ошибку, от которой не может восстановить.

\description{{\tt batchmode}:} Комбинация двух предыдущих вариантов. Он работает без перебоев и не выводит никаких экранных сообщений.

На ранних этапах изучения \ConTeXt\ я не думаю, что стоит использовать последние три параметра, поскольку, когда возникает ошибка, мы не будем иметь ни малейшего представления о том, где она находится и что ее вызвало. И поверьте, дорогие читатели, рано или поздно у вас будет ошибка при обработке.

\stopsection

\startsection
  [title=Managing errors]

При работе с \ConTeXt\ рано или поздно неизбежны ошибки при обработке. Мы можем сгруппировать ошибки по этим четырем категориям:

\startitemize[n]

\item {\bf Ошибки записи}. Они возникают, когда мы ошибаемся в написании команды. В этом случае мы отправим компилятору запрос, который он не понимает. Например, когда вместо записи команды \tex{TeX} мы пишем \tex{Tex} с последним нижним регистром \quote{x}, учитывая, что \ConTeXt\ различает верхний и нижний регистр и, следовательно, видит \quotation{TeX} и \quotation{Tex} как разные слова. ; или если функциональные параметры команды помещены в квадратные скобки вместо фигурных скобок, или если мы пытаемся использовать зарезервированные символы как если бы они были нормальными символами и т. д.

\item {\bf Ошибки упущения}. В \ConTeXt\ есть инструкции, которые запускают задачу, требующую, чтобы мы также явно указали, когда она закончится; как зарезервированный символ \$, который включает математический режим, который продолжается до тех пор, пока он не будет отключен, и если мы забудем его отключить, при обнаружении текста или инструкции, которые не имеют смысла в математическом режиме, возникает ошибка. То же самое, если мы начинаем текстовый блок с зарезервированного символа \quote{\{} или с команды \tex{startSomething}, и далее при явном закрытии \quote{\}} или команда \tex{stopsomething} не найдена.



\item {\bf Концептуальные ошибки}. Это то, что я называю ошибками, возникающими, когда вызывается команда, которая требует определенных аргументов, но они не указаны, или когда синтаксис, вызывающий команду, неверен.

\item {\bf Ситуационные ошибки}. Есть некоторые команды, которые предназначены для работы только в определенных контекстах или средах и не распознаются вне их. Это происходит особенно в математическом режиме: некоторые команды \ConTeXt\ работают только при написании математических формул, и при вызове в другой среде они генерируют ошибку.

\stopitemize

Что мы делаем, когда \MyKey{context} предупреждает нас во время обработки, что произошла ошибка? Первым делом, очевидно, является определение ошибки. Для этого нам необходимо проанализировать файл \MyKey{.log}, сгенерированный в процессе обработки; хотя иногда в этом нет необходимости, поскольку ошибка такого рода вызывает немедленную остановку обработки, и в этом случае сообщение об ошибке будет видно в том же терминале, где мы запустили \MyKey{context}.

\placefloat
  [here]
  [middle]
  [msgerror]
  {Screen output in the case of a compilation error}
{
\switchtobodyfont[script]
\startframedtext
\starttyping
3     \setuppapersize % Paper size
4       [S5]
5
6     \setupbodyfont
7       [modern,12pt] % Main font
8
9     \setuphead      % Chapter titles in bold
10       [chapter]
11       [style=\bfc]
12
13 >>  \startext  % Begin the document
14
15     \startchapter[title=The rain in Spain]
16
17     How kind of you to let me come.
18     Now once again, where does it rain?
19     On the plain, on the plain.
20     And where's that blasted plain?
21     In Spain, in Spain.
22     The rain in Spain stays mainly in the plain.
23     The rain in Spain stays mainly in the plain.

mtx-context     | fatal error: return code: 256
\stoptyping
\stopframedtext
}

Например, если в нашем тестовом файле \MyKey{rain.tex} по ошибке вместо \tex{starttext} мы написали \tex{starttext} (только с одним \quote{t}), очень распространенная ошибка, при запуске \MyKey{context rain} обработка будет остановлена и в терминале мы увидим информацию, показанную на \in{figure}[msgerror]. Здесь мы видим, что строки нашего исходного файла пронумерованы, и в одной из них, в данном случае под номером 13, между номером и строкой текста, компилятор добавил \MyKey{>>}, чтобы указать, что это строка, где он обнаружил ошибку. Файл \MyKey{rain.log} даст нам больше подсказок. В нашем примере это не такой уж большой файл, поскольку компилируемый исходный код значительно сокращен; в других случаях он может содержать огромное количество информации. Но мы должны погрузиться в это. Если мы откроем \MyKey{rain.log} в текстовом редакторе, мы увидим, что он сохранил всё, что делает \ConTeXt. Нам нужно найти там строку, которая начинается с предупреждения об ошибке, и для этого мы можем использовать функцию поиска текстового редактора. Мы будем искать «tex error», и это приведет нас к следующим строкам:

\starttyping
tex error       > tex error on line 13 in file |
                  /home/jq/context/docs/rain.tex: ! Undefined control sequence

l.13 \startext
              % Begin the document

\stoptyping

\startSmallPrint

{\bf Примечание}: первая строка, сообщающая нам об ошибке в файле \MyKey{rain.log}, очень длинная. Чтобы он выглядел хорошо, учитывая ширину страницы, я разделил её на две части. Символ \quote{\|} показывает точку, в которой я её разделил.

\stopSmallPrint

Если мы обратим внимание на три строки сообщения об ошибке, то увидим, что в первом сообщается, какой номер строки привел к ошибке (строка 13) и что это за ошибка: «Неопределенная управляющая последовательность» \quotation{Undefined control sequence},или, что то же самое: неизвестная последовательность управления, другими словами, неизвестная команда. Две следующие строки файла журнала показывают нам строку 13, разделенную в точке, в которой возникла ошибка. Так что нет никаких сомнений в том, что ошибка кроется в \tex{startext}. Мы внимательно его прочитаем и, если повезёт и накопим опыт, то мы поймём, что написали \quotation{startext}, а не \quotation{starttext} (с двойной буквой \quote{t}).

Подумайте о том факте, что компьютеры очень хороши и очень быстро выполняют инструкции, но очень медленно читают наши мысли, и слово \quotation{startext} не то же самое, что \quotation{starttext}. Программа знает, как выполнить последнее, а не первое. Она не знает, что с этим делать.

В других случаях найти ошибку будет не так-то просто. Особенно, когда ошибка состоит в том, что что-то началось, но не указано, где это должно закончиться. Иногда вместо поиска \quotation{tex error} в файле \MyKey{.log} нам следует искать звездочку. Этот символ в начале строки файла является не столько фатальной ошибкой, сколько предупреждением. Однако предупреждения могут быть полезны для поиска ошибки.

И если информации в файле \MyKey{.log} будет недостаточно, нам нужно будет просмотреть наш основной файл по крупицам в поисках ошибки. Хорошая стратегия для этого - изменить расположение команды \tex{stoptext}. Помните, что \ConTeXt\ прекращает обработку текста, когда находит эту команду. Следовательно, если я помещаю \tex{stoptext} более или менее в середине файла и компилирую его, будет скомпилирована только первая половина; если ошибка повторится, то я знаю, что она находится в первой половине исходного файла, а если нет, то это означает, что она находится во второй половине ... и так далее, по крупицам, меняя расположение \tex{stoptext} команда, мы сможем найти, где ошибка. Как только мы ее нашли, мы можем попытаться понять и исправить ее или, если мы не можем понять, почему возникла ошибка, по крайней мере, обнаружив, где она находится, мы можем попробовать написать что-то другим способом, чтобы избежать ее воспроизведения. Это последнее решение, конечно, применимо только в том случае, если мы являемся автором. Если мы просто наберем текст для кого-то еще, мы не сможем его изменить, и нам придется продолжать исследование, пока мы не обнаружим причины ошибки и ее возможное решение.

На практике, когда с помощью \ConTeXt\ создается относительно длинный документ, он обычно время от времени компилируется по мере того, как документ готовится, так что, если он выдаст ошибку, мы будем более или менее ясно понимаем новую часть, поскольку в последний раз мы обработал файл, и почему он выдал ошибку.


\stopsection

\stopchapter

\stopcomponent

%%% Local Variables:
%%% mode: ConTeXt
%%% mode: auto-fill
%%% TeX-master: "../introCTX.mkiv"
%%% coding: utf-8-unix
%%% End:
%%% vim:set filetype=context tw=72 : %%%
