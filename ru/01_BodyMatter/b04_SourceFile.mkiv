%%% File:        b04_SourceFile.mkiv
%%% Author:      Joaquín Ataz-López
%%% Begun:       April 2020
%%% Concluded:   June 2020
%%% Contents:    The idea of the first part of this chapter is
%%%              taken from Chapter 2 of The TeX Book: "Book
%%%              printing versus ordinary typing". Basically,
%%%              it is about explaining how to write the
%%%              source file. Initially, in this chapter I included
%%%              part of what finally became Chapter 10 and
%%%              appendix B. But at the last miniute I decided to reconfigure it
%%%              and link it to dealing with projects that
%%%              I initially planned to deal with at the end. I think
%%%              that this final order is preferable.
%%%
%%% Edited with: Emacs + AuTeX - And at times with vim + context-plugin
%%%

\environment ../introCTX_env.mkiv

\startcomponent b04_SourceFile.mkiv

\startchapter
  [reference=cap:sourcefile, title=Исходные файлы и проекты]

\TocChap

Как мы уже знаем, при работе с \ConTeXt\ мы всегда начинаем с текстового файла, в который, наряду с содержимым окончательного документа, включен ряд инструкций, сообщающих \ConTeXt\ о преобразованиях, которые он должен применить для генерации нашего итоговый правильно отформатированный документ в формате PDF из исходного файла.

Думая о читателях, которые до сих пор знали, как работать только с текстовыми редакторами, я думаю, что стоит потратить некоторое время на сам исходный файл. Или, скорее, исходные файлы, поскольку бывают случаи, когда есть только один исходный файл, а другие, когда мы используем несколько исходных файлов для получения окончательного документа. В этом последнем случае мы можем говорить о \quotation{многофайловых проектах}.

\startsection
  [title=Кодировка исходных файлов, reference=sec:encoding]

Исходные файлы должны быть текстовыми. В компьютерной терминологии это имя, данное файлу, содержащему только читаемый человеком текст, который не включает двоичный код. Эти файлы также называются файлами {\em простой текст} или {\em простой текст}.

Поскольку внутренне компьютерные системы обрабатывают только двоичные числа, текстовый файл на самом деле состоит из {\em чисел}, которые представляют {\em символов}. {\em table} используется для соединения числа с символом. Для текстовых файлов существует несколько возможных таблиц. Термин {\em кодировка текстового файла} относится к определенной таблице соответствия символов |-|, которую использует конкретный текстовый файл.

\startSmallPrint

Существование различных таблиц кодирования для текстовых файлов - следствие истории самой информатики. На ранних этапах разработки, когда память и объем памяти компьютерных устройств были недостаточными, было решено использовать таблицу под названием ASCII (расшифровывается как \quote{{\em  Американский стандартный код для обмена информацией}}), которая позволяла только 128 символов и была создана в 1963 году Комитетом по стандартам США. Очевидно, что 128 знаков недостаточно для представления всех знаков и символов, используемых во всех языках мира; но этого было более чем достаточно для представления английского языка, который из всех западных языков имеет меньшее количество символов, поскольку в нем не используются диакритические знаки (диакритические знаки и другие знаки выше или ниже или через другие буквы). Преимущество использования ASCII состояло в том, что текстовые файлы занимали очень мало места, так как 127 (наибольшее число в таблице) может быть представлено 7-значным двоичным числом, а первые компьютеры использовали байт как единицу измерения памяти. , 8-значное двоичное число. Любой символ в таблице поместится в один байт. Поскольку байт состоит из 8 цифр, а ASCII использует только 7 цифр, оставалось даже место для добавления некоторых других символов для представления других языков.

Но когда использование компьютеров расширилось, неадекватность ASCII стала очевидной, и возникла необходимость в разработке {\ em альтернативных} таблиц, которые включали символы, не известные в английском алфавите, такие как испанский \quote {ñ}, гласные с ударением, каталонский или французский \quote{ç} и т. д. С другой стороны, не было первоначального соглашения относительно того, какими должны быть эти {\em альтернативные таблицы} ASCII, поэтому различные специализированные компьютерные компании постепенно взялись за решение этой проблемы самостоятельно. Таким образом, были созданы не только конкретные таблицы для разных языков или групп языков, но и разные таблицы в зависимости от компании, которая их создала (Microsoft, Apple, IBM и т.д.).

Идея создания единой таблицы, которую можно было бы использовать для всех языков, возникла только с увеличением компьютерной памяти и более низкой стоимостью запоминающих устройств и соответствующим увеличением емкости. Но, опять же, на самом деле это была не одна таблица, содержащая все символы, которые были созданы, а стандартная кодировка (называемая {\sc Unicode}) вместе с различными способами ее представления (UTF-8, UTF-16, UTF- 32 и т.д.) Из всех этих систем стандартом де-факто стала UTF-8, которая позволяет отображать практически любой живой язык и многие уже исчезнувшие языки, а также многочисленные дополнительные символы, все с использованием чисел переменной длины (от 1 до 4 байтов), что, в свою очередь, помогает оптимизировать размер текстовых файлов. Этот размер не увеличился {\em слишком} по сравнению с файлами, использующими чистый ASCII.

До появления \XeTeX\ системы, основанные на \TeX\ - который также родился в США и, следовательно, имеет английский как родной язык - предполагали, что кодировка была в чистом ASCII; чтобы использовать другую кодировку, вам нужно было как-то указать это в исходном файле.

\stopSmallPrint

\dontleavehmode \ConTeXt\ Mark~IV предполагает, что кодировка будет UTF-8. Однако в менее современных компьютерных системах по-прежнему может использоваться другая кодировка. Я не очень уверен в кодировке по умолчанию, которую использует Windows, учитывая, что стратегия Microsoft по охвату широкой публики заключается в сокрытии сложности (но даже если она скрыта, это не означает, что она исчезла!). Информации о системе кодирования, которую он использует по умолчанию, не так много (или мне не удалось ее найти).

В любом случае, независимо от кодировки по умолчанию, любой текстовый редактор позволяет сохранить файл в нужной кодировке. Исходные файлы, предназначенные для обработки с помощью \ConTeXt\ Mark~IV, должны быть сохранены в UTF-8, если, конечно, нет очень веской причины для использования другой кодировки (хотя я не могу понять, в чем может быть эта причина).

Если мы хотим записать файл, написанный в другой кодировке (возможно, старый файл), то мы можем

\startitemize[a]

\item Преобразовать файл в формат UTF-8, рекомендуемый вариант, и для этого существуют различные инструменты; в Linux, например, команды {\tt iconv} или {\tt recode}.

\item Сообщить \ConTeXt\ в исходном файле, что кодировка не UTF-8. Для этого нам нужно использовать команду \tex{enableregime}, синтаксис которой:

\PlaceMacro{enableregime}{\tt \color[maincolor]{\backslash enableregime[{\em Encoding}]}}

где {\em Encoding} относится к имени, по которому \ConTeXt\ знает фактическую кодировку рассматриваемого файла. В \in{table}[кодировках] вы найдете различные кодировки и имена, по которым их знает \ConTeXt\.

\stopitemize

{\switchtobodyfont[small]
  \placetable
    [here]
    [encodings]
    {Основные кодировки в \ConTeXt}
    {
      \starttabulate[|l|l|l|]
        \HL
        \NC {\bf Encoding} \NC {\bf Name(s) in \ConTeXt} \NC{\bf Notes}\NR
        \HL
        \NC Windows CP 1250\NC cp1250, windows-1250\NC Western Europe\NR
        \NC Windows CP 1251\NC cp1251, windows-1251\NC Cyrillic\NR
        \NC Windows CP 1252\NC cp1252, win, windows-1252\NC Western Europe\NR
        \NC Windows CP 1253\NC cp1253, windows-1253\NC Greek\NR
        \NC Windows CP 1254\NC cp1254, windows-1254\NC Turkish\NR
        \NC Windows CP 1257\NC cp1257, windows-1257\NC Baltic\NR
        \NC ISO-8859-1, ISO Latin 1\NC iso-8859-1, latin1, il1\NC Western Europe\NR
        \NC ISO-8859-2, ISO Latin 2\NC iso-8859-2, latin2, il2\NC Western Europe\NR
        \NC ISO-8859-15, ISO Latin 9\NC iso-8859-15,  latin9,  il9\NC Western Europe\NR
        \NC ISO-8859-7\NC iso-8859-7,  grk\NC Greek\NR
        \NC Mac Roman\NC mac\NC Western Europe\NR
        \NC IBM PC DOS\NC ibm\NC Western Europe\NR
        \NC UTF-8\NC utf\NC Unicode\NR
        \NC VISCII\NC vis,  viscii\NC Vietnamese\NR
        \NC DOS CP 866\NC cp866, cp866nav\NC Cyrillic\NR
        \NC KOI8\NC koi8-r, koi8-u, koi8-ru\NC Cyrillic\NR
        \NC Mac Cyrillic\NC maccyr, macukr\NC Cyrillic\NR
        \NC Others\NC cp855, cp866av, cp866mav, cp866tat, \NC Various\NR
        \NC \NC ctt, dbk, iso88595, isoir111, mik, mls, \NC\NR
        \NC \NC mnk, mos, ncc\NC\NR
        \HL
      \stoptabulate
    }
}

\ConTeXt\ Mk IV настоятельно рекомендует использовать UTF-8. Я согласен с этой рекомендацией. Начиная с этого введения, мы можем предположить, что всегда используется кодировка UTF-8.

\startSmallPrint

Вместе с \tex{enableregime} \ConTeXt\ включает команду \PlaceMacro{useregime}\tex{useregime}, которая позволяет нам использовать код для той или иной кодировки в качестве аргумента. Я не нашел информации ни об этой команде, ни о том, чем она отличается от \tex{enableregime}, только несколько примеров её использования \Conjecture. Я подозреваю, что \tex{useregime} разработан для сложных проектов, в которых используется много исходных файлов, и предполагается, что не все из них будут иметь одинаковую кодировку. Но это только предположение.

\stopSmallPrint

\stopsection

\startsection
  [title={Символы в исходных файлах, которые \ConTeXt\ обрабатываются особым образом}]

{\em Специальные символы} -- это имя, которое я дал группе символов, которые отличаются от {\em зарезервированных символов}. Как видно из \in{section}[sec: зарезервированные символы], они имеют особое значение для \ConTeXt\ и поэтому не могут использоваться непосредственно как символы в исходном файле. Наряду с ними существует еще одна группа символов, которые, хотя и рассматриваются как таковые \ConTeXt, когда он находит их в исходном файле, он обрабатывает их по особым правилам. В эту группу входят пробелы (пробелы), табуляции, разрывы строк и дефисы.

\startsubsection
  [title={Пробелы (пустые пространства) и табуляции}, reference=sec:spaces]

Табуляторы и пробелы в исходном файле обрабатываются одинаково для всех целей и задач. Символ табуляции (клавиша Tab на клавиатуре) будет преобразован \ConTeXt\ в пробел. И пустые места поглощаются любым другим пустым пространством (или табуляцией) сразу после них. Таким образом, нет абсолютно никакой разницы в исходном файле для записи

\type{Tweedledum and Tweedledee.}

or

\type{Tweedledum   and   Tweedledee.}

\ConTeXt{} считает эти два предложения абсолютно одинаковыми. Следовательно, если мы хотим ввести дополнительный пробел между словами, нам нужно использовать некоторые команды \ConTeXt{}, которые делают это. Обычно он работает с \quotation{\cmd{\textvisiblespace}}, что означает символ {\tt\backslash}, за которым следует пробел. Но есть и другие процедуры, которые будут рассмотрены в \in{chapter}[sec:horizontal space1] относительно горизонтального пространства.

Поглощение следующих друг за другом пустых пространств позволяет нам писать исходный файл, визуально выделяя части, которые мы хотели бы выделить, просто увеличивая или уменьшая используемый отступ, со спокойствием зная, что это никоим образом не повлияет на окончательный документ. Таким образом, в следующем примере

\starttyping

The music group from Madrid at the end of the seventies {\em La Romántica
  Banda Local} wrote songs of an eclectic style that were very difficult to
categorise. In their son “El Egipcio”, for example, they said:
\quotation{{\em Esto es una farsa más que una comedia, página muy seria
  de la histeria musical; sueños de princesa, vicios de gitano pueden en
  su mano acariciar la verdad}}, mixing word, phrases simply because they
have an internal rhythm (comedia-histeria-seria, gitano-mano).

\stoptyping

вы можете увидеть, как некоторые линии слегка смещены вправо. Это строки, которые являются частью фрагментов, которые будут выделены курсивом. Наличие этих отступов помогает (автору) увидеть, где заканчивается курсив.

\startSmallPrint

Некоторые могут подумать, что за бардак! Придется ли мне возиться с отступами строк? На самом деле этот специальный отступ выполняется автоматически моим текстовым редактором (GNU Emacs), когда он редактирует исходный файл \ConTeXt. Это такая небольшая подсказка, которая заставляет вас выбирать работу с одним текстовым редактором, а не с другим.

\stopSmallPrint

Правило поглощения пробелов применяется исключительно к последовательным пробелам в исходном файле. Следовательно, если пустая группа (\MyKey{\{\}}) помещается в исходный файл между двумя пробелами, хотя пустая группа ничего не создаст в конечном файле, её присутствие гарантирует, что эти два пробела не будут последовательными. Например, если мы напишем  \MyKey{Tweedledum \{\} и Tweedledee}, мы получим \quotation{\color[red]{Tweedledum {} и Tweedledee}}, где, если вы внимательно присмотритесь, вы увидите два последовательных пробела между первыми двумя словами.

То же самое происходит с зарезервированным символом \MyKey{\lettertilde}, хотя его эффект заключается в создании пробела, хотя на самом деле это не так: пробел, за которым следует \lettertilde\, не поглотит последний, а пробел после \lettertilde\ не будет впитаться тоже.


\stopsubsection

\startsubsection
  [reference=sec:linebreaks, title=Разрывы строк]

В большинстве текстовых редакторов, когда строка превышает максимальную ширину, автоматически вставляется разрыв строки. Мы также можем явно вставить разрыв строки, нажав клавишу  \quotation{Enter} или \quotation{Return}


\ConTeXt{}применяет следующие правила к разрывам строк:

\startitemize[a, broad]

\item Одиночный разрыв строки во всех смыслах равен пробелу. Следовательно, если непосредственно перед или после разрыва строки есть какое-либо пустое пространство или табуляция, они будут поглощены разрывом строки или первым пустым пространством, а в окончательный документ будет вставлено простое пустое пространство.

\item  Два или более разрыва строки подряд создают разрыв абзаца. Для этого два разрыва строки считаются последовательными, если между первым и вторым разрывом строки нет ничего, кроме пробелов или табуляции (поскольку они поглощаются первым разрывом строки); что, вкратце, означает, что одна или несколько последовательных строк, которые являются абсолютно пустыми в исходном файле (без каких-либо символов в них или только с пробелами или табуляциями), становятся разрывом абзаца.

\stopitemize

Обратите внимание, что я сказал «два или более последовательных разрывов строки», а затем «одна или несколько пустых последовательных строк», имея в виду, что если мы хотим увеличить расстояние между абзацами, мы не делаем это просто, вставляя еще один разрыв строки. Для этого нам нужно использовать команду, увеличивающую вертикальное пространство. Если нам нужна только одна дополнительная разделительная строка, мы можем использовать команду \PlaceMacro{blank}\tex{blank}. Но есть и другие способы увеличения вертикального пространства. Я обращаюсь к \in{section}[sec:verticalspace].

\startSmallPrint

В некоторых случаях, когда разрыв строки становится пробелом, мы можем получить нежелательные и неожиданные пробелы. Особенно, когда мы пишем макросы, где пустое пространство легко  \quotation{sneak in}, даже если мы этого не осознаем. Чтобы избежать этого, мы можем использовать зарезервированный символ \MyKey{\%}, который, как мы знаем, приводит к тому, что строка, в которой он окажется, не обрабатывается, что означает, что разрыв в конце строки также не будет обрабатываться. Так, например, команда

\vbox{
\starttyping
\define[3]\Test{
  {\em #1}
  {\bf #2}
  {\sc #3}
}
\stoptyping
}

который пишет свой первый аргумент курсивом, второй жирным шрифтом, а третий прописными буквами, вставит пробел между каждым из этих аргументов, в то время как


\starttyping
\define[3]\Test{%
  {\em #1}%
  {\bf #2}%
  {\sc #3}%
}
\stoptyping

не будет вставлять пробелы между ними, поскольку зарезервированный символ \% предотвращает обработку разрывов строк и просто становится пробелом.

\stopSmallPrint

\stopsubsection

\startsubsection
  [reference=sec:dashes, title=Rules/dashes]

Тире -- хороший пример разницы между компьютерной клавиатурой и печатным текстом. На обычной клавиатуре обычно есть только один символ для тире (или правила, в типографских терминах), который мы называем дефисом или (\MyKey{-}); но печатный текст использует до четырех разных длин для правил:

\startitemize[1,broad]

\item Короткие черточки (дефисы), подобные тем, которые используются для разделения слогов в переносах в конце строки (-).

\item Черточки среднего размера (en тире или en дефисы), немного длиннее предыдущих (--). Они имеют ряд применений, в том числе для некоторых европейских языков (в меньшей степени на английском языке) в начале строки диалога или для отделения меньших от больших цифр в диапазоне дат или страниц; \quotation{pp. 12--33}.

\item Длинные (тире или правила em) (---), используемые в качестве скобок для включения одного предложения в другое.

\item Знак минус ($-$) для обозначения вычитания или отрицательного числа.

\stopitemize

Сегодня все вышеперечисленное и другие доступны в кодировке UTF-8. Но поскольку все они не могут быть созданы одной клавишей на клавиатуре, их не так просто создать в исходном файле. К счастью, \TeX\ увидел необходимость включить в наш окончательный документ больше черточек / тире, чем может быть создано с помощью клавиатуры, и разработал простую процедуру для этого. \ConTeXt{} дополнил эту процедуру, добавив также команды, которые генерируют эти различные типы черточек. Мы можем использовать два подхода для создания четырех видов правил: либо обычный метод \ConTeXt{} с помощью команды, либо непосредственно с клавиатуры. Эти процедуры показаны в \in{table}[tbl:rules]:

{\switchtobodyfont[small]
\placetable
  [here]
  [tbl:rules]
  {Rules/dashes in \ConTeXt}
  {\starttabulate[|l|c|c|l|]
    \HL
    \NC {\bf Type of rule}
    \NC {\bf Appearance}
    \NC {\bf Written directly}
    \NC {\bf Command}
    \NR
    \HL
    \NC Hyphen
    \NC -
    \NC {\tt -}
    \NC \PlaceMacro{hyphen}\tex{hyphen}
    \NR
    \NC En rule
    \NC --
    \NC {\tt --}
    \NC \PlaceMacro{endash}\tex{endash}
    \NR
    \NC Em rule
    \NC ---
    \NC {\tt ---}
    \NC \PlaceMacro{emdash}\tex{emdash}
    \NR
    \NC Minus sign
    \NC $-$
    \NC {\tt \$-\$}
    \NC \PlaceMacro{minus}\tex{minus}
    \NR
    \HL
  \stoptabulate}
}

Имена команд tex{hyphen} и \tex{minus} обычно используются в английском языке. Хотя многие в полиграфической отрасли называют их \quote{rules}, термины \TeX, а именно \tex{endash} и \tex{emdash}, также распространены в терминологии набора.  \quotation{{\em en}} и \quotation{{\em em}} - это названия единиц измерения, используемых в типографике.  \quotation{en} обозначает ширину \quote{n}, а \quotation{em} -- ширину \quote{m} в используемом шрифте.

\stopsection

\startsection
  [title=Простые и многофайловые проекты]

В \ConTeXt\ мы можем использовать только один исходный файл, который включает в себя абсолютно все содержимое нашего окончательного документа, а также все детали, относящиеся к нему, и в этом случае мы говорим о «простых проектах» или, напротив, мы могли бы использовать несколько исходных файлов, которые разделяют содержимое нашего окончательного документа, и в данном случае мы говорим о «многофайловых проектах».

Сценарии, при которых типично работать с более чем одним исходным файлом, следующие:

\startitemize

\item Если мы пишем документ, в котором участвовало несколько авторов, у каждого из которых есть своя часть, отличная от других; например, если мы пишем праздничную брошюру с участием разных авторов, номера журнала и т.д.

\item Если мы пишем объемный документ, в котором каждая часть (глава) имеет относительную автономию, так что их окончательная компоновка допускает несколько возможностей и будет определена в конце. Это происходит с относительной частотой для многих академических текстов (руководств, введений и т.п.), где порядок глав может варьироваться.


\item Если мы пишем ряд связанных документов, которые имеют некоторые стилевые характеристики.

\item Если, проще говоря, документ, над которым мы работаем, большой, так что компьютер тормозит либо при его редактировании, либо при компиляции; в этом случае разделение материала на несколько исходных файлов значительно ускорит компиляцию каждого из них.

\item Кроме того, если мы написали ряд макросов, которые хотим применить в некоторых (или во всех) наших документах, или если мы создали шаблон, который управляет или стилизует наши документы, и мы хотим применить их к ним и т.д.

\stopitemize

\stopsection

\startsection
  [title=Структура исходного файла в простых проектах,
  reference=sec:structure]

В простых проектах, разработанных в одном исходном файле, структура очень проста и вращается вокруг \MyKey{text} среды, которая, по сути, должна находиться в том же файле. Мы различаем следующие части этого файла:

\startitemize

\item {\bf Преамбула документа}: все от первой строки файла до начала \MyKey{text} среды (\PlaceMacro{starttext}\PlaceMacro{stoptext}\tex{starttext}).

\item {\bf Тело документа}: это содержимое \MyKey{text} среды; или, другими словами, все между \tex{starttext} и \tex{stoptext}.

\stopitemize

\placefigure
  [here]
  [img:ProyectoSimple]
  {\tfx file containing a simple project}
{\startframedtext
\starttyping
% First line of the document

% Preamble area:
% Containing the global configuration
% commands for the document

\starttext % The body of the document begins here

...
... % Document contents
...

\stoptext % End of the document

\stoptyping
\stopframedtext}

На \in{figure}[img:ProyectoSimple] мы видим очень простой исходный файл. Абсолютно все, что находится перед командой \tex{starttext} (которая на картинке находится в строке 5, считая только те, на которых есть текст), составляет преамбулу; все между \tex{starttext} и  \tex{stoptext} составляет тело документа. Все, что находится после stoptext, будет проигнорировано.



{\bf Преамбула} используется для включения команд, влияющих на документ в целом, тех, которые определяют его общую конфигурацию. Писать какую-либо команду в преамбуле не обязательно. Если её нет, \ConTeXt\ примет конфигурацию по умолчанию, которая не очень развита, но подходит для многих документов. В хорошо спланированном документе преамбула будет содержать все команды, влияющие на документ в целом, такие как макросы и настраиваемые команды, которые будут использоваться в исходном файле. В типичной преамбуле это может включать следующее:

\startitemize[packed]

\item Указание основного языка документа (см. \in{section}[sec:langdoc]).

\item Указание размера бумаги (\in{section}[sec:papersize]) и макета страницы (\in{section}[sec:pagelayout]).

\item Особенности основного шрифта документов  (\in{section}[sec:mainfont]).

 \item Настройка используемых команд раздела   (\in{section}[sec:setuphead]) и, при необходимости, определение новых команд раздела (\in{section}[sec:definehead]).

\item Макет верхних и нижних колонтитулов (\in{section}[sec:headerfooter]).

\item Настройки собственных макросов (\in{section}[sec:definingcommands]).

\item Так далее.

\stopitemize

Преамбула предназначена для общей конфигурации документа; поэтому здесь не должно быть ничего, что связано с содержимым {\em contents} документа или обрабатываемым текстом. Теоретически любой обрабатываемый текст, включенный в преамбулу, будет проигнорирован, хотя иногда, если он там есть, это вызовет ошибку компиляции.

{\bf Тело документа}, заключенное между командами \tex{starttext} и \tex{stoptext}, включает фактическое содержимое, то есть обрабатываемый текст, а также команды \ConTeXt, которые не должны влиять на весь документ.

\stopsection

\startsection
  [title=Многофайловое управление в стиле \TeX]

Чтобы работать с более чем одним исходным файлом, \TeX\ включил примитив под названием \tex{input}, который также работает в \ConTeXt, хотя последний включает две специфические команды, которые в некоторой степени улучшают способ функции \tex{input}.

\stopsection

\startsubsection
  [reference=input, title=Команда \tex{input}]
\PlaceMacro{input}

Команда  \tex{input} вставляет содержимое указанного файла. Его формат:

\type{\input FileName}

где  {\em FileName} -- имя вставляемого файла. Обратите внимание, что имя файла не обязательно заключать в фигурные скобки, даже если это не приведет к возникновению ошибки. Однако его нельзя заключать в квадратные скобки. Если расширение файла \quotation{\type{.tex}}, его можно не указывать.

Когда \ConTeXt\ компилирует документ и находит команду \tex{input}, он ищет указанный файл и продолжает компиляцию, как если бы этот файл был частью файла, который его вызвал. Когда он завершает его компиляцию, он возвращается к исходному файлу и продолжает с того места, где он остановился; практический результат, таким образом, состоит в том, что содержимое файла, вызываемого с помощью \tex{input}, вставляется в точку, где он был вызван. Файл, вызываемый с помощью \tex{input}, должен иметь допустимое имя в нашей операционной системе и без пробелов в имени. \ConTeXt\ будет искать его в рабочем каталоге, и если он не найдет его там, он будет искать его в каталогах, включенных в переменную среды TEXROOT. Если файл в конечном итоге не будет найден, произойдет ошибка компиляции.

Чаще всего команда \tex{input} используется следующим образом: записывается файл, назовем его \MyKey{principal.tex}, и он будет использоваться в качестве контейнера для вызова с помощью команды \tex{input} различных файлов, составляющих наш проект. Это показано в следующем примере:

\startframedtext\switchtobodyfont[small]
\starttyping
% General configuration commands:

  \input MyConfiguration

\starttext

  \input PageTitle
  \input Preface
  \input Chap1
  \input Chap2
  \input Chap3

  ...

\stoptext
\stoptyping
\stopframedtext

Обратите внимание, как для общей конфигурации документа мы назвали файл \quotation{MyConfiguration.tex}, который, как мы предполагаем, содержит глобальные команды, которые мы хотим применить. Затем между командами  \tex{starttext} и \tex{stoptext} мы вызываем несколько файлов, которые содержат содержимое различных частей нашего документа. Если в какой-то момент для ускорения процесса компиляции мы хотим исключить компиляцию некоторых файлов, все, что нам нужно сделать, это поставить отметку комментария в начале строки, вызывающей тот или иной файл. Например, если мы пишем третью главу и хотим скомпилировать её просто для того, чтобы проверить, нет ли в ней ошибок, нам не нужно компилировать остальную часть, и поэтому мы можем написать:

\startframedtext\switchtobodyfont[small]
\starttyping
% General configuration commands:

  \input MyConfiguration

\starttext

  % \input PageTitle
  % \input Preface
  % \input Chap1
  % \input Chap2

  \input Chap3

  ...

\stoptext
\stoptyping
\stopframedtext

и будет скомпилирована только Глава 3. Обратите внимание, что, с другой стороны, изменить порядок глав так же просто, как изменить порядок вызывающих их строк.


\startSmallPrint

Когда мы исключаем файл в многофайловом проекте из компиляции, мы увеличиваем скорость обработки, но в результате все ссылки, которые компилируемая часть делает на другие части, которые еще не скомпилированы, больше не будут работать. См. \in{section}[sec:references].

\stopSmallPrint

Важно понимать, что когда мы работаем с  \tex{input}, только главный файл, тот, который вызывает все остальные, должен включать команды\tex{starttext} и \tex{stoptext}, потому что, если другие файлы включают их, будет ошибка. Это, с другой стороны, означает, что мы не можем напрямую скомпилировать различные файлы, составляющие проект, но обязательно должны скомпилировать их из основного файла, который содержит основную структуру документа.

\stopsubsection

\startsubsection
  [title=\tex{ReadFile} и \tex{readfile}]
\PlaceMacro{ReadFile}\PlaceMacro{readfile}

Как мы только что видели, если \ConTeXt\ не найдет файл с именем \tex{input}, он выдаст ошибку. Для ситуации, когда мы хотим вставить файл только в том случае, если он существует, но с учетом возможности того, что он может и не быть, \ConTeXt\ предлагает вариант команды \tex{input}. Это

\type{\ReadFile{FileName}}

Эта команда похожа на \tex{input} во всех отношениях, за исключением того, что если файл, который нужно вставить, не найден, он продолжит компиляцию без каких-либо ошибок. Он также отличается от \tex{input} своим синтаксисом, поскольку мы знаем, что с \tex{input} нет необходимости помещать имя файла, который будет вставлен между фигурными скобками. Но с \tex{ReadFile} это необходимо. Если мы не будем использовать фигурные скобки, \ConTeXt\ будет считать, что имя искомого файла совпадает с первым символом, следующим за командой \tex{ReadFile}, за которым следует расширение \type{.tex}. Так, например, если мы напишем

\type{\ReadFile MyFile}

\ConTeXt\ поймет, что файл, который нужно прочитать, называется \quotation{\type{M.tex}}, поскольку символ сразу после команды \type{\ReadFile} (исключая пробелы, которые, как мы знаем, игнорируются в конце имени команды) -- это \quote{M}. Поскольку \ConTeXt\ обычно не находит файл с именем \quotation{\type{M.tex}}, а \tex{ReadFile} не генерирует ошибку, если не находит файл, \ConTeXt\ продолжит компиляцию после  \quote{M} в «MyFile» и вставит текст  \quotation{\type{yFile}}.

Более усовершенствованная версия tex{ReadFile} -- это \tex{readfile}, формат которой

\type{\readfile{FileName}{TextIfExists}{TextIfNotExists}}

Первый аргумент аналогичен \type{\ReadFile}: имя файла, заключенное в фигурные скобки. Второй аргумент включает текст, который будет записан, если файл существует, перед вставкой содержимого файла. Третий аргумент включает текст, который будет записан, если рассматриваемый файл не найден. Это означает, что в зависимости от того, найден ли файл, введенный в качестве первого аргумента, будет выполнен второй аргумент (если файл существует) или третий (если файл не существует).

\stopsubsection

\stopsection

\startsection
  [title=\ConTeXt\ проекты как таковые,
  reference=sec-projects]

Третий механизм, который \ConTeXt\ предлагает для многофайловых проектов, является более сложным и полным: он начинается с различения файлов проекта, файлов продукта, файлов компонентов и файлов среды. Чтобы понять взаимосвязь и функционирование каждого из этих типов файлов, я думаю, что лучше всего объяснить их каждый в отдельности:

\startsubsection
  [reference=environments, title={Файлы {\em среды }}]
\PlaceMacro{startenvironment}\PlaceMacro{environment}

Файл среды - это файл, в котором хранятся макросы и конфигурации определенного стиля, который предназначен для применения к нескольким документам, независимо от того, являются ли они полностью независимыми документами или частями сложного документа. Таким образом, файл окружения может включать все, что мы обычно пишем перед \tex{starttext}; то есть: общая конфигурация документа.

\startSmallPrint

Я сохранил термин «файлы среды» для этих типов файлов, чтобы не отходить от официальной терминологии \ConTeXt\, даже несмотря на то, что я считаю, что лучшим термином, вероятно, будет «файлы форматирования» или «файлы глобальной конфигурации».

\stopSmallPrint

Как и все исходные файлы \ConTeXt, файлы среды являются текстовыми файлами и предполагают, что расширение будет \quotation{\type{.tex}}, хотя, если мы хотим, мы можем изменить его, возможно, на \quotation{\type{.env}}. Однако обычно это не делается в \ConTeXt. Чаще всего файл среды идентифицируется по имени, начинающемуся или заканчивающемуся на  \quote{env}. Например: \quotation{\type{MyMacros_env.tex}} или \quotation{\type{env_MyMacros.tex}}. Внутри такой файл окружения будет выглядеть примерно так:

\startframedtext\switchtobodyfont[small]
\starttyping

\startenvironment MyEnvironment

  \mainlanguage[en]

  \setupbodyfont
    [modern]

  \setupwhitespace
    [big]

  ...

\stopenvironment

\stoptyping
\stopframedtext

Другими словами, определения и команды настройки входят в \tex{startenvironment} и \tex{stopenvironment}. Сразу после \tex{startenvironment} мы пишем имя, по которому мы хотим идентифицировать рассматриваемую среду, а затем включаем все команды, из которых мы хотели бы, чтобы наша среда состояла.

\startSmallPrint

Что касается имени среды, согласно моим тестам, имя, которое мы добавляем сразу после \tex{startenvironment}, является просто ориентировочным, и если бы мы не дали ему имени, то ничего (плохого) не произошло.

\stopSmallPrint

Файлы среды предназначались для работы с компонентами и продуктами (объяснено в следующем разделе). Вот почему одна или несколько сред могут быть вызваны из компонента или продукта с помощью команды \tex{environment}. Но эта команда также работает, если она используется в области конфигурации (преамбуле) любого исходного файла \ConTeXt, даже если это не исходный файл, предназначенный для компиляции по частям.

Команду  \tex{environment} можно вызвать в любом из двух следующих форматов:

\type{\environment File}

\type{\environment[File]}

В любом случае результатом этой команды будет загрузка содержимого файла, взятого в качестве аргумента. Если этот файл не найден, он продолжит компилирование обычным способом без каких-либо ошибок. Если расширение файла \quotation{\type{.tex}}, его можно не указывать.

\stopsubsection

\startsubsection
  [reference=components and products, title=Компоненты и продукты]
\PlaceMacro{startcomponent}\PlaceMacro{startproduct}\PlaceMacro{product}

Если мы подумаем о книге, в которой каждая глава находится в отдельном исходном файле, то мы бы сказали, что главы - это {\em компоненты}, а книга - это {\em product}. Это означает, что {\em component} является автономной частью {\em product}, способной иметь свой собственный стиль и компилироваться независимо. У каждого компонента будет отдельный файл, и, кроме того, будет файл продукта, который объединяет все компоненты.

Типичный компонентный файл выглядит следующим образом

\startframedtext\switchtobodyfont[small]
\starttyping

\environment MyEnvironment
\environment MyMacros

\startcomponent Chapter1

  \startchapter[title={Chapter 1}]

  ...

\stopcomponent

\stoptyping
\stopframedtext

И файл продукта будет выглядеть следующим образом:

\startframedtext\switchtobodyfont[small]
\starttyping

\environment MyEnvironment
\environment MyMacros

\startproduct MyBook

  \component Chapter1
  \component Chapter2
  \component Chapter3

  ...

\stopproduct

\stoptyping
\stopframedtext

Обратите внимание, что фактическое содержимое нашего документа будет распределено между различными файлами «компонентов», а файл продукта ограничен установкой порядка компонентов. С другой стороны, (отдельные) компоненты и продукты могут быть скомпилированы напрямую. При компиляции продукта создается PDF-файл, содержащий все компоненты этого продукта. Если, с другой стороны, один из компонентов компилируется отдельно, он сгенерирует файл pdf, содержащий только скомпилированный компонент.

В файле компонента и перед командой \tex{startcomponent} мы можем вызвать один или несколько файлов среды с помощью \tex{environment
EnvironmentName}. То же самое можно сделать в файле продукта перед \tex{startproduct}. Одновременно могут быть загружены несколько файлов среды. Например, у нас может быть наша любимая коллекция макросов и различных стилей, которые мы применяем к нашим документам, в разных файлах. Однако обратите внимание, что когда мы используем две или более среды, они загружаются в том порядке, в котором они вызываются, так что если одна и та же команда конфигурации была включена в более чем одну среду и имеет разные значения, значения последней загруженной среды. С другой стороны, файлы среды загружаются только один раз, поэтому в предыдущих примерах, в которых среда вызывается из файла продукта и из определенных файлов компонентов, если мы компилируем продукт, это время загрузки среды и в указанном там порядке; когда среда вызывается из любого из компонентов, \ConTeXt\ проверяет, загружена ли среда уже, и в этом случае ничего не будет делать.

Имя компонента, вызываемого из продукта, должно быть именем файла, содержащего рассматриваемый компонент, хотя, если расширение этого файла - \quotation{\type{.tex}}, его можно не указывать.

\stopsubsection

\startsubsection
  [title=Проекты как таковые]
\PlaceMacro{startproject}\PlaceMacro{project}

В большинстве случаев достаточно проводить различие между продуктами и компонентами. Точно так же \ConTeXt\ имеет еще более высокий уровень, на котором мы можем сгруппировать ряд продуктов: это {\em проект}.

Типичный файл проекта будет выглядеть примерно следующим образом

\startframedtext\switchtobodyfont[small]
\starttyping

\startproject MyCollection

  \environment MyEnvironment
  \environment MyMacros

  \product Book01
  \product Book02
  \product Book03

  ...

\stopproject

\stoptyping
\stopframedtext

Сценарий, в котором нам понадобится проект, будет, например, когда нам нужно отредактировать коллекцию книг, все с одинаковыми спецификациями формата; или если бы мы редактировали журнал: сборник книг или журнал как таковой были бы проектом; каждая книга или каждый выпуск журнала были бы продуктом; и каждая глава книги или каждая статья в журнальном выпуске будет составляющей.

С другой стороны, проекты не предназначены для непосредственной компиляции. Учтите, что по определению каждый продукт, принадлежащий проекту (каждая книга в коллекции или каждый выпуск журнала), должен быть скомпилирован отдельно и генерировать свой собственный PDF-файл. Поэтому включенная в него команда \tex{product}, указывающая, какие продукты принадлежат проекту, на самом деле ничего не делает: это просто напоминание для автора.

Ясно, что некоторые могут спросить, зачем у нас проекты, если они не могут быть скомпилированы: ответ заключается в том, что файл проекта связывает определенные среды с проектом. Вот почему, если мы включим команду \PlaceMacro{project}\tex{project ProjectName} в файл компонента или продукта, \ConTeXt\ прочитает файл проекта и автоматически загрузит связанные с ним среды. Вот почему команда \tex{environment} в проектах должна идти после \tex{startproject}; однако в продуктах и ​​компонентах \tex{environment} должен {\em предшествовать} \tex{startproduct} или \tex{startcomponent}.

Как и в случае с командами \tex{environment} и \tex{component}, команда \tex{project} позволяет указать имя проекта либо внутри квадратных скобок, либо вообще не использовать квадратные скобки. Это означает, что \tex{project FileName} и \tex{Project[FileName]}  являются эквивалентными командами.

{\bf Резюме различных способов загрузки окружения}

Из вышесказанного следует, что окружение может быть загружено любой из следующих процедур:

\startitemize[a, broad]

\item Вставив команду \tex{environment EnvironmentName} перед \tex{starttext} или \tex{startcomponent}. Это загрузит среду только для компиляции рассматриваемого файла.

\item Вставив команду \tex{environment EnvironmentName} в файл продукта перед \tex{startproduct}. Это загрузит среду при компиляции продукта, но не в том случае, если его компоненты компилируются индивидуально.

\item Вставив команду \tex{project} в продукт или среду: это загрузит все среды, связанные с проектом (в файле проекта).

\stopitemize

\stopsubsection

\startsubsection
  [title={Общие аспекты сред,\\ компонентов, продуктов и проектов}]

\startdescription{Названия сред, компонентов, продуктов и проектов:}

мы уже видели, что для всех этих элементов после команды \tex{start}, запускающей конкретную среду, компонент, продукт или проект, непосредственно вводится его имя. Это имя, как правило, должно совпадать с именем файла, содержащего среду, компонент или продукт, потому что, например, когда \ConTeXt\ компилирует продукт и, согласно файлу продукта, должен загружать среду или компонент, у нас нет способа узнать, к какому файлу относится эта среда или компонент, если только файл не имеет то же имя, что и загружаемый элемент.

В противном случае, согласно моим тестам, имя, написанное после tex{startproduct} или \tex{startenvironment} в файлах продукта и среды, является просто ориентировочным. Если он опущен или не соответствует имени файла, ничего плохого не произойдет. Однако в случае компонентов важно, чтобы имя компонента совпадало с именем файла, который его содержит.

\stopdescription

\description{Структура каталогов проекта:}

Мы знаем, что по умолчанию \ConTeXt\ ищет файлы в рабочем каталоге и по пути, указанному переменной TEXROOT. Однако, когда мы используем команды \tex{project}, \tex{product}, \tex{component} или \tex{environment}, предполагается, что проект имеет структуру каталогов, в которой общие элементы находятся в родительском каталоге, а определенные - в некотором дочернем каталоге. Таким образом, если файл, указанный в рабочем каталоге, не найден, он будет найден в его родительском каталоге, а если он также не найден, в родительском каталоге этого каталога и так далее.

\stopsubsection

\stopsection

\stopchapter

\stopcomponent

%%% Local Variables:
%%% mode: ConTeXt
%%% mode: auto-fill
%%% coding: utf-8-unix
%%% TeX-master: "../introCTX.mkiv"
%%% End:
%%% vim:set filetype=context tw=75 : %%%
