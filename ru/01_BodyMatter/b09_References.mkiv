%%% File:      b09_References.mkiv
%%% Author:    Joaquín Ataz-López
%%% Begun:     July 2020
%%% Concluded: August 2020
%%% Contents:  Just like the previous chapter, initially, this
%            chapter was considered to be a section of Chapter 12. But
%            when I began writing it I saw that it affected the document
%            as a whole, so it changed place.  In this case the
%            information comes fundamentally from the wiki.
%
%%% Edited with: Emacs + AuTeX - And at times vim + context-plugin
%%%

\environment ../introCTX_env.mkiv

\startcomponent b09_References.mkiv

\startchapter
  [title=Литературные ссылки и гиперлинки]

\TocChap

\startsection
  [title=Типы ссылок]

Научно-техническая документация изобилует ссылками:

\startitemize

\item  Иногда они ссылаются на другие документы, которые являются основанием для того, что говорится, или которые противоречат тому, что объясняется, или которые развивают или усугубляют нюансы рассматриваемой идеи и т.д. В этих случаях ссылка считается {\em внешней} и, если документ должен быть академически строгим, ссылка должна иметь форму {\em цитат} из литературы.

\item Но также обычно в документе в одном из его разделов ссылаются на другой из его разделов, и в этом случае ссылка считается {\em внутренней}. Также существует внутренняя ссылка, когда точка в документе комментирует какой-либо аспект определенного изображения, таблицы, заметки или элемента аналогичного характера, ссылаясь на него по его номеру или по странице, на которой он находится.

В целях точности внутренние ссылки должны быть нацелены на точное и легко определяемое место в документе. Следовательно, такого рода ссылки всегда являются ссылкой либо на пронумерованные элементы (как, например, когда мы говорим «см. Таблицу 3.2» или «Главу 7»), либо на номера страниц. Расплывчатые ссылки типа «как мы уже сказали» или «как мы увидим дальше» не являются истинными ссылками, и нет никаких специальных требований для их набора, и для этого нет какого-либо специального инструмента. Кроме того, я лично отговариваю своих аспирантов или магистрантов от привычного использования этой практики.

\startSmallPrint

Внутренние ссылки также обычно называют «перекрестными ссылками» (cross references), хотя в этом документе я буду просто использовать термин «ссылки» (references) в целом и «внутренние ссылки» (internal references), когда я хочу быть конкретным.

\stopSmallPrint

\stopitemize

Чтобы прояснить терминологию, которую я использую для ссылок, я назову точку в документе, где вводится ссылка, ({\em источником (origin)}), а место, на которое она указывает, --  {\em целью (target)}. С этой точки зрения мы бы сказали, что ссылка является внутренней, когда источник и цель находятся в одном документе, и внешней, когда источник и цель находятся в разных документах.

С точки зрения верстки документа

\startitemize

\item Внешние ссылки не представляют особой проблемы и, следовательно, в принципе не требуют каких-либо инструментов для их введения: все данные, которые мне нужны из целевого документа, доступны мне, и я могу использовать их в ссылке. Однако, если исходный документ является электронным документом, а целевой документ также доступен в Интернете, то в ссылку можно включить гиперссылку, которая позволяет перейти непосредственно к цели. В этих случаях документ происхождения можно назвать интерактивным {\em interactive}.

\item Напротив, внутренние ссылки создают проблему для верстки документа, поскольку любой, кто имеет опыт подготовки научно-технических документов средней длины, знает, что нумерация страниц, разделов, изображений, таблиц, теорем или аналогичных тому, что указано в ссылке, почти неизбежно изменится во время подготовки документа, что очень затрудняет его обновление.

\startSmallPrint

В докомпьютерные времена авторы избегали внутренних ссылок; а те, которые были неизбежны, такие как оглавление (которое, если оно сопровождается номером страницы каждого раздела, является примером внутренней ссылки), писались в конце.

\stopSmallPrint

\stopitemize


Даже самые ограниченные системы набора текста, такие как текстовые процессоры, позволяют включать какие-либо внутренние перекрестные ссылки, такие как оглавления. Но это ничто по сравнению с всеобъемлющим механизмом управления ссылками, включенным в \ConTeXt, который также может сочетать внутренний механизм управления ссылками, направленный на поддержание актуальности ссылок, с использованием гиперссылок, что, очевидно, не является исключительным для внешних ссылок.

\stopsection

\startsection
[
reference=sec:references,
title=Внутренние ссылки,
]

Для создания внутренней ссылки необходимы две вещи:

\startitemize[n]

\item Метка или идентификатор в целевой точке. Во время компиляции \ConTeXt будет связывать определенные данные с этой меткой. Какие данные будут связаны, зависит от типа метки; это может быть номер раздела, номер заметки, номер изображения, номер, связанный с конкретным элементом в нумерованном списке, заголовок раздела и т.д.

\item Команда в исходной точке, которая считывает данные, связанные с меткой, связанной с целевой точкой, и вставляет их в исходную точку. Команда различается в зависимости от того, какие данные из метки мы хотим вставить в исходную точку.

\stopitemize

Когда мы думаем о ссылке, мы делаем это в терминах \quotation{origin~\longrightarrow~target} («источник ⟶ цель»), поэтому может показаться, что сначала следует объяснить вопросы, связанные с источником, а затем - с целью. Однако я считаю, что легче понять логику ссылок, если объяснение будет обратным.

\startsubsection
[
reference=sec:target labels,
title=Метка в референтной цели,
]

В этой главе под меткой ({\em label}) я подразумеваю текстовую строку, которая будет связана с целевой точкой ссылки и использоваться внутри для извлечения определенной информации о целевой точке ссылки, такой как, например, номер страницы, номер раздела и т.д. Фактически, информация, связанная с каждой меткой, зависит от процедуры её создания. \ConTeXt\ называет эти ярлыки ссылками {\em references}, но я думаю, что этот последний термин, поскольку он имеет гораздо более широкое значение, менее ясен.

Метка, связанная с целевой ссылкой:

\startitemize

\item  Необходимо, чтобы каждая потенциальная цель в документе была уникальной, чтобы её можно было без сомнения идентифицировать. Если мы используем одну и ту же метку для разных целей, \ConTeXt\ не вызовет ошибку компиляции, но приведет к тому, что все ссылки будут указывать на первую метку, которую он найдет (в исходном файле), и это будет иметь побочный эффект, заключающийся в том, что некоторые из наших ссылок могут быть неправильными и, что ещё хуже, мы их не заметим. Поэтому при создании метки важно убедиться, что новая метка, которую мы назначаем, ещё не была назначена ранее.

\item может содержать буквы, цифры, знаки препинания, пробелы и т.д. Там, где есть пробелы, общие правила \ConTeXt в отношении таких символов по-прежнему применяются (см. \in{section}[sec:spaces]), так что, например, quotation {\type{My nice label}} и \quotation{\type{My   nice   label}} будут восприниматься как одно и то же, хотя в обоих используется разное количество пробелов.

\stopitemize

Поскольку нет ограничений относительно того, какие символы могут быть частью метки и сколько их, я советую использовать понятные имена меток, которые помогут нам понять исходный файл, когда, возможно, мы прочитаем его спустя долгое время после того, как он был первоначально написан. Вот почему пример, который я привел ранее (\quotation{\type{My nice label}}), не является хорошим примером, поскольку он ничего не говорит нам о цели, на которую указывает метка. Например, для этого заголовка лучше использовать ярлык  \quote{sec:Target labels}.

Чтобы связать конкретную цель с меткой, в основном есть две процедуры:

\startitemize[n]

\item С помощью аргумента или параметра команды, используемого для создания элемента, на который будет указывать метка. С этой точки зрения, все команды, которые создают какую-либо структуру или текстовый элемент, открытый для использования в качестве цели ссылки, включают параметр, называемый «ссылка» \MyKey{reference}, который используется для включения метки. Иногда вместо {\em опции} метка является содержанием всего аргумента.

Мы находим хороший пример того, что я пытаюсь сказать, в командах раздела, которые, как мы знаем из (\in{section}[sec:sectionsyntax]), допускают несколько видов синтаксиса. В классическом синтаксисе команда записывается как:

\type{\section[Label]{Title}}

а в синтаксисе, специфичном для \ConTeXt, команда записывается как

\starttyping
\startsection
 [title=Title, reference=Label, ...   ]
\stoptyping

В обоих случаях команда предусматривает введение метки, которая будет связана с рассматриваемым разделом (или главой, подразделом и т.д.).

Я сказал, что эта возможность присутствует во {\em всех командах}, которые позволяют нам создавать текстовый элемент, открытый для использования в качестве цели ссылки. Это все текстовые элементы, которые можно пронумеровать, в том числе, среди прочего, разделы, плавающие объекты всех видов (таблицы, изображения и т.д.), сноски или конечные примечания, цитаты, нумерованные списки, описания, определения и т.д.

\startSmallPrint

Когда метка вводится напрямую с аргументом, а не как опция, которой присваивается значение, с помощью \ConTeXt\ можно связать несколько меток с одной целью. Например:

\type{\chapter[label1, label2, label3] {My chapter}}

Мне не ясно, в чем преимущество наличия нескольких разных меток для одной цели и подозреваю \Conjecture, что это можно сделать не потому, что это даёт преимущества, а из-за некоторых {\em внутренних} требований \ConTeXt, применимых к определенным видам аргументов.

\stopSmallPrint

\item С помощью команд PlaceMacro{pagereference}\tex{pagereference}, \PlaceMacro{reference}\tex{reference}, или \PlaceMacro{textreference}\tex{textreference} синтаксис которых

\starttyping
\pagereference[Label]
\reference[Label]{Text}
\textreference[Label]{Text}
\stoptyping

\startitemize

\item Ярлык, созданный с помощью \tex{pagereference}, позволяет нам получить номер страницы.

\item Ярлыки, созданные с помощью \tex{reference} и \tex{textreference}, позволяют нам получить номер страницы, а также связанный с ними текст, который включен в качестве аргумента.

Как в \tex{reference}, так и в \tex{textreference} текст, связанный с меткой, исчезает как таковой из окончательного документа в точке, где расположена команда (цель ссылки), но может быть извлечен и снова появится в точке происхождения ссылки.

\stopitemize

\stopitemize

Я сказал ранее, что каждая метка связана с определенной информацией о целевой точке. Что это за информация, зависит от типа этикетки:

\startitemize

\item Все метки {\em запоминают} (в том смысле, что они позволяют извлекать) номер страницы команды, которая их создала. Для ярлыков, прикрепленных к разделам, которые могут состоять из нескольких страниц, этот номер будет номером страницы, с которой начинается рассматриваемый раздел.

\item Ярлыки, вставленные с помощью команды, которая создает пронумерованный текстовый элемент (раздел, примечание, таблица, изображение и т.д.), {\em запоминают} номер, связанный с этим элементом (номер раздела, номер заметки и т.д.)

\item Если у этого элемента есть заголовок {\em title}, как, например, для разделов, но также и для таблиц, если они были вставлены с помощью команды \tex{placetable}, они запомнят этот заголовок.

\item Ярлыки, созданные с помощью \tex{pagereference}, {\em запоминают} только номер страницы.

\item Созданные с помощью \tex{reference} или \tex{textreference}, также запоминают связанный с ними текст, который эти команды принимают в качестве аргумента.

\startSmallPrint

На самом деле я не уверен в реальной разнице между командами \tex{reference} и \tex{textreference}. Я думаю, вполне возможно \Conjecture, что дизайн трех команд, которые позволяют создавать метки, пытается работать параллельно с тремя командами, которые позволяют извлекать информацию из меток (что мы увидим чуть позже); но правда в том, что согласно моим тестам, \tex{reference} и \tex{textreference} кажутся избыточными командами

\stopSmallPrint

\stopitemize

\stopsubsection

\startsubsection
[title=Команды в исходной точке отсчета для извлечения данных из целевой точки]

Команды, которые я объясню далее, извлекают информацию из меток и, кроме того, если наш документ интерактивный, генерируют соединение с эталонной целью. Но важная вещь в этих командах -- это информация, полученная с метки. Если мы хотим только сгенерировать соединение, не извлекая никакой информации из метки, мы должны использовать команду \tex{goto}, описанную в разделе \in{section}[sec:createlinks].

\startsubsubsection
[title=Основные команды для получения информации с метки]

Принимая во внимание, что каждая метка, связанная с целевой точкой, может хранить разные элементы информации, логично, что \ConTeXt\ включает три разные команды для получения такой информации: в зависимости от того, какую информацию из опорной целевой точки мы хотим получить, мы используем одну или другую из этих команд:

\startitemize

\item Команда \tex{at} позволяет нам получить номер страницы ярлыка.

\item Для этикеток, которые запоминают номер элемента (номер раздела, номер заметки, номер элемента, номер таблицы и т.д.) В дополнение к номеру страницы, команда \tex{in} позволяет нам получить этот номер.

\item Наконец, для меток, которые запоминают текст, связанный с меткой (заголовок раздела, заголовок изображения, вставленный с помощью \tex{placefigure}, и т.д.), команда \tex{about} позволяет нам получить этот текст.

\stopitemize

Три команды  \PlaceMacro{at}\tex{at} \PlaceMacro{in}\tex{in} \PlaceMacro{about}\tex{about} имеют одинаковый синтаксис:

\starttyping
\at{Text}[Label]
\in{Text}[Label]
\about{Text}[Label]
\stoptyping

\startitemize

\item Label - это метка, с которой мы хотим получить информацию

\item Текст - это текст, написанный непосредственно перед информацией, которую мы хотим получить с помощью команды. Между текстом и данными метки, которую извлекает команда, будет вставлен неразделимый пробел, и если функция интерактивности включена таким образом, что команда, помимо получения информации, генерирует ссылку, которая позволяет нам переходить до целевой точки, то текст, включенный в качестве аргумента, будет частью ссылки (это будет кликабельный текст).

\stopitemize

Итак, в следующем примере мы видим, как \tex{in} извлекает номер раздела, а \tex{at} -- номер страницы.

\startDoubleExample
\starttyping
In \in{section}[sec:target labels], that begins on \at{page}
[sec:target labels], the
characteristics of labels used for
internal references are explained.
\stoptyping

In \in{section}[sec:target labels], that begins on \at{page} [sec:target labels], the characteristics of labels used for internal references are explained.

\stopDoubleExample

Обратите внимание, что \ConTEXt\ автоматически создает гиперссылки (см. Раздел \in{section}[sec:interactivity]), и что текст, принимаемый в качестве аргумента \tex{in} и \tex{at}, является частью ссылки. Но если бы мы написали иначе, результат был бы таким:

\startDoubleExample
\starttyping
In section \in{}[sec:target
labels], that begins on page \at{}
[sec:target labels], the
characteristics of labels used for
internal references are explained.
\stoptyping


In section \in{}[sec:target labels], that begins on page \at{}
[sec:target labels], the characteristics of labels used for internal
references are explained.

\stopDoubleExample

Текст остаётся прежним, но слова {\em section} и {\em page}, предшествующие ссылке, не включаются в ссылку, поскольку они больше не являются частью команды.

Если \ConTeXt\ не может найти метку, на которую указывают команды \tex{at}, \tex{in} или \tex{about}, ошибки компиляции не будет, но там, где информация, полученная этими командами, должна появиться в окончательном документе, мы увидим «??».

\startSmallPrint

\ConTeXt\ не может найти метку по двум причинам:

\startitemize[n]

\item Мы ошиблись при написании.

\item  Мы компилируем только часть документа, а метка указывает на ещё не скомпилированную часть (см. \in{sections}[input] and \in{}[sec-projects]).

\stopitemize

В первом случае ошибку нужно будет исправить. Поэтому, когда мы закончим компиляцию всего документа (и второй случай больше невозможен), будет хорошей идеей искать все появления «??» в PDF, чтобы убедиться, что в документе нет {\em неработающих} ссылок.

\stopSmallPrint

\stopsubsubsection

\startsubsubsection
[title={Получение информации, связанной с меткой, с помощью команды \tex{ref}}]
\PlaceMacro{ref}

Каждая из \tex{at}, \tex{in} и \tex{about} извлекает некоторые элементы метки. Доступна другая команда, которая позволяет нам спасти какой-либо элемент указанной метки. Это команда \tex{ref}, синтаксис которой:

\type{\ref[Element to retrieve][Label]}

где первым аргументом может быть:

\startitemize

\item {\tt text}: возвращает текст, связанный с меткой.

\item {\tt title}: возвращает текст, связанный с меткой.

\item {\tt number}: возвращает число, связанное с меткой. Например, в разделах номер раздела.

\item {\tt page}: возвращает номер страницы.

\item {\tt realpage}: возвращает фактический номер страницы.

\item {\tt default}: возвращает то, что \ConTeXt\ считает {\em естественным} элементом метки. Обычно это совпадает с тем, что возвращает {\tt number}.

\stopitemize

Фактически, \tex{ref} намного точнее, чем \tex{at}, \tex{in} или \tex{about}, и поэтому, например, он различает номер страницы и фактический номер страницы. Номер страницы может не совпадать с фактическим номером, если, например, нумерация страниц документа начинается с 1500 (потому что этот документ является продолжением предыдущего) или если страницы преамбулы были пронумерованы римскими цифрами и при этом нумерация была перезапущена. Точно так же \tex{ref} различает {\em текст} и {\em заголовок}, связанный со ссылкой, чего, например, не делает \tex{about}.

Если \tex{ref} используется для получения информации от метки, в которой такая информация отсутствует (например, заголовок метки, связанный со сноской), команда вернет пустую строку.

\stopsubsubsection

\startsubsubsection
[title={Определение того, куда ведет ссылка}]

В \ConTeXt\ также есть две команды, которые зависят от адреса ссылки {\em the link address}. С помощью \quotation{link address} я намерен определить, находится ли цель ссылки в исходном файле до или после источника. Например: мы пишем наш документ и хотим сослаться на раздел, который всё ещё может быть до или после того, который мы пишем в окончательном оглавлении. Просто мы еще не решили. В этой ситуации было бы полезно иметь команду, которая записывает одно или другое в зависимости от того, находится ли цель в конечном итоге до или после источника в окончательном документе. Для подобных нужд \ConTeXt\ предоставляет команду PlaceMacro{somewhere}\tex{somewhere}, синтаксис которой:

\type{\somewhere{Text if before}{Text if after}[Label]}.

\page[preference]

Например, в следующем тексте:

\starttyping

\color[red]{Адрес гиперссылки также можно определить с помощью команды \type{\somewhere}.
Таким образом, мы также можем найти главы или другие текстовые элементы \somewhere {before}{after} [sec:references] и обсудить их описания в другом месте \somewhere{before}{after} [sec:interactivity].}

\stoptyping

\startnarrower\switchtobodyfont[small]

\stopnarrower

\startSmallPrint

Для этого примера я использовал две фактические метки в этой главе в исходном файле.

\stopSmallPrint

Другая команда, способная определить, идет ли метка, на которую она указывает, до или после, - это \PlaceMacro{atpage}\tex{atpage}, синтаксис которой:

\type{\atpage[label]}

Эта команда очень похожа на предыдущую, но вместо того, чтобы позволить нам писать текст самостоятельно, в зависимости от того, идет ли метка до или после, \tex{atpage} вставляет текст по умолчанию для каждого из двух случаев и, если документ интерактивный, также вставляет гиперссылку.

Текст, который вставляет \tex{atpage}, связан с метками «предыдущая страница» \MyKey{precedingpage} в случае, если метка {\em label}, которую он принимает в качестве аргумента, находится перед командой, а \MyKey{hereafter} -- в противоположном случае.

\startSmallPrint

Когда я подошел к этому моменту, меня предало предыдущее решение: в этой главе я решил назвать то, что \ConTeXt\ называет «ссылкой» \quotation{reference}, «меткой» \quotation{label}. Мне это показалось яснее. Но определенные фрагменты текста, генерируемые командами \ConTeXt, такие как \tex{atpage}, также называются \quotation{labels} «метками» (на этот раз в другом смысле). (См. \in{section}[sec:labels]). Надеюсь, читатель не запутается. Я думаю, что контекст позволяет нам правильно различать, какое из различных значений ярлыка {\em label} я имею в виду в каждом конкретном случае.

\stopSmallPrint

Следовательно, мы можем изменить текст, вставленный с помощью  \tex{atpage}, так же, как мы меняем текст любой другой метки:

\starttyping
\setuplabeltext[en][precedingpage=New text ]
\setuplabeltext[en][hereafter=New text ]
\stoptyping

\startSmallPrint

По этому поводу я считаю, что есть небольшая ошибка в \suite- (дистрибутив, который я использую). Изучая имена предопределенных меток в \ConTeXt, которые можно изменить с помощью \tex{setuplabeltext}, мы обнаруживаем две пары меток, которые являются кандидатами на использование \tex{atpage}:

\startitemize[packed]

\item \MyKey{precedingpage} and \MyKey{followingpage} («предыдущая страница» и «следующая страница»).
\item \MyKey{hencefore} and \MyKey{hereafter} («отсюда» и «далее»).

\stopitemize

Можно предположить, что \tex{atpage} будет использовать либо первую, либо вторую пару. Но на самом деле для предшествующих элементов используется «предыдущая страница» \MyKey{precedingpage}, а для следующих - «в дальнейшем» \MyKey{hereafter}, что, на мой взгляд, непоследовательно.

\stopSmallPrint

\stopsubsubsection

\stopsubsection

\startsubsection
[title={Автоматическая генерация префиксов, чтобы избежать дублирования этикеток}]

В большом документе не всегда легко избежать дублирования надписей. Поэтому желательно навести некоторый порядок в том, как мы выбираем, какие этикетки использовать. Одна из практик, которая помогает -- это использование префиксов для меток, которые будут варьироваться в зависимости от типа метки. Например, \quotation{sec:} для разделов, \quotation{fig:} для рисунков, \quote{tbl:} для таблиц и т.д.

Имея это в виду, \ConTeXt\ включает набор инструментов, которые позволяют:

\startitemize

\item \ConTeXt\ сам автоматически генерирует метки для всех допустимых элементов.

\item Каждая метка, сгенерированная вручную для получения префикса, который мы либо заранее определили, либо автоматически сгенерированы \ConTeXt.

\stopitemize

Подробное объяснение этого механизма является длинным и, хотя они, несомненно, являются полезными инструментами, я не думаю, что они необходимы. Поэтому, поскольку они не могут быть объяснены в нескольких словах, я предпочитаю не объяснять их и ссылаться на то, что сказано о них в справочном руководстве \ConTeXt\ или в \goto{wiki}[url(https://wiki.contextgarden.net/References)] по этому вопросу.

% Если мы решим написать свои собственные метки, команда, которая может помочь нам избежать дублирования, будет \tex{showreferences}: эта команда покажет список всех установленных меток в документе.

\stopsubsection

\stopsection

\startsection
[
reference=sec:interactivity,
title=Интерактивные электронные документы,
]

Интерактивными могут быть только электронные документы, но не все электронные документы являются интерактивными.  {\em Электронный} документ - это документ, который хранится в компьютерном файле и может быть открыт и прочитан непосредственно на экране. С другой стороны, электронный документ, оснащенный утилитами, которые позволяют пользователю взаимодействовать с ним, является интерактивным; то есть мы можем сделать больше, чем просто прочитать его. Существует интерактивность, например, когда в документе есть кнопки, которые выполняют какое-либо действие, или ссылки, с помощью которых мы можем перейти в другую точку документа или во внешний документ; или когда в документе есть области, где пользователь может писать, или имеются видео или аудиоклипы, которые можно воспроизводить, и т.д.

Все документы, созданные \ConTeXt, являются электронными (поскольку \ConTeXt\ генерирует PDF-файл, который по определению является электронным документом), но они не всегда интерактивны. Чтобы обеспечить им интерактивность, необходимо прямо указать это, как показано в следующем разделе.

Имейте в виду, однако, что, хотя \ConTeXt\ генерирует интерактивный PDF-файл, для того, чтобы оценить эту интерактивность, нам нужна программа чтения PDF, способная на это, поскольку не все программы чтения PDF позволяют нам использовать гиперссылки, кнопки и аналогичные элементы, соответствующие интерактивным документам.

\startsubsection
[title=Включение интерактивности в документах]
\PlaceMacro{setupinteraction}

\ConTeXt\ не использует интерактивные функции по умолчанию, если прямо не указано, что обычно делается в преамбуле документа. Команда, которая включает эту утилиту, является:

\type{\setupinteraction[state=start]}

Обычно эта команда используется только один раз и в преамбуле документа, когда мы хотим создать интерактивный документ. Но на самом деле мы можем использовать его так часто, как захотим, изменяя состояние интерактивности документа. Команда \MyKey{state=start} включает интерактивность, а \MyKey{state=stop} отключает ее, поэтому мы можем отключить интерактивность в некоторых главах или {\em частях} нашего документа, где мы хотим это сделать.

\startSmallPrint

Я не могу придумать ни одной причины, по которой мы хотели бы иметь в документах неинтерактивные части, которые являются интерактивными. Но что важно в философии \ConTeXt, так это то, что если что-то технически возможно, даже если мы вряд ли будем это использовать, то он предлагает процедуру для этого. Именно эта философия дает \ConTeXt\ столько возможностей и не позволяет сделать такое простое введение {\em кратким}.

\stopSmallPrint

Как только взаимодействие будет установлено:

\startitemize

\item Некоторые команды \ConTeXt\ уже будут включать гиперссылки. Таким образом:

\startitemize

\item Команды для создания оглавлений, которые в принципе и если прямо не указано иное, будут интерактивными, т.е. нажатие на запись в оглавлении приведет к переходу на страницу, с которой начинается соответствующий раздел.

\item Команды для внутренних ссылок, которые мы видели в первой части этой главы, где нажатие на них автоматически переходит к цели ссылки.

\item Сноски и конечные примечания, где щелчок по привязке примечания в основной части текста приведет нас на страницу, где написана сама заметка, а щелчок по метке примечания в тексте заметки приведет нас к точке в основном тексте, где был сделан вызов.

\item и т.д.

\stopitemize

\item Включена возможность использования других команд, специально предназначенных для интерактивных документов, таких как презентации. В них используются многочисленные инструменты, связанные с интерактивностью, такие как кнопки, меню, наложения изображений, встроенный звук или видео и т.д. Объяснение всего этого было бы слишком длинным, и, кроме того, презентации - это довольно особый вид документа. Поэтому в следующих строках я опишу одну функцию, связанную с интерактивностью: гиперссылки.

\stopitemize

\stopsubsection

\startsubsection
[title=Базовая конфигурация для интерактивности]

\tex{setupinteraction}, помимо включения или отключения взаимодействия, позволяет нам настраивать некоторые связанные с ним вопросы; в основном, но не только, цвет и стиль ссылок. Это делается с помощью следующих параметров команды:

\startitemize

\item {\tt color}: управляет {\em обычным} цветом ссылок.

\item {\tt contrastcolor}: определяет цвет ссылок, цель которых находится на той же странице, что и исходная. Я рекомендую всегда устанавливать этот параметр на то же содержание, что и предыдущий.

\item {\tt style}: управляет стилем ссылки.

\item {\tt title, subtitle, author, date, keyword}: значения, присвоенные этим параметрам, будут преобразованы в метаданные PDF-файла, созданного
\ConTeXt.

\item {\tt click}: этот параметр определяет, должна ли ссылка выделяться при нажатии.

\stopitemize

\stopsubsection

\stopsection

\startsection
[title=Гиперссылки на внешние документы]

Я буду различать команды, которые не создают ссылку, но помогают набрать URL-адрес ссылки, и команды, которые создают гиперссылку. Давайте посмотрим на них отдельно

\startsubsection
[title={Команды, которые помогают набирать гиперссылки, но не создают их}]

URL-адреса, как правило, очень длинные и включают символы всех типов, даже символы, которые являются зарезервированными символами в \ConTeXt\ и не могут использоваться напрямую. Кроме того, когда URL-адрес должен отображаться в документе, очень сложно набрать абзац, поскольку URL-адрес может превышать длину строки и никогда не включать пробелы, которые можно использовать для вставки разрыва строки. Более того, в URL-адресе нецелесообразно переносить слова для вставки разрывов строк, так как читатель вряд ли может знать, действительно ли расстановка переносов является частью URL-адреса.

Поэтому \ConTeXt\ предоставляет две утилиты для {\em набора} URL-адресов. Первый предназначен в первую очередь для URL-адресов, которые будут использоваться внутри, но фактически не будут отображаться в документе. Второй - для URL-адресов, которые должны быть вписаны в текст документа. Давайте посмотрим на них отдельно:

\startdescription{\tex{useURL}}\PlaceMacro{useURL}

Эта команда позволяет нам записать URL-адрес в преамбуле документа, связав его с именем, так что, когда мы хотим использовать его в нашем документе, мы можем вызывать его по ассоциированному с ним имени. Это особенно полезно с URL-адресами, которые будут использоваться несколько раз в документе.

\page[preference]

Команда допускает два использования:

\startitemize[n, packed]

\item \type{\useURL[Associated name][URL]}
\item \type{\useURL [Associated name] [URL] [] [Link text]}

\stopitemize

\startitemize

\item В первой версии URL просто связан с именем, под которым он будет вызываться в нашем документе. Но затем, чтобы использовать URL-адрес, нам нужно будет каким-то образом указать при его вызове, какой интерактивный текст будет отображаться в документе.

\item Во второй версии последний аргумент включает интерактивный текст. Третий аргумент существует на тот случай, если мы хотим разделить URL-адрес на две части, чтобы первая часть содержала адрес доступа, а вторая часть - имя конкретного документа или страницы, которую мы хотим открыть. Например: адрес документа, объясняющего, что такое \ConTeXt: \\
\color[blue]{\hyphenatedurl{http://www.pragma-ade.com/general/manuals/what-is-context.pdf}}. Этот адрес можно записать полностью во второй аргумент, оставив третий пустой:

\starttyping
\useURL [WhatIsCTX]
  [http://www.pragma-ade.com/general/manuals/what-is-context.pdf]
  []
  [What is \ConTeXt?]
\stoptyping

но мы также можем разделить его на два аргумента:

\starttyping
\useURL [WhatIsCTX]
  [http://www.pragma-ade.com/general/manuals/]
  [what-is-context.pdf]
  [What is \ConTeXt?]
\stoptyping

В обоих случаях мы будем связывать этот адрес со словом \MyKey{WhatIsCTX}, так что для включения ссылки на этот адрес мы используем команду, которую используем для создания ссылки; вместо самого URL-адреса мы можем просто написать \MyKey{WhatIsCTX}.

Если в любом месте текста мы хотим воспроизвести URL-адрес, который мы связали с именем с помощью \tex{useURL}, мы можем использовать \tex{url[Associated name]}, который вставляет URL-адрес, связанный с этим именем, в документ. Но эта команда, хотя и записывает URL-адрес, не создает никаких ссылок.

\startSmallPrint

Формат, в котором отображаются URL-адреса, записанные с использованием \tex{url}, не является общим, установленным с помощью \tex{setupinteraction}, это формат, специально установленный для этой команды с помощью \PlaceMacro{setupurl}\tex{setupurl}, который позволяет нам установить стиль (параметр {\tt style}) и цвет (параметр {\tt цвет}).

\stopSmallPrint

\stopitemize

\stopdescription

\startdescription{\tex{hyphenatedurl}}\PlaceMacro{hyphenatedurl}

Эта команда предназначена для URL-адресов, которые будут записаны в тексте нашего документа, и \ConTeXt\ включает в себя разрывы строк в URL-адресе, если это необходимо, для правильного набора абзаца. Её формат:

\type{\hyphenatedurl{URLaddress}}

Несмотря на название команды \PlaceMacro{hyphenatedurl}\tex{hyphenatedurl}, она не переносит имя URL-адреса. Она учитывает, что определенные символы, часто встречающиеся в URL-адресах, являются хорошим поводом для вставки разрыва строки до или после них. Мы можем добавить нужные символы в список символов, для которых разрешен разрыв строки.


Для этого у нас есть три команды:

\starttyping
\sethyphenatedurlnormal{Characters}
\sethyphenatedurlbefore{Characters}
\sethyphenatedurlafter{Characters}
\stoptyping\PlaceMacro{sethyphenatedurlnormal}\PlaceMacro{sethyphenatedurlbefore}\PlaceMacro{sethyphenatedurlafter}

Эти команды добавляют символы, которые они принимают в качестве аргументов, в список символов, поддерживающих разрывы строк, до и после списка символов, которые поддерживают только разрывы строк, и тех, которые разрешают только обратные разрывы строк, соответственно.

\tex{hyphenatedurl} можно использовать всякий раз, когда необходимо написать URL-адрес, который будет отображаться в окончательном документе как есть. Его даже можно использовать в качестве последнего аргумента для \tex{useURL} в версии этой команды, где последний аргумент выбирает интерактивный текст, который будет отображаться в окончательном документе. Например:

\starttyping
\useURL [WhatIsCTX]
  [http://www.pragma-ade.com/general/manuals/what-is-context.pdf]
  []
  [\hyphenatedurl{http://www.pragma-ade.com/general/manuals/what-is-context.pdf}]
\stoptyping

В аргументе \tex{hyphenatedurl} можно использовать все зарезервированные символы, кроме трех, которые необходимо заменить командами:

\startitemize[packed]

\item \%{} должен быть заменен на
\PlaceMacro{letterpercent}\tex{letterpercent}

\item \#{} должен быть заменен на \PlaceMacro{letterhash}\tex{letterhash}

\item \backslash{} должен быть заменен на
\PlaceMacro{letterescape}\tex{letterescape} or
\PlaceMacro{letterbackslash}\tex{letterbackslash}.

\stopitemize

Каждый раз, когда \tex{hyphenatedurl} вставляет разрыв строки, он выполняет команду \\\PlaceMacro{hyphenatedurlseparator}\tex{hyphenatedurlseparator}, которая по умолчанию ничего не делает. Но если мы его переопределим, репрезентативный символ вставится в URL-адрес аналогично тому, как это происходит с обычными словами, где дефис вставляется, чтобы указать, что слово продолжается на следующей строке. Например:

\type{\def\hyphenatedurlseparator{\curvearrowright}}

\def\hyphenatedurlseparator{\curvearrowright}

таким образом отобразит следующий особенно длинный веб-адрес:

\startnarrower\switchtobodyfont[11pt]

\color[blue]{\hyphenatedurl{https://support.microsoft.com/?scid=http://support.microsoft.com:80/support/kb/articles/Q208/4/27.ASP&NoWebContent=1}.}

\stopnarrower

\stopdescription

\stopsubsection

\startsubsection
[
reference=sec:createlinks,
title={Команды, создающие ссылку},
]

Чтобы установить ссылки на предопределенные URL-адреса с помощью \tex{useURL}, мы можем использовать команду \PlaceMacro{from}\tex{from}, которая ограничивается установкой ссылки, но не записывает какой-либо интерактивный текст. Текст по умолчанию в \tex{useURL} будет использоваться в качестве текста ссылки. Его синтаксис:

\type{\from[Name]}

где {\em Name} -- это имя, ранее связанное с URL-адресом с помощью \tex{useURL}.

Чтобы создавать ссылки и связывать их с интерактивным текстом, который не был ранее определен, у нас есть команда  \PlaceMacro{goto}\tex{goto}, которая используется как для создания внутренних, так и внешних ссылок. Его синтаксис:

\type{\goto{Clickable tex}[Target]}

где {\em Clickable tex} - это текст, который будет отображаться в окончательном документе, и где щелчок мыши вызовет переход, а {\em Target} может быть:

\startitemize

\item Ярлык из нашего документа. В этом случае \tex{goto} сгенерирует переход таким же образом, как, например, уже рассмотренные команды \tex{in} или \tex{at}. Но, в отличие от этих команд, никакая информация, связанная с меткой, не будет получена.

\item Сам URL. В этом случае необходимо прямо указать, что это URL-адрес, написав команду следующим образом:

\type{\goto{Clickable text}[url(URL)]}

где URL, в свою очередь, может быть именем, ранее связанным с URL-адресом с помощью \tex{useURL}, или самим URL-адресом, и в этом случае при написании URL-адреса мы должны убедиться, что зарезервированные символы \ConTeXt\ написаны правильно в \ConTeXt. Запись URL-адреса в соответствии с правилами \ConTeXt\ не повлияет на функциональность ссылки.

\stopitemize

\stopsubsection

\stopsection

\startsection
[title=Создание закладок в окончательном PDF-файле]

Файлы PDF могут иметь внутренний список закладок, который позволяет читателю видеть содержимое документа в специальном окне программы просмотра PDF и перемещаться по нему, просто щелкая каждый из разделов и подразделов.

По умолчанию \ConTeXt\ не добавляет в выходной PDF-файл список закладок, хотя сделать это так же просто, как включить команду \PlaceMacro{placebookmarks}\tex{placebookmarks}, синтаксис которой:

\type{\placebookmarks[List of sections]}

где {\em List of sections} - это разделенный запятыми список уровней разделов, которые должны отображаться в списке содержимого.

Имейте в виду следующие наблюдения относительно этой команды:

\startitemize

\item По моим тестам \tex{placebookmarks} не работают, если это в преамбуле документа. Но в теле документа (между \tex{starttext} и \tex{stoptext}, или между \tex{startproduct} и \tex{stopproduct}) не имеет значения, где вы его разместите: список закладок также будет включать разделы или подразделы, предшествующие команде. Однако я считаю, что наиболее разумным для правильного понимания исходного файла является размещение команды вначале.

\item Типы разделов, определенные пользователем (с помощью \tex{definehead}), не всегда располагаются в нужном месте в списке закладок. Их желательно исключить.

\item Если название раздела в каком-либо разделе содержит концевую сноску или сноску, текст сноски считается частью закладки.

\item В качестве аргумента вместо списка разделов мы можем просто указать символическое слово \MyKey{all}, которое, как указывает его название, будет включать все разделы; однако, согласно моим тестам, это слово, в дополнение к тому, что определенно является разделами, включает тексты, помещенные туда с некоторыми командами без разделения, поэтому результирующий список несколько непредсказуем.

\stopitemize

Не все программы просмотра PDF позволяют нам просматривать закладки; и у многих из них эта функция не активирована по умолчанию. Поэтому, чтобы проверить результат этой функции, мы должны убедиться, что наша программа для чтения PDF-файлов поддерживает эту функцию и активирована ли она. Думаю, я помню, что Acrobat, например, по умолчанию не показывает закладки, хотя на его панели инструментов есть кнопка для их отображения.

\stopsection

\stopchapter

\stopcomponent

%%% Local Variables:
%%% mode: ConTeXt
%%% mode: auto-fill
%%% coding: utf-8-unix
%%% TeX-master: "../introCTX.mkiv"
%%% End:
%%% vim:set filetype=context tw=72 : %%%
