%%% File:         b10_CharText.mkiv
%%% Author:       Joaquín Ataz-López
%%% Begun:        July 2020
%%% concluded:    July 2020
%%% Contents:     It is actually an amalgamation of issues that are
%%% raised in this chapter, and the criterion that
%%% unified them is somewhat forced: Section 1 could be in
%%% the chapter dedicated to the source file (in fact
%%% was in the first version of it);  2 in the
%%% chapter dedicated to fonts: because although they are not
%%% characteristics of the format itself, they are
%%% somewhat similar. 3 is horizontal space; in the
%%% first versions I put it together with  vertical space in
%%% a chapter titled "Blank space". The 4th and 5th
%%% are more difficult to locate. I finally opted for this
%%% chapter that is a "poutpurri".
%%%
%%% Edited by: Emacs + AuTeX - And at times vim + context-plugin
%%%

\environment ../introCTX_env.mkiv

\startcomponent b10_CharText.mkiv

\startchapter
  [title={Символы, слова, текст и горизонтальное пространство}]

\TocChap

Основным основным элементом всех текстовых документов является символ: символы сгруппированы в слова, которые, в свою очередь, образуют строки, составляющие абзацы, составляющие страницы. 

Текущая глава, начинающаяся с «символа» \quotation{{\em character}}, объясняет некоторые утилиты \ConTeXt\, относящиеся к символам, словам и тексту.

\startsection
  [title={Получение символов, которые обычно не доступны с клавиатуры}]

В текстовом файле, закодированном как UTF-8 (см. \in{section}[sec:encoding]), мы можем использовать любой символ или символ, как живых языков, так и многих уже вымерших. Но, поскольку возможности клавиатуры ограничены, большинство символов и символов, разрешенных в UTF-8, обычно не могут быть получены непосредственно с клавиатуры. Это особенно падеж с множеством диакритических знаков, то есть знаки, помещенные над (или под) определенными буквами, придавая им особую ценность; но также и со многими другими символами, такими как математические символы, традиционные лигатуры и т. д. Мы можем получить многие из этих символов с помощью \ConTeXt\ с помощью команд.

\startsubsection
  [title={Диакритические знаки и специальные буквы}]

Почти все западные языки имеют диакритические знаки (за важным исключением английского по большей части), и в целом клавиатура может генерировать диакритические знаки, соответствующие региональным языкам. Таким образом, испанская клавиатура может генерировать все диакритические знаки, необходимые для испанского (в основном акценты и диэрезис), а также некоторые диакритические знаки, используемые в других языках, таких как каталонский (серьезные акценты и cedillas) или французские (cedillas, серьезные и циркумфлексные акценты); но не, например, некоторые, которые используются в португальском языке, такие как тильда на некоторых гласных в таких словах, как \quotation{navegaç\~ao}.

\TEX\ был разработан в Соединенных Штатах, где клавиатуры обычно не позволяют нам вводить диакритические знаки; поэтому Дональд Кнут дал ему набор команд, которые позволяют нам получать почти все известные диакритические знаки (по крайней мере, в языках, использующих латинский алфавит). Если мы используем испанскую клавиатуру, не имеет большого смысла использовать эти команды для получения диакритических знаков, которые можно получить непосредственно с клавиатуры. По-прежнему важно знать, что эти команды существуют, и что они из себя представляют, поскольку испанские (или итальянские, или французские ...) клавиатуры не позволяют нам генерировать все возможные диакритические знаки.

\placetable
  [here]
  [tbl:diacritics]
  {\tfx  Акценты и другие диакритические знаки}
  {
    \starttabulate[|l|l|l|l|]
      \HL
      \NC{\bf Название}\NC{\bf Буква}\NC{\bf Абревиатура}\NC{\bf Команда}\NR
      \HL
      \NC Acute accent\NC\'u\NC{\tt\backslash'u}\NC{\tt\backslash
        uacute}\NR\PlaceMacro{aacute}\PlaceMacro{eacute}\PlaceMacro{iacute}\PlaceMacro{oacute}\PlaceMacro{uacute}
      \NC Grave accent\NC\`u\NC{\tt\backslash`u}\NC{\tt\backslash
        ugrave}\NR\PlaceMacro{agrave}\PlaceMacro{egrave}\PlaceMacro{igrave}\PlaceMacro{ograve}\PlaceMacro{ugrave}
      \NC Circumflex
      accent\NC\^u\NC{\tt\backslash^u}\NC{\tt\backslash
        ucircumflex}\NR\PlaceMacro{acircumflex}\PlaceMacro{ecircumflex}\PlaceMacro{icircumflex}\PlaceMacro{ocircumflex}\PlaceMacro{ucircumflex}
      \NC Dieresis or umlaut
      \NC\"u\NC{\tt\backslash”u}\NC{\tt\backslash udiaeresis,
        \backslash
        uumlaut}\NR\PlaceMacro{adiaeresis}\PlaceMacro{ediaeresis}\PlaceMacro{idiaeresis}\PlaceMacro{odiaeresis}\PlaceMacro{udiaeresis}
      \NC Tilde\NC\~u\NC{\tt\backslash\lettertilde u}\NC{\tt\backslash
        utilde}\NR\PlaceMacro{atilde}\PlaceMacro{etilde}\PlaceMacro{itilde}\PlaceMacro{otilde}\PlaceMacro{utilde}
      \NC Macron\NC\=u\NC{\tt\backslash=u}\NC{\tt\backslash
        umacron}\NR\PlaceMacro{amacron}\PlaceMacro{emacron}\PlaceMacro{imacron}\PlaceMacro{omacron}\PlaceMacro{umacron}
      \NC Breve\NC\u u\NC{\tt\backslash u u}\NC{\tt\backslash
        ubreve}\PlaceMacro{u}\PlaceMacro{abreve}\PlaceMacro{ebreve}\PlaceMacro{obreve}\PlaceMacro{ibreve}\PlaceMacro{ubreve}\NR
      \HL
    \stoptabulate
}
 
В \in{table}[tbl:diacritics] мы находим команды и сокращения, которые позволяют нам получать эти диакритические знаки. Во всех случаях неважно, используем ли мы команду или сокращение. В таблице я использовал букву \quote{u} в качестве примера, но эти команды работают с любой гласной (большинство из них \footnote{Из команд, найденных в \in{table}[tbl:diacritics], тильда не работает с буквой \quote{e}, и я не знаю почему.}), а также с некоторыми согласными и некоторыми полугласными звуками.
 
  \startitemize

  \item Поскольку большинство сокращенных команд представляют собой {\em управляющие символы} (см. \in{section}[sec:commands themselves]), буква, на которой должен стоять диакритический знак, может быть написана сразу после команды или отделена от нее. Так, например: чтобы получить португальский \quote{\~a}, мы можем написать символы \tex{=a} или \cmd{=\textvisiblespace a}. \footnote{Помните, что в этом документе мы представляем пробелы , когда важно, чтобы мы их видели, с помощью \quote{\textvisiblespace}.} Но в случае breve (\tex{u}), когда мы имеем дело с {\em контрольным словом}, пробел является обязательным.

  \item В случае длинной версии команды буква с диакритическим знаком будет первой буквой имени команды. Так, например, \tex{emacron} поместит макрон над строчной буквой  \quote{e} (\emacron), \tex{Emacron} сделает то же самое над прописной буквой \quote{E} (\Emacron), а tex{Amacron} сделает то же самое над прописной буквой  \quote{A} (\Amacron).

   
  \stopitemize

Хотя команды в таблице \in{table}[tbl:diacritics] работают с гласными и некоторыми согласными, существуют и другие команды для создания некоторых диакритических знаков и специальных букв, которые работают только с одной или несколькими буквами. Они представлены в таблице \in{table}[tbl:morediacritics].

{\switchtobodyfont[small]
\placetable
  [here]
  [tbl:morediacritics]
  {\tfx Больше диакритических знаков и специальных букв}
  {
    \starttabulate[|l|l|l|l|]
      \HL
      \NC{\bf Наименование}\NC{\bf Буква}\NC{\bf Абревиатура}\NC{\bf Команда}\NR
      \HL
      \NC Scandinavian O\NC\o, \O\NC{\tt \backslash o, \backslash O}\NC\NR\PlaceMacro{o}
      \NC Scandinavian A\NC\aring, \Aring\NC{\tt \backslash aa, \backslash AA, \{\backslash r a\}, \{\backslash r A\}}\NC{\tt \backslash aring, \backslash Aring}\NR\PlaceMacro{aa}\PlaceMacro{r}\PlaceMacro{aring}
      \NC Polish L\NC\l, \L\NC{\tt \backslash l, \backslash L}\NC\NR\PlaceMacro{l}
      \NC German Eszett\NC\SS\NC{\tt \backslash ss, \backslash SS}\NC\NR\PlaceMacro{ss}
      \NC \quote{i} and \quote{j} wihtout a point\NC\i, \j\NC{\tt \backslash i, \backslash j}\NC\NR\PlaceMacro{i}\PlaceMacro{j}
      \NC Hungarian Umlaut\NC\H u, \H U\NC{\tt\backslash H u}, {\tt\backslash H U}\NC\NR\PlaceMacro{H}
      \NC Cedilla\NC\c c, \c C\NC{\tt \backslash c c, \backslash c C}\NC{\tt \backslash ccedilla, \backslash Ccedilla}\PlaceMacro{c}\PlaceMacro{ccedilla}\PlaceMacro{kcedilla}\PlaceMacro{lcedilla}\PlaceMacro{ncedilla}\PlaceMacro{rcedilla}\PlaceMacro{scedilla}\PlaceMacro{tcedilla}\NR
      \HL
    \stoptabulate
  }
}

Я хотел бы отметить, что некоторые команды в приведенной выше таблице генерируют символы из других символов, в то время как другие команды работают только в том случае, если шрифт, который мы используем, явно предоставлен для рассматриваемого символа. Итак, что касается немецкого Eszett (ß), в таблице показаны две команды, но только один символ, потому что шрифт, который я использую здесь для этого текста, предусматривает только версию немецкого Eszett в верхнем регистре (что-то довольно распространенное).

Вероятно, поэтому я тоже не могу получить скандинавский A в верхнем регистре, хотя \MyKey{\{\backslash r A\}} и \cmd{Aring}  работают правильно.

Венгерский умляут также работает с буквой \quote{o}, а седиль - с буквами letters \quote{k},  \quote{l}, \quote{n}, \quote{r}, \quote{s} and \quote{t}, в нижнем или верхнем регистре соответственно. Используются следующие команды: \cmd{kcedilla}, \cmd{lcedilla}, \cmd{ncedilla} ... соответственно.

\stopsubsection

\startsubsection
  [
    reference=sec:ligatures,
    title={Традиционные лигатуры},
  ]
  %Должен быть еще один раздел только для лигатур, автоматически сгенерированных ConTeXt в качестве функции шрифта. Но в конце главы о шрифтах я не говорил об особенностях различных шрифтов, и не было места, где разместить этот раздел.

Лигатура образована объединением двух или более графем, которые обычно пишутся отдельно. Это «слияние» \quotation{fusion} двух символов часто начиналось как своего рода стенография в рукописных текстах, пока, наконец, они не достигли определенной типографской независимости. Некоторые из них даже были включены в число символов, которые обычно определяются в типографском шрифте, например, амперсанд, \quote{\&}, который начался как сокращение латинской связки (соединения) \quotation{et} или немецкого Eszett (ß). , который, как следует из названия, начинался как комбинация букв\quote{s} и \quote{z}. В дизайне некоторых шрифтов даже сегодня можно проследить происхождение этих двух символов; или, может быть, я вижу их, потому что знаю, что они там. В частности, со шрифтом Pagella для  \quote{\&} и с Bookman для \quote{ß}.

В качестве упражнения я предлагаю (после прочтения \in{Chapter}[sec:fontscol], где объясняется, как это сделать) попробовать представить эти символы с помощью этих шрифтов с достаточно большим размером (например, 30 pt), чтобы можно было проработать их компоненты.

Другие традиционные лигатуры, которые не стали такими популярными, но все еще иногда используются сегодня, - это латинские окончания \quotation{oe} и \quotation{ae}, которые иногда записывались как \quote{\oe} или \quote{ae}, чтобы указать, что они образовали дифтонг на латыни. Эти лигатуры могут быть достигнуты в \ConTeXt\ с помощью команд, приведенных в  \in{table}[tbl:ligatures]



\placetable
  [here]
  [tbl:ligatures]
  {Традиционные лигатуры}
{
  \starttabulate[|l|l|l|]
    \HL
    \NC {\bf Лигатура}\NC {\bf Абревиатура}\NC {\bf Команда}\NR
    \HL
    \NC\ae, \AE\NC{\tt \backslash ae, \backslash AE}\NC{\tt \backslash aeligature, \backslash AEligature}\NR\PlaceMacro{ae}\PlaceMacro{aeligature}
    \NC\oe, \OE\NC{\tt \backslash oe, \backslash OE}\NC{\tt \backslash oeligature, \backslash OEligature}\PlaceMacro{oe}\PlaceMacro{oeligature}\NR
    \HL
  \stoptabulate
}    

Лигатура, которая раньше была традиционной для испанского (кастильского) и которая обычно не встречается в шрифтах сегодня, - это \quote{Đ}: сокращение, включающее \quote{D} и \quote{E}. Насколько мне известно, в \ConTeXt\ нет команды, которая позволяла бы нам использовать это, \footnote{В \LaTeX, напротив, мы можем использовать команду \MyKey{fontenc} package.}, реализованную в пакете fontenc. но мы можем создать ее, как описано в \in{section}[sec:create characters].

Наряду с предыдущими лигатурами, которые я назвал {\em традиционными}, потому что они происходят от рукописного ввода, после изобретения печатного станка были разработаны определенные лигатуры печатного текста, которые я назову «типографскими лигатурами», которые \ConTeXt\ считает утилитами шрифтов и которыми автоматически управляет программа, хотя мы можем влиять на то, как эти утилиты шрифтов обрабатываются (включая лигатуры) с помощью \PlaceMacro{definefontfeature}\tex{definefontfeature} (не объясняется в этом введении).

\stopsubsection

\startsubsection
  [title={Греческие буквы}]

Греческие символы обычно используются в математических и физических формулах. Вот почему \ConTeXt\ включил возможность генерации всего греческого алфавита, в верхнем и нижнем регистре. Здесь команда построена на английском имени рассматриваемой греческой буквы. Если первый символ написан в нижнем регистре, у нас будет строчная греческая буква, а если он написан заглавными буквами, мы получим греческую букву в верхнем регистре. Например, команда \cmd{mu} сгенерирует версию этой буквы в нижнем регистре (\mu), а команда \cmd{Mu} сгенерирует версию в верхнем регистре (Μ). В т \in{table}[tbl:greekletters] мы можем увидеть, какая команда генерирует каждую из букв греческого алфавита, нижний и верхний регистры.

{\smallbodyfont
\placetable
  [here]
  [tbl:greekletters]
  {Греческий алфавит}
{
  \starttabulate[|l|l|l|]
    \HL
    \NC {\bf Английское имя}\NC {\bf Буква (lc/uc)}\NC {\bf Команды (lc/uc)}\NR
    \HL
    \NC Alpha\NC\alpha, \Alpha\NC{\tt \backslash alpha, \backslash Alpha}\NR\PlaceMacro{alpha}
    \NC Beta\NC\beta, \Beta\NC{\tt \backslash beta, \backslash Beta}\NR\PlaceMacro{beta}
    \NC Gamma\NC\gamma, \Gamma\NC{\tt \backslash gamma, \backslash Gamma}\NR\PlaceMacro{gamma}
    \NC Delta\NC\delta, \Delta\NC{\tt \backslash delta, \backslash Delta}\NR\PlaceMacro{delta}
    \NC Epsilon\NC\epsilon, \varepsilon, \Epsilon\NC{\tt \backslash epsilon, \backslash varepsilon, \backslash Epsilon}\NR\PlaceMacro{epsilon}\PlaceMacro{varepsilon}
    \NC Zeta\NC\zeta, \Zeta\NC{\tt \backslash zeta, \backslash Zeta}\NR\PlaceMacro{zeta}
    \NC Eta\NC\eta, \Eta\NC{\tt \backslash eta, \backslash Eta}\NR\PlaceMacro{eta}
    \NC Theta\NC\theta, \vartheta, \Theta\NC{\tt \backslash theta, \backslash vartheta, \backslash Theta}\NR\PlaceMacro{theta}\PlaceMacro{vartheta}
    \NC Iota\NC\iota, \Iota\NC{\tt \backslash iota, \backslash Iota}\NR\PlaceMacro{iota}
    \NC Kappa\NC\kappa, \varkappa, \Kappa\NC{\tt \backslash kappa, \backslash varkappa, \backslash Kappa}\NR\PlaceMacro{kappa}\PlaceMacro{varkappa}
    \NC Lambda\NC\lambda, \Lambda\NC{\tt \backslash lambda, \backslash Lambda}\NR\PlaceMacro{lambda}
    \NC Mu\NC\mu, \Mu\NC{\tt \backslash mu, \backslash Mu}\NR\PlaceMacro{mu}
    \NC Nu\NC\nu, \Nu\NC{\tt \backslash nu, \backslash Nu}\NR\PlaceMacro{nu}
    \NC Xi\NC\xi, \Xi\NC{\tt \backslash xi, \backslash Xi}\NR\PlaceMacro{xi}
    \NC Omicron\NC\omicron, \Omicron\NC{\tt \backslash omicron, \backslash Omicron}\NR\PlaceMacro{omicron}
    \NC Pi\NC\pi, \varpi, \Pi\NC{\tt \backslash pi, \backslash varpi, \backslash Pi}\NR\PlaceMacro{pi}\PlaceMacro{varpi}
    \NC Rho\NC\rho, \varrho, \Rho\NC{\tt \backslash rho, \backslash varrho, \backslash Rho}\NR\PlaceMacro{rho}\PlaceMacro{varrho}
    \NC Sigma\NC\sigma, \varsigma, \Sigma\NC{\tt \backslash sigma, \backslash varsigma, \backslash Sigma}\NR\PlaceMacro{sigma}\PlaceMacro{varsigma}
    \NC Tau\NC\tau, \Tau\NC{\tt \backslash tau, \backslash Tau}\NR\PlaceMacro{tau}
    \NC Ypsilon\NC\upsilon, \Upsilon\NC{\tt \backslash upsilon, \backslash Upsilon}\NR\PlaceMacro{upsilon}
    \NC Phi\NC\phi, \varphi, \Phi\NC{\tt \backslash phi, \backslash varphi, \backslash Phi}\NR\PlaceMacro{phi}\PlaceMacro{varphi}
    \NC Chi\NC\chi, \Chi\NC{\tt \backslash chi, \backslash Chi}\NR\PlaceMacro{chi}
    \NC Psi\NC\psi, \Psi\NC{\tt \backslash psi, \backslash Psi}\NR\PlaceMacro{psi}
    \NC Omega\NC\omega, \Omega\NC{\tt \backslash omega, \backslash Omega}\PlaceMacro{omega}\NR
    \HL
    
  \stoptabulate
}}

Обратите внимание, что для строчных версий некоторых символов (epsilon, kappa, theta, pi, rho, sigma and phi) есть два возможных варианта.

\stopsubsection

\startsubsection
  [title={Различные символы}]

Вместе с символами, которые мы только что видели, \TEX\ (а следовательно, и \ConTeXt\) предлагает команды для генерации любого количества символов. Таких команд много. Я представил расширенный, хотя и неполный список в \in{Appendix}[app:symbols].

\stopsubsection

\startsubsection
  [
    reference=sec:create characters,
    title={Определение символов}
  ]
  \PlaceMacro{definecharacter}

Если нам нужно использовать какие-либо символы, недоступные с нашей клавиатуры, мы всегда можем найти веб-страницу с этими символами и скопировать их в наш исходный файл. Если мы используем кодировку UTF-8 (как рекомендуется), это почти всегда будет работать. Но также в вики \ConTeXt\ есть страница с кучей символов, которые можно просто скопировать и вставить в наш документ. Чтобы получить их, перейдите по этой ссылке \goto{on this link}[url(wikisymbols)].

Однако, если нам нужно использовать один из рассматриваемых символов более одного раза, тогда этот символ будет связан с командой, которая будет генерировать его каждый раз. Для этого мы используем \cmd{definecharacter}, синтаксис которого:

{\tt \backslash definecharacter {\em Name} {\em Character}}

где

\startitemize

\item {\bf Name} -- это имя, связанное с новым символом. Это не должно быть имя существующей команды, так как это приведет к перезаписи этой команды.

\item {\bf Character}  -- это символ, который создается каждый раз, когда мы запускаем \cmd{{\em Name}}. Мы можем указать этот символ тремя способами:

  \startitemize

  \item Просто записав его или вставив в наш исходный файл (если мы скопировали его из другого электронного документа или веб-страницы).

\item Указав номер, связанный с этим символом, в шрифте, который мы используем в настоящее время.  Чтобы увидеть символы, включенные в шрифт, связанные с ними числа, мы можем использовать команду \cmd{showfont[{\em Font name}]}.

  \item Создание нового символа с помощью одной из команд создания составного символа, которую мы увидим сразу после.

 \stopitemize
  
\stopitemize

В качестве примера первого использования давайте вернемся к разделам, посвященным лигатурам (\in{}[sec:ligatures]). Там я рассказал о традиционной испанской лигатуре, которую сегодня обычно не встретишь в шрифтах:  \quote{Đ}. Мы могли бы связать этот символ, например, с командой \cmd{decontract}, чтобы символ был сгенерирован всякий раз, когда мы пишем  \cmd{decontract}. Мы делаем это с помощью:

\type{\definecharacter decontract Đ}

\startSmallPrint

Чтобы создать новый символ, которого нет в нашем шрифте и который не может быть получен с клавиатуры, как в случае с примером, который я только что привел, сначала мы должны найти текст, в котором находится этот символ, скопировать его и иметь возможность вставить это в наше определение. В фактическом примере, который я только что привел, я изначально скопировал \quote{Đ} из Википедии.

\stopSmallPrint

\ConTeXt\ также включает некоторые команды, которые позволяют нам создавать составные символы и которые можно использовать в сочетании с\cmd{definecharacter}. Под составными символами я подразумеваю символы с диакритическими знаками. Команды следующие:

\PlaceMacro{buildmathaccent}\PlaceMacro{buildtextaccent}\PlaceMacro{buildtextbootomcomma}\PlaceMacro{buildtextbottomdot}\PlaceMacro{buildtextcedilla}\PlaceMacro{buildtextgrave}\PlaceMacro{buildtextmacron}\PlaceMacro{buildtexttognek}
\starttyping
  \buildmathaccent Accent Character
  \buildtextaccent Accent Character
  \buildtextbottomcomma Character
  \buildtextbottomdot Character
  \buildtextcedilla Character
  \buildtextgrave Character
  \buildtextmacron Character
  \buildtextognek Character
\stoptyping

Например: как мы уже знаем, по умолчанию в \ConTeXt\ есть только команды для написания определенных букв с седилем (c, k, l, n, r, s y t), которые обычно включаются в шрифты. Если бы мы хотели использовать \quote{b}, мы могли бы использовать команду \cmd{buildtextcedilla} следующим образом:

\type{\definecharacter bcedilla {\buildtextcedilla b}}

\definecharacter bcedilla {\buildtextcedilla b}

Эта команда создаст новую команду \cmd{bcedilla}, которая сгенерирует \quote{b} с седилем: \quote{\bcedilla}. Эти команды буквально «создают» новый символ, который будет сгенерирован, даже если в нашем шрифте его нет. Эти команды накладывают один символ на другой, а затем дают имя этому наложению.

\startSmallPrint

В моих тестах мне не удалось заставить работать  \cmd{buildmathaccent} и \cmd{buildtextognek} . Так что я больше не буду их упоминать.

\stopSmallPrint

{\tt \backslash buildtextaccent} принимает два символа в качестве аргументов и накладывает один на другой, слегка увеличивая один из них. Хотя это называется \quotation{buildtextaccent}, не обязательно, чтобы какой-либо из символов, взятых в качестве аргументов, был акцентом; но перекрытие даст лучшие результаты, если это так, потому что в этом случае, накладывая акцент на символ, акцент с меньшей вероятностью перезапишет символ. С другой стороны, перекрытие двух символов, которые имеют одинаковую базовую линию в нормальных условиях, зависит от того факта, что команда слегка приподнимает один из символов над другим. Вот почему мы не можем использовать эту команду, например, для получения упомянутого выше сокращения \quote{Đ} , потому что если мы напишем

\type{\definecharacter decontract {\buildtextaccent D E}}
\definecharacter decontract {\buildtextaccent D E}

в нашем исходном файле небольшое возвышение над базовой линией  \quote{D}, которое вызывает эта команда (\quotation{\decontract}), не очень хорошо. Но если высота символов позволяет, мы могли бы создать комбинацию.. Например,

\type{\definecharacter unusual {\buildtextaccent \_ "}}
\definecharacter unusual {\buildtextaccent \_ "}

будет определять \quote{\unusual} символ, который будет связан с \cmd{unusual} необычной командой.

Остальные команды сборки принимают единственный аргумент - символ, к которому будет добавлен диакритический знак, сгенерированный каждой командой. Ниже я покажу пример каждого из них, построенный на букве \quote{z}:

\definecharacter zcomma {\buildtextbottomcomma z}
\definecharacter zdot {\buildtextbottomdot z}
\definecharacter zcedilla {\buildtextcedilla z}
\definecharacter zgrave {\buildtextgrave z}
\definecharacter zmacron {\buildtextmacron z}

\startitemize

\item {\tt \backslash buildtextbottomcomma} добавляет запятую под символом, который он принимает в качестве аргумента (\quote{\zcomma}).
\item {\tt \backslash buildtextbottomdot} добавляет точку под символом, который он принимает в качестве аргумента (\quote{\zdot}).
\item {\tt \backslash buildtextcedilla} добавляет седиль под символом, который принимает в качестве аргумента (\quote{\zcedilla}).
\item {\tt \backslash buildtextgrave} добавляет серьезный акцент над символом, который он принимает в качестве аргумента (\quote{\zgrave}).
\item {\tt \backslash buildtextmacron} добавляет небольшую полосу под символом, который он принимает в качестве аргумента (\quote{\zmacron}).
  
\stopitemize

На первый взгляд, {\tt \backslash buildtextgrave} кажется излишним, учитывая, что у нас есть {\tt \backslash buildtextaccent}; Однако, если вы проверите серьезный акцент, созданный с помощью первой из этих двух команд, он выглядит немного лучше. В следующем примере показан результат обеих команд с достаточным размером шрифта, чтобы оценить разницу:

\definecharacter zgraveb {\buildtextaccent ` z}

{\switchtobodyfont[30pt]
\midaligned{\framed{\zgrave\ -- \zgraveb}}
}

\stopsubsection

\startsubsection
  [title={Использование предопределенных наборов символов}]

\suite- включает, наряду с самим \ConTeXt\, ряд предопределенных наборов символов, которые мы можем использовать в наших документах. Эти наборы называются \MyKey{cc}, \MyKey{cow}, \MyKey{fontawesome}, \MyKey{on}, \MyKey{move} и \MyKey{nav}. Каждый из этих наборов также включает несколько подмножеств:

\startitemize[packed]

\item {\tt\bf cc} включает \quotation{cc}.

\item {\tt\bf cow} включает \quotation{cownormal} and \quotation{cowcontour}.

\item {\tt\bf fontawesome} включает \quotation{fontawesome}.

\item {\tt\bf jmn} включает \quotation{navigation~1}, \quotation{navigation~2},  \quotation{navigation~3} and \quotation{navigation~4}.

\item {\tt\bf mvs} включает \quotation{astronomic}, \quotation{zodiac}, \quotation{europe}, \quotation{martinvogel~1}, \quotation{martinvogel~2} and \quotation{martinvogel~3}.

\item {\tt\bf nav} включает \quotation{navigation~1}, \quotation{navigation~2} and \quotation{navigation~3}.
  
\stopitemize

\startSmallPrint

В вики также упоминается набор под названием {\tt\bf was}, который включает в себя \quotation{wasy general}, \quotation{wasy music}, \quotation{wasy astronomy}, \quotation{wasy  astrology}, \quotation{wasy geometry}, \quotation{wasy physics} и \quotation{wasy apl}. Но я не смог найти их в своем дистрибутиве, и мои попытки получить их не увенчались успехом.

\stopSmallPrint

Чтобы увидеть конкретные символы, содержащиеся в каждом из этих наборов, используется следующий синтаксис:

\PlaceMacro{usesymbols}\PlaceMacro{showsymbolset}
\starttyping
  \usesymbols[Set]
  \showsymbolset[Subset]
\stoptyping

Например: если мы хотим видеть символы, включенные в \quotation{mvs/zodiac}, то в исходном файле нам нужно написать:

\starttyping
  \usesymbols[mvs]
  \showsymbolset[zodiac]
\stoptyping

и мы получим следующий результат:

\usesymbols[mvs]
%\startcolumns[n=2]

  \showsymbolset[zodiac]

%\stopcolumns

Обратите внимание, что имя каждого символа указывается вместе с символом. Команда \PlaceMacro{symbol}\tex{symbol} позволяет использовать любой из символов. Его синтаксис:

{\tt \backslash symbol[Subset][SymbolName]}

где subset - это одно из подмножеств, связанных с любым из наборов, которые мы ранее загрузили с помощью \cmd{usesymbols}. Например, если бы мы хотели использовать астрологический символ, связанный с Водолеем (найденный в mvs / zodiac), нам нужно было бы написать

\starttyping
  \usesymbols[mvs]
  \symbol[zodiac][Aquarius]
\stoptyping
\usesymbols[mvs]

который даст нам  \quotation{\symbol[zodiac][Aquarius]}, и это, для всех намерений и целей, будет рассматриваться как \quotation{character} и, следовательно, зависит от размера шрифта, который активен при печати. Мы также можем использовать  \cmd{definecharacter}, чтобы связать рассматриваемый символ с командой. Например

\type{\definecharacter Aries {\symbol[zodiac][Aries]}}
\definecharacter Aries {\symbol[zodiac][Aries]}

создаст новую команду с именем \cmd{Aries}, которая сгенерирует символ \quotation{\Aries}.

Мы могли бы также использовать эти символы, например, в окружении элементов. Например:

\starttyping
\usesymbols[mvs]
\definesymbol[1][{\symbol[martinvogel 2][PointingHand]}]
\definesymbol[2][{\symbol[martinvogel 2][CheckedBox]}]
\startitemize[packed]
\item item \item item
 \startitemize[packed]
 \item item \item item
 \stopitemize
\item item
\stopitemize
\stoptyping

даст

{
\usesymbols[mvs]
\definesymbol[1][{\symbol[martinvogel 2][PointingHand]}]
\definesymbol[2][{\symbol[martinvogel 2][CheckedBox]}]
\startitemize[packed]
\item item \item item
 \startitemize[packed]
 \item item \item item
 \stopitemize
\item item
\stopitemize
}

\stopsubsection

\stopsection

\startsection
  [title={Форматы специальных символов}]

Строго говоря, именно команды {\em форматирования} влияют на используемый шрифт, его размер, стиль или вариант. Эти команды объясняются в \in{Chapter}[sec:fontscol]. Однако, если смотреть в более {\em широком} смысле, мы также можем рассматривать команды, которые каким-то образом изменяют символы, которые они принимают в качестве аргумента (таким образом изменяя их внешний вид), как команды форматирования. В этом разделе мы рассмотрим некоторые из этих команд. Другие, такие как подчеркнутый или линейный текст со строками над или под текстом (например, там, где мы хотим предоставить место для ответа на вопрос), будут рассмотрены в  \in{section}[sec:FramesLines].


\startsubsection
  [
    reference=sec:Upper-Lower-Fake,
    title={Верхний регистр, нижний регистр и псевдо маленькие заглавные буквы},
  ]

Сами буквы могут быть в верхнем или нижнем регистре. Для \ConTeXt\ прописные и строчные буквы - это разные символы, поэтому в принципе он будет набирать буквы так же, как находит их написанными. Однако есть группа команд, которые позволяют нам гарантировать, что текст, который они принимают в качестве аргумента, всегда записывается в верхнем или нижнем регистре:

\startitemize[packed]

\item \PlaceMacro{word}\cmd{word\{text\}}: преобразует текст, взятый в качестве аргумента, в нижний регистр.
  
\item \PlaceMacro{Word}\cmd{Word\{text\}}: преобразует первую букву текста, взятого в качестве аргумента, в верхний регистр.
  
\item \PlaceMacro{Words}\cmd{Words\{text\}}: преобразует первую букву каждого слова, взятого в качестве аргумента, в верхний регистр; остальные в нижнем регистре.
  
\item \PlaceMacro{WORD}\cmd{WORD\{text\}} или \PlaceMacro{WORDS}\cmd{WORDS\{text\}}: записывает текст, взятый в качестве аргумента, в верхнем регистре.
  
\stopitemize

Очень похожи на эти команды \PlaceMacro{cap}\cmd{cap} и \PlaceMacro{Cap}\cmd{Cap}: они также используют заглавные буквы в тексте, который они принимают в качестве аргумента, но затем применяют к нему коэффициент масштабирования, равный тому, который применяется суффиксом \quote{x} в командах изменения шрифта (см. 2), так что в большинстве шрифтов заглавные буквы будут той же высоты, что и строчные буквы, что дает нам эффект {\em псевдо} маленьких заглавных букв. По сравнению с настоящими маленькими крышками (см. \in{section}[sec:smallcaps]) они имеют следующие преимущества:

\startitemize[n]

\item \cmd{cap} and \cmd{Cap} будут работать с любым шрифтом, в отличие от настоящих маленьких заглавных букв, которые работают только со шрифтами и стилями, которые явно включают их.

\item С другой стороны, настоящие маленькие заглавные буквы - это вариант шрифта, который как таковой несовместим с любым другим вариантом, таким как полужирный, курсив или наклонный. Тем не мение, \cmd{cap} и \cmd{Cap} полностью совместимы с любым вариантом шрифта.

\stopitemize

Разница между \cmd{cap} и \cmd{Cap}  заключается в том, что в то время как первый применяет коэффициент масштабирования ко всем буквам слов, составляющих его аргумент, \cmd{Cap} не применяет масштабирование к первой букве каждого слова, таким образом достигая эффекта, аналогичного к тому, что мы получим, если использовать в тексте настоящие заглавные буквы. Если текст, взятый в качестве аргумента в \quote{caps}, состоит из нескольких слов, размер заглавной буквы в первой букве каждого слова будет сохранен.

\page[bigpreference]

Таким образом, в следующем примере

\startDoubleExample

\starttyping
The UN, whose \Cap{president} has his 
office at \cap{uN} headquarters...
\stoptyping
  
The UN, whose \Cap{president} has his 
office at \cap{uN} headquarters...

\stopDoubleExample

Прежде всего, мы должны отметить разницу в размере между первым разом, когда мы пишем \quotation{UN} (заглавными буквами), и вторым разом (маленькими заглавными буквами quotation{\cap{UN}}). В этом примере я написал \cmd{cap\{uN\}} второй раз, чтобы мы могли видеть, что не имеет значения, пишем ли мы аргумент, который  \cmd{cap} принимает в верхнем или нижнем регистре: команда преобразует все буквы в верхний регистр, а затем применяет коэффициент масштабирования; в отличие от\cmd{Cap}, который не масштабирует первую букву.

Эти команды также могут быть {\em вложенными}, и в этом случае коэффициент масштабирования будет применен еще раз, что приведет к дальнейшему уменьшению, как в следующем примере, где слово \quotation{capital} в первой строке снова масштабируется:

\startDoubleExample

\starttyping
\cap{People who have amassed their
\cap{capital} at the expense of others 
are more often than not
{\bf decapitated} in revolutionary 
times}.
\stoptyping

\cap{People who have amassed their \cap{capital} 
at the expense of others are
more often than not {\bf decapitated} in revolutionary 
times}.

\stopDoubleExample

Команда \cmd{nocap}, примененная к тексту, к которому применяется \cmd{cap}, отменяет эффект \cmd{cap} в тексте, который является его аргументом. Например:

\startDoubleExample

\starttyping
\cap{When I was One I had just begun,
when I was Two I was \nocap{nearly} 
new (A.A. Milne)}.
\stoptyping

\cap{When I was one I had just begun,
when I was two I was \nocap{nearly} 
new (A.A. Milne)}.

\stopDoubleExample

Мы можем настроить, как \cmd{cap} работает с  \PlaceMacro{setupcapitals}\cmd{setupcapitals}, а также можем определить разные версии команды, каждая со своим именем и определенной конфигурацией. Это можно сделать с помощью \PlaceMacro{definecapitals}\cmd{definecapitals}.

Обе команды работают одинаково:

\starttyping
\definecapitals[Name][Configuration]
\setupcapitals[Name][Configuration]
\stoptyping

Параметр \quotation{Name} в \cmd{setupcapitals} не является обязательным. Если он не используется, конфигурация повлияет на саму команду \cmd{cap}. Если он используется, нам нужно дать имя, которое мы ранее присвоили в \cmd{definecapitals}, какой-то реальной конфигурации.

В любой из двух команд конфигурация допускает три параметра: \quotation{{\tt title}}, \quotation{{\tt sc}} and \quotation{{\tt style}}, первая и вторая, позволяющие использовать \quotation{yes} и \quotation{no} в качестве значений. С помощью \quotation{{\tt title}} мы указываем, будет ли использование заглавных букв также влиять на заголовки (что и происходит по умолчанию), а с  \quotation{{\tt sc}}  мы указываем, должна ли команда быть настоящей маленькой заглавной (\quotation{yes}) или фальшивой заглавной (\quotation{no}). По умолчанию он использует фальшивые маленькие заглавные буквы, что дает то преимущество, что команда работает, даже если вы используете шрифт, в котором не реализованы маленькие заглавные буквы. Третье значение \quotation{{\tt style}} позволяет нам указать команду стиля, которая будет применяться к тексту, на который воздействует команда \cmd{cap}.

\stopsubsection

\startsubsection
  [title={Надстрочный или подстрочный текст}]

Мы уже знаем (см. \in{section}[sec:reserved characters]), что в математическом режиме зарезервированные символы \MyKey{_} and \MyKey{^} преобразуют следующий за ним символ или группу в верхний или нижний индекс. Для достижения этого эффекта вне математического режима \ConTeXt\ включает следующие команды:

\startitemize

\item \PlaceMacro{high}\cmd{high\{Text\}}:записывает текст, который принимает в качестве аргумента, в виде надстрочного индекса.

\item \PlaceMacro{low}\cmd{low\{Text\}}:  записывает текст, который принимает в качестве аргумента, в виде подстрочного индекса.

\item \PlaceMacro{lohi}\cmd{lohi\{Subscript\}\{Superscript\}}: записывает оба аргумента, один над другим: внизу первый аргумент, а сверху второй, что вызывает любопытный эффект:

  \startDoubleExample

    \starttyping
      \lohi{below}{above}
    \stoptyping

    \lohi{below}{above}

\stopDoubleExample

\stopitemize

\stopsubsection

\startsubsection
  [
    reference=sec:verbatim,
    title={Verbatim текст},
  ]
  \PlaceMacro{type}\PlaceMacro{starttyping}

Латинское выражение {\em verbatim} (от {\em verbum} $=$ {\em word} + суффикс {\em atim}), которое можно перевести как \quotation{буквально} или \quotation{дословно}, используется в программах обработки текста, таких как \ConTeXt\, для обозначения фрагментов текста, которые не должны обрабатываться вообще, а должны быть выгружены в том виде, в котором они были записаны, в окончательный файл. \ConTeXt\ использует для этого команду \tex{type}, предназначенную для коротких текстов, которые не занимают более одной строки, и среду {\tt typing}, предназначенную для текстов более чем одной строки. Эти команды широко используются в компьютерных книгах для отображения фрагментов кода, и \ConTeXt\ форматирует эти тексты моноширинными буквами, как пишущая машинка или компьютерный терминал. В обоих случаях текст отправляется в окончательный документ без {\em обработки}, что означает, что они могут использовать зарезервированные символы или специальные символы, которые будут преобразованы {\em как есть} в окончательный файл. Аналогично, если аргумент \tex{type} или содержимое \tex{starttyping} включает команду, она будет {\em написана} в окончательном документе, но не будет выполнена.

Кроме того, команда \tex{type} имеет следующую особенность: её аргумент {\em может} заключаться в фигурные скобки (как обычно в \ConTeXt), но любой другой символ может использоваться для ограничения (окружения) аргумента.

\startSmallPrint

Когда \ConTeXt\ читает команду \tex{type}, он предполагает, что символ, который не является пробелом сразу после имени команды, будет действовать как разделитель ее аргумента; поэтому он считает, что содержимое аргумента начинается со следующего символа и заканчивается символом до следующего появления {\em разделителя}.

Несколько примеров помогут нам лучше понять это:

  \starttyping
    \type 1Tweedledum and Tweedledee1
    \type |Tweedledum and Tweedledee|
    \type zTweedledum and Tweedledeez
    \type (Tweedledum and Tweedledee(
  \stoptyping

Обратите внимание, что в первом примере первым символом после имени команды является \quote{1}, во втором - \quote{\|}, а в третьем - \quote{z}; Итак: в каждом из этих случаев \ConTeXt\ будет считать, что аргумент \tex{type} -- это все, что находится между этим символом и следующим появлением того же символа. То же самое верно и для последнего примера, который также очень поучителен, потому что в принципе мы могли бы предположить, что если открывающий разделитель аргумента - это '(', то закрывающий должен быть \quote{)}, но это не так, потому что\quote{(} и \quote{)} - это разные символы, а \tex{type}, как я уже сказал, ищет закрывающий символ-разделитель, который совпадает с символом, используемым в начале аргумента.

Есть только два случая, когда \tex{type} позволяет использовать открывающий и закрывающий разделители разными символами:

  \startitemize

  \item Если открывающим разделителем является символ \quote{\{}, предполагается, что закрывающим разделителем будет \quote{\}}.


  \item Если открывающий разделитель - \quote{<<}, считается, что закрывающий разделитель будет \quote{>>}. Этот случай также уникален тем, что в качестве разделителей используются два последовательных символа.

  \stopitemize

Однако тот факт, что \tex{type} допускает любые разделители, не означает, что мы должны использовать \quotation{weird (странные)} разделители. С точки зрения читабельности и понятности источника файла, лучше всего ограничивать аргумент \tex{type} по возможности фигурными скобками, как это обычно бывает с \ConTeXt; а когда это невозможно из-за фигурных скобок в аргументе \tex{type}, используйте символ: предпочтительно тот, который не является зарезервированным символом \ConTeXt. Например:

 \cmd{type *This is a closing curly bracket: \quote{\}}*}.

\stopSmallPrint

И \tex{type}, и \tex{starttyping} можно настроить с помощью \PlaceMacro{setuptype}\tex{setuptype} и \PlaceMacro{setuptyping}\tex{setuptyping}. Мы также можем создать их индивидуальную версию с помощью \PlaceMacro{Definetype}\tex{Definetype} и \PlaceMacro{Definetyping} \tex{Definetyping}. Что касается фактических параметров конфигурации для этих команд, я обращаюсь к \MyKey{setup-en.pdf} (в каталоге {\tt tex/texmf-context/doc/context/documents/general/qrcs}.

Две очень похожие на \tex{type} команды:

\startitemize

\item \PlaceMacro{typ}\tex{typ}: работает аналогично \tex{type}, but не отключает расстановку переносов.

\item \PlaceMacro{tex}\tex{tex}: команда, предназначенная для написания текстов о \TEX\ или \ConTeXt: она добавляет пробел перед текстом, который принимает в качестве аргумента. В противном случае эта команда отличается от \tex{type} тем, что обрабатывает некоторые из зарезервированных символов, которые она находит в тексте, который принимает в качестве аргумента. В частности, фигурные скобки внутри \tex{tex} будут обрабатываться так же, как они обычно обрабатываются в \ConTeXt.

\stopitemize

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:horizontal space1,
    title={Межсимвольные и межсловные интервалы},
  ]

\startsubsection
  [title=Автоматическая установка горизонтального пространства]

Пространство между разными символами и словами (называемое {\em горизонтальным пространством} в \TEX) обычно автоматически устанавливается \ConTeXt:

\startitemize

\item  Пространство между символами, составляющими слово, определяется самим шрифтом, который, за исключением шрифтов с фиксированной шириной, обычно использует большее или меньшее количество пробелов в зависимости от разделяемых символов, и поэтому, например, расстояние между буквами «A» и «V» («AV») обычно меньше, чем пространство между \quote{A} и \quote{V} (\quote{AV}). Однако, помимо этих возможных вариантов, которые зависят от комбинации рассматриваемых букв и предопределены шрифтом, расстояние между символами, составляющими слово, в целом является фиксированной и неизменной мерой.

\item Напротив, интервал между словами в одной строке может быть более эластичным.

  \startitemize

  \item В случае слов в строке, ширина которой должна быть такой же, как у остальных строк в абзаце, изменение интервала между словами является одним из механизмов, которые \ConTeXt\ использует для получения строк одинаковой ширины, так как более подробно объяснено в разделе 11.3. В этих случаях \ConTeXt\ установит точно такое же горизонтальное расстояние между всеми словами в строке (за исключением правил, приведенных ниже), при этом гарантируя, что расстояние между словами в разных строках абзаца будет как можно более похожим.

  \item Однако, в дополнение к необходимости растягивать или сокращать интервалы между словами для выравнивания строк, в зависимости от активного языка, \ConTeXt\ принимает во внимание определенные типографские правила, посредством которых в определенных местах типографская традиция, связанная с этим языком, добавляет некоторые дополнительные пустое пространство, как, например, в некоторых частях английской типографской традиции, при котором после точки добавляются дополнительные пробелы.

    \startSmallPrint

Эти дополнительные пробелы работают для английского языка и, возможно, для некоторых других языков (хотя верно и то, что во многих случаях издатели на английском языке в настоящее время предпочитают не оставлять дополнительное пространство после точки), но не для испанского, где типографская традиция отличается. Таким образом, мы можем временно включить эту функцию с помощью \PlaceMacro{setupspacing}\cmd{setupspacing[wide]} и отключить её с помощью \cmd{setupspacing[pack]}. Мы также можем изменить конфигурацию по умолчанию для испанского (и в этом отношении для любого другого языка, включая английский), как описано в \in{section}[sec:langconfig].

    \stopSmallPrint

  \stopitemize

\stopitemize

\stopsubsection

\startsubsection
  [title=Изменение расстояния между символами в слове]

Изменение пространства по умолчанию для символов, составляющих слово, считается очень плохой практикой с типографской точки зрения, за исключением заголовков и заголовков. Однако \ConTeXt\ предоставляет команду для изменения этого промежутка между символами в слове: \footnote{Очень типично для философии \ConTeXt\ включать команду для выполнения чего-то, что сама документация \ConTeXt\ не рекомендует делать.  Несмотря на то, что типографское совершенство требуется, цель также состоит в том, чтобы дать автору полный контроль над внешним видом своего документа: короче говоря, лучше или хуже - это его или её ответственность.} \PlaceMacro{stretch}\cmd{растянутый}, синтаксис которого следующий:

\type{\stretched[Configuration]{Text}}

где {\em Configuration} допускает любой из следующих параметров:

\startitemize

\item {\tt factor}: целое или десятичное число, представляющее получаемый интервал. Это число не должно быть слишком большим. Коэффициент 0,05 виден уже невооруженным глазом.

\item {\tt width}: указывает общую ширину, которую должен иметь текст, передаваемый команде, таким образом, чтобы команда сама вычисляла необходимый интервал для распределения символов в этом пространстве.

  \startSmallPrint

Согласно моим тестам, когда ширина, установленная с помощью параметра {\tt width}, меньше ширины, необходимой для представления текста с  {\em factor}, равным 0,25, параметр {\em width} и этот factor игнорируются. Я предполагаю, что это потому, что \cmd{stretch} позволяет нам только {\em увеличивать} расстояние между символами в слове, но не уменьшать его. Но я не понимаю, почему ширина, необходимая для представления текста с коэффициентом 0,25, используется в качестве минимальной меры для параметра {\tt width}, а не {\em natural width} текста (с factor от 0).

    According to my tests, when the width established with the {\tt width} option is less than that required to represent the text with a {\em factor} equal to 0.25, the {\em width} option and this factor are ignored. I guess that's because \cmd{stretched} allows us only {\em to increase} the space between the characters in a word, not reduce it. But I don't understand why the width required to represent the text with a factor of 0.25 is used as a minimum measure for the {\tt width} option, and not the {\em natural width} of the text (with a factor of 0).
    
  \stopSmallPrint


\item {\tt\bf style}: команда стиля или команды, применяемые к тексту, взятому в качестве аргумента.

\item {\tt\bf color}: цвет, которым будет написан текст, взятый в качестве аргумента.

\stopitemize

Итак, в следующем примере мы можем графически увидеть, как команда будет работать при применении к одному и тому же предложению, но с разной шириной:

\startDoubleExample\smallbodyfont

\starttyping
\stretched[width=4cm]{\bf test text}
\stretched[width=6cm]{\bf test text}
\stretched[width=8cm]{\bf test text}
\stretched[width=9cm]{\bf test text}
\stoptyping

\stretched[width=4cm]{\bf test text}
\stretched[width=6cm]{\bf test text}
\stretched[width=8cm]{\bf test text}
\stretched[width=9cm]{\bf test text}

\stopDoubleExample

\startSmallPrint

В этом примере можно увидеть, что распределение горизонтального пространства между разными символами неоднородно. \quote{x} и \quote{t} в \quotation{text} и \quote{e} и \quote{b} в \quotation{test} всегда располагаются гораздо ближе друг к другу, чем другие символы. Мне не удалось выяснить, почему это происходит.
  
\stopSmallPrint

При использовании без аргументов команда будет использовать всю ширину линии. С другой стороны, в тексте, который является аргументом этой команды, команда \\ переопределяется и вместо разрыва строки вставляется горизонтальный пробел. Например:


Команда без аргументов  будет использовать всю ширину линии. С другой стороны, в тексте, который является аргументом этой команды, команда \cmd{\backslash} переопределяется и вместо разрыва строки вставляется горизонтальный пробел. Например:

\startcolumns[n=2]

\starttyping
\stretched{test\\text}    
\stoptyping

\stretched{test\\text}  

\stopcolumns

Мы можем настроить конфигурацию команды по умолчанию с помощью\PlaceMacro{setupstretched}\cmd{setupstretched}.

\startSmallPrint

Однако нет команды  \PlaceMacro{definestretched}\cmd{definestretched}, которая позволила бы нам устанавливать индивидуальные конфигурации, связанные с именем команды \Doubt, в официальном списке команд (см. \in{section}[sec:qrc- setup-en]) там сказано, что \cmd{setupstretched} происходит из \PlaceMacro {setupcharacterkerning}\cmd{setupcharacterkerning}, а есть \PlaceMacro{definecharacterkerning}\cmd{de\-fi\-ne\-cha\-rac\-ter\-ker\-ning} команда. Однако в моих тестах мне не удалось установить какую-либо индивидуальную конфигурацию для \cmd{stretch} с помощью последней, хотя я должен признать, что я тоже не тратил много времени на попытки сделать это.

\stopSmallPrint

\stopsubsection

\startsubsection
  [
    reference=sec:horizontal space2,
    title={Команды для добавления горизонтального пробела между словами},
  ]

Мы уже знаем, что для увеличения промежутка между словами бесполезно добавлять два или более последовательных пробелов, поскольку \ConTeXt\ поглощает все последовательные пробелы, как объяснено в \in{section}[sec:пробелы]. Если мы хотим увеличить расстояние между словами, нам нужно перейти к одной из команд, которая позволяет нам это сделать:

\startitemize

\item \ cmd {,} вставляет в документ очень маленькое пустое пространство (называемое тонким пространством). Оно используется, например, для разделения тысяч в наборе чисел (например, 1000000) или для отделения одиночной кавычки от двойных кавычек. Например: \\quotation{\color[darkmagenta]{{\tt 1\backslash,473\backslash,451}}} создаст \quotation{1\,473\,451}.

\item \PlaceMacro{\textvisiblespace}\PlaceMacro{space}\cmd{space} или  \quotation{\cmd{\textvisiblespace}} (обратная косая черта, за которой следует пробел, который, поскольку это невидимый символ, я представил как \quotation{\textvisiblespace}) вводит дополнительное пустое пространство.

\item \PlaceMacro{enskip}\cmd{enskip}, \PlaceMacro{quad}\cmd{quad} и \PlaceMacro{qquad}\cmd{qquad} вставит пустое пространство в половину {\em em}, 1 {\em em} или 2 {\em ems} соответственно. Помните, что {\em em} - это мера, зависящая от размера шрифта и эквивалентная ширине \quote{m}, которая обычно совпадает с размером шрифта в пунктах. Итак, при использовании шрифта размером 12 пунктов \cmd{enskip} дает нам пространство в 6 пунктов, \cmd{quad} дает нам 12 пунктов, а \cmd{qquad} дает нам 24 пункта.

\stopitemize

Наряду с этими командами, которые дают нам пустое пространство при точных измерениях, команды \PlaceMacro{hskip}\cmd{hskip} и \PlaceMacro{hfill}\cmd{hfill} вводят горизонтальное пространство разных размеров:

\PlaceMacro{hskip}\cmd{hskip} позволяет нам точно указать, сколько пустого пространства мы хотим добавить. Таким образом:


\startDoubleExample

\starttyping
This is \hskip 1cm 1 centimetre\\
This is \hskip 2cm 2 centimetres\\
This is \hskip 2.5cm 2.5 centimetres\\
\stoptyping

This is \hskip 1cm 1 centimetre\\
This is \hskip 2cm 2 centimetres\\
This is \hskip 2.5cm 2.5 centimetres\\

\stopDoubleExample

Указанный пробел может быть отрицательным, что приведет к наложению одного текста на другой. Таким образом:

\startDoubleExample

\starttyping
This is farce rather than 
\hskip -1cm comedy
\stoptyping

Это скорее фарс, чем комедия \hskip -1cm

\stopDoubleExample

\cmd{hfill}, со своей стороны, вводит столько пробелов, сколько необходимо, чтобы занять всю строку, что позволяет нам создавать интересные эффекты, такие как текст с выравниванием по правому краю, центрированный текст или текст с обеих сторон строки, как показано в следующий пример:

\startDoubleExample
\starttyping
\hfill On the right\\
On both\hfill sides
\stoptyping

\hfill On the right\\
On both\hfill sides

\stopDoubleExample

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:compound words,
    title=Составные слова,
  ]

Под \quotation{составными словами} в этом разделе я подразумеваю слова, которые формально понимаются как одно слово, а не слова, которые просто соединяются. Это различие не всегда легко понять: \quotation {радуга} явно состоит из двух слов (\quotation{rain + bow}), но ни один англоговорящий человек не подумает о комбинированных терминах иначе, как об одном слове. С другой стороны, у нас есть слова, которые иногда объединяются с помощью дефиса или обратной косой черты. Эти два слова имеют разные значения и употребления, но соединены (и в некоторых случаях могут стать одним словом, но еще нет!). Так, например, мы можем найти такие слова, как \quotation{French || Canadian} или \quotation{(inter |) | communication} (хотя мы также можем найти \quotation{intercommunication} и обнаружить, что говорящая публика наконец приняла два слова должны быть одним словом. Так развивается язык).

Сложные слова представляют для \ConTeXt\ некоторые проблемы, в основном связанные с их потенциальным переносом в конце строки. Если соединяющим элементом является дефис, то с типографской точки зрения проблем с переносом в конце строки в этой точке не возникает, но нам нужно избегать второго переноса во второй части слова, так как это оставит нас с два подряд идущих дефиса, которые могут вызвать трудности с пониманием.

Доступна команда \quotation{{\tt\|\|}}, чтобы сообщить \ConTeXt, что два слова составляют составное слово. Эта команда, в исключительных случаях, не начинается с обратной косой черты и допускает два разных использования:

\startitemize

\item Мы можем использовать две последовательные вертикальные черты (вертикальные черты) и написать, например, \MyKey{Испанский \|\|Аргентинский}.

\item Две вертикальные полосы могут иметь элемент соединения |/| разделения между двумя словами, заключенными между ними, как, например, \MyKey{joining\|/\|separating}.
 

\stopitemize

В обоих случаях \ConTeXt\ будет знать, что имеет дело со сложным словом, и применит соответствующие правила расстановки переносов для этого типа слова. Разница между использованием двух последовательных вертикальных полос (каналов) или обрамлением ими разделителя слов заключается в том, что в первом случае \ConTeXt\ будет использовать разделитель, который предопределен как \PlaceMacro{setuphyphenmark}\cmd{setuphyphenmark}, или другими словами дефис, который используется по умолчанию (\MyKey{--}). Итак, если мы напишем  \MyKey{picture\|\|frame}, \ConTeXt\ создаст\quotation{Picture||frame}.

С помощью \cmd{setuphyphenmark} мы можем изменить разделитель по умолчанию (в случае, когда нам нужны две черты). Допустимые значения для этой команды: \MyKey{-, ---, -, ~, (,), =, /}. Однако имейте в виду, что значение \MyKey{=} превращается в длинное тире (то же самое, что и \MyKey{---}).


Обычно \MyKey{\|\|} используется с дефисами, так как это то, что обычно используется между составными словами. Но иногда разделителем может быть скобка, если, например, мы хотим \quote{(inter)space}, или косая черта, как в \quote{input/output}. В этих случаях, если мы хотим, чтобы применялись обычные правила расстановки переносов для составных слов, мы могли бы написать \MyKey{(inter\|)\|space} or \MyKey{input\|/\|output}. Как я сказал ранее, \\MyKey{\|=\|}  считается сокращением от \MyKey{\|---\|} и вставляет длинное тире в качестве разделителя (---).

\stopsection

\startsection
  [
    reference=sec:langdoc,
    title={Язык текста},
  ]

Символы образуют слова, которые обычно принадлежат какому-либо языку. Для \ConTeXt\ важно знать язык, на котором мы пишем, потому что от этого зависит ряд важных вещей. В основном:

\startitemize[packed]

\item Расстановка переносов в словах.

\item Формат вывода определенных слов.

\item Определенные вопросы набора, связанные с традициями набора данного языка.

\stopitemize

\startsubsection
  [title=Установка и изменение языка]

\ConTeXt\ предполагает, что языком будет английский. Две процедуры могут изменить это:

\startitemize

\item С помощью команды \PlaceMacro{mainlanguage}\cmd{mainlanguage}, используемой в преамбуле для изменения основного языка документа.

\item С помощью команды \PlaceMacro{language}\cmd{language}, предназначенной для изменения активного языка в любом месте документа.

\stopitemize

Обе команды ожидают аргумент, состоящий из любого идентификатора языка (или кода). Для идентификации языка мы используем либо двухбуквенный международный код языка, установленный в ISO 639-1, который совпадает с используемым, например, в Интернете, либо английское название рассматриваемого языка, либо иногда некоторая аббревиатура названия на английском.

В \in{table}[tbl:languages] мы находим полный список языков, поддерживаемых \ConTeXt, вместе с кодом ISO для каждого из рассматриваемых языков, а также, при необходимости, кодом для определенных языковых вариантов, специально предусмотренных. \footnote{\in{Table}[tbl:languages] содержит сводку списка, полученного с помощью следующих команд:\\

  \PlaceMacro{usemodule}\type{\usemodule[languages-system]}\\
  \PlaceMacro{loadinstalledlanguages}\type{\loadinstalledlanguages}\\
  \PlaceMacro{showinstalledlanguages}\type{\showinstalledlanguages}\\

Если вы читаете этот документ спустя много времени после его написания (2020 г.), возможно, в ConTEXt будут включены дополнительные языки, поэтому было бы неплохо использовать эти команды для отображения обновленного списка языков.}

{\switchtobodyfont[script]
\placetable
  [here]
  [tbl:languages]
  {Поддержка языков в \ConTeXt}
{\starttabulate[|l|l|p(.6\textwidth)|]
\HL
\NC{\bf Language} \NC {\bf ISO code} \NC {\bf Language} (variants)
\NR
\HL
\NC Afrikaans
\NC af, afrikaans
\NR
\NC Arabic
\NC ar, arabic
\NC ar-ae, ar-bh, ar-dz, ar-eg, ar-in, ar-ir, ar-jo, ar-kw, ar-lb, ar-ly, ar-ma, ar-om, ar-qa, ar-sa, ar-sd, ar-sy, ar-tn, ar-ye
\NR
\NC Catalan
\NC ca, catalan
\NR
\NC Czech
\NC cs, cz, czech
\NR
\NC Croatian
\NC hr, croatian
\NR
\NC Danish
\NC da, danish
\NR
\NC Dutch
\NC nl, nld, dutch
\NR
\NC English
\NC en, eng, english
\NC en-gb, uk, ukenglish, en-us, usenglish
\NR
\NC Estonian
\NC et, estonian
\NR
\NC Finnish
\NC fi, finnish
\NR
\NC French
\NC fr, fra, french
\NR
\NC German
\NC de, deu, german
\NC de-at, de-ch, de-de
\NR
\NC Greek
\NC gr, greek
\NR
\NC Greek (ancient)
\NC agr, ancientgreek
\NR
\NC Hebrew
\NC he, hebrew
\NR
\NC Hungarian
\NC hu, hungarian
\NR
\NC Italian
\NC it, italian
\NR
\NC Japanese
\NC ja, japanese
\NR
\NC Korean
\NC kr, korean
\NR
\NC Latin
\NC la, latin
\NR
\NC Lithuanian
\NC lt, lithuanian
\NR
\NC Malayalam
\NC ml, malayalam
\NR
\NC Norwegian
\NC nb, bokmal, no, norwegian
\NC nn, nynorsk
\NR
\NC Persian
\NC pe, fa, persian
\NR
\NC Polish
\NC pl, polish
\NR
\NC Portuguese
\NC pt, portughese
\NC pt-br
\NR
\NC Romanian
\NC ro, romanian
\NR
\NC Russian
\NC ru, russian
\NR
\NC Slovak
\NC sk, slovak
\NR
\NC Slovenian
\NC sl, slovene, slovenian
\NR
\NC Spanish
\NC es, sp, spanish
\NC es-es, es-la
\NR
\NC Swedish
\NC sv, swedish
\NR
\NC Thai
\NC th, thai
\NR
\NC Turkish
\NC tr, turkish
\NC tk, turkmen
\NR
\NC Ukranian
\NC ua, ukrainian
\NR
\NC Vietnamese
\NC vi, vietnamese
\NR
\HL
\stoptabulate
}}

Так, например, чтобы установить испанский (кастильский) в качестве основного языка документа, мы могли бы использовать любой из трех следующих:

\starttyping
\mainlanguage[es]
\mainlanguage[spanish]
\mainlanguage[sp]
\stoptyping

Чтобы включить определенный язык {\em внутри} документа, мы можем использовать либо команду \cmd{language [Language code]}, либо специальную команду для активации этого языка. Так, например, \PlaceMacro{en}\cmd{en} активирует английский, \PlaceMacro{fr}\cmd{fr} активирует французский, \PlaceMacro{es}\cmd{es} испанский или \PlaceMacro{ca}\cmd{ca} каталонский. Как только реальный язык был активирован, он остается таковым до тех пор, пока мы не переключимся на другой язык или группа, в которой был активирован язык, не будет закрыта. Таким образом, языки работают так же, как команды смены шрифтов. Однако обратите внимание, что язык, установленный командой \cmd{language} или одним из ее сокращений (\cmd{en}, \cmd{fr}, \PlaceMacro{de}\cmd{de}, и т.д.) не влияет на язык, на котором печатаются метки (см. \in{section}[sec:labels]).

\startSmallPrint

 Хотя может быть сложно отметить язык всех слов и выражений, которые мы используем в нашем документе, которые не принадлежат к основному языку документа, это важно сделать, если мы хотим получить окончательный документ с правильным набором, особенно в профессиональной деятельности. Мы должны отмечать не весь текст, а только ту часть, которая не относится к основному языку. Иногда можно автоматизировать маркировку языка с помощью макроса. Например, для этого документа, в котором постоянно цитируются команды \ConTeXt, исходным языком которого является английский, я разработал макрос, который, помимо записи команды в соответствующем формате и цвете, помечает ее как английское слово. В моей профессиональной работе, когда мне нужно цитировать много французской и итальянской библиографии, я включил поле в свою библиографическую базу данных, чтобы выбрать язык работы, чтобы я мог автоматизировать указание языка в цитатах и ​​списках библиографические ссылки.

 Если мы используем два языка, которые используют разные алфавиты в одном и том же документе (например, английский и греческий или английский и русский), есть уловка, которая избавит нас от необходимости отмечать язык выражений, построенных с помощью альтернативного алфавита: измените настройку основного языка (см. следующий раздел), чтобы она также загружала шаблоны переносов по умолчанию для языка, использующего другой алфавит. Например, если мы хотим использовать английский и древнегреческий языки, следующая команда избавит нас от необходимости отмечать язык текстов на греческом:

  \type{\setuplanguage[en][patterns={en, agr}]}

Это работает только потому, что в английском и греческом языках используется другой алфавит, поэтому не может быть конфликта в схемах переноса двух языков, поэтому мы можем загружать их оба одновременно. Но в двух языках, использующих один и тот же алфавит, одновременная загрузка шаблонов расстановки переносов обязательно приведет к неправильной расстановке переносов.

\stopSmallPrint

\stopsubsection

\startsubsection
  [
    reference=sec:langconfig,
    title=Настройка языка,
  ]
  \PlaceMacro{setuplanguage}

\dontleavehmode\ConTeXt\ связывает работу определенных утилит с конкретным языком, активным в любой момент времени. Связи по умолчанию можно изменить с помощью \cmd{setuplanguage}, синтаксис которого:

\type{\setuplanguage[Language][Configuration]}

где {\em Language} - это код языка для языка, который мы хотим настроить, а {\em Configuration} содержит конкретную конфигурацию, которую мы хотим установить (или изменить) для этого языка. В частности, разрешено до 32 различных вариантов конфигурации, но я буду иметь дело только с теми, которые кажутся подходящими для вводного текста, например этого:

\startitemize

\item {\tt\bf date}: позволяет нам настроить формат даты по умолчанию. Смотрите дальше на \at{page}[sec:dates].

\item {\tt\bf lefthyphenmin, righthyphenmin}: минимальное количество символов, которое должно быть слева или справа для поддержки переносов слова.
Например, \cmd{setuplanguage[en][lefthyphenmin=4]} не будет переносить любое слово, если слева от возможного дефиса меньше 4 символов.

\item {\tt\bf spacing}:  возможные значения для этого параметра: «широкий» \MyKey{broad}  или «упакованный» \MyKey{packed}. В первом случае (широком) будут применяться правила расстановки интервалов между словами на английском языке, что означает, что после точки и когда следует другой символ, будет добавлено определенное количество дополнительного пробела. С другой стороны, \MyKey{spacing=packed} не позволит применять эти правила. Для английского языка по умолчанию используется широкий.

\item {\tt\bf leftquote, rightquote}: укажет символы (или команды), соответственно, которые \cmd{quote} будут использоваться слева и справа от текста, являющегося его аргументом (для этой команды см.\at{page}[sec:quote]). 

\item {\tt\bf leftquotation, rightquotation}: укажите символы (или команды), соответственно, которые \cmd{quotation} будет использовать слева и справа от текста, являющегося его аргументом (для этой команды см. \at{page}[sec:quote])

\stopitemize%%%@@@

\stopsubsection

\startsubsection
  [
    reference=sec:labels,
    title=Ярлыки, связанные с определенными языками,
  ]

Многие команды \ConTeXt\ автоматически генерируют определенные тексты (или  {\em labels}), как, например, команда \cmd{placetable}, которая записывает метку \quotation{Table xx} под вставляемой таблицей, или \cmd{placefigure}, который вставляет метку \quotation{Figure xx}.

Эти {\em labels} чувствительны к языку, установленному с помощью \cmd{mainlanguage} (но не чувствительны, если установлены с помощью \cmd{language}), и мы можем изменить их с помощью

\PlaceMacro{setuplabeltext}\type{\setuplabeltext[Language][Key=Label]}

где {\em Key} -- термин, по которму \ConTeXt\ узнает метку, а {\em Label} -- это текст, который мы хотим чтобы был сгенерирован \ConTeXt\. Так например,

\type{\setuplabeltext[es][figure=Imagen~]}
увидит, что когда основным языком является испанский, изображения, вставленные с помощью \cmd{placefigure} будут называться не \quotation{Figure x}, а  \quotation{Imagen x}.Обратите внимание, что после текста на самой этикетке необходимо оставить пробел, чтобы гарантировать, что этикетка не будет прикреплена к следующему символу. В этом примере я использовал символ \quotation{\lettertilde}; можно было бы написать \MyKey{[figure=Imagen\{ \}]} заключив пробел между фигурными скобками, чтобы \ConTeXt\ не избавился от него.

Какие ярлыки мы можем переопределить с помощью \cmd{setuplabeltext}? Документация \ConTeXt\ по этому поводу не так полна, как можно было бы надеяться.  В справочном руководстве 2013 г. (которое объясняет больше всего об этой команде) упоминаются \MyKey{chapter}, \MyKey{table}, \MyKey{figure}, \MyKey{appendix}... \Conjecture и дополнительные \quotation{другие сопоставимые текстовые элементы}. Можно предположить, что имена будут английскими названиями рассматриваемого элемента.

\startSmallPrint

 Одним из преимуществ {\em free libre software} является то, что исходные файлы доступны пользователю; так что мы можем изучить их.Я сделал это и, просматривая {\em snooping} исходные файлы \ConTeXt обнаружил файл \MyKey{lang-txt.lua}, доступный в {\tt tex/texmf-context/tex/context/base/mkiv} который, как мне кажется, содержит предопределенные метки и их различные переводы; так что если в любое время \ConTeXt\ сгенерирует переопределенный текст который мы хотим изменить, чтобы увидеть имя метки, с которой связан текст, мы можем открыть соответствующий файл и обнаружить, что мы хотим изменить. Таким образом, мы можем увидеть, какое название ярлыка с ним связано.

\stopSmallPrint

Если мы хотим вставить текст, связанный с определенной меткой, где-нибудь в документе, мы можем сделать это с помощью команды \PlaceMacro{labeltext}\cmd{labeltext} command. Так, например, если я хочу сослаться на таблицу, чтобы гарантировать, что я назову ее так же, как \ConTeXt\ вызывает ее в команде  \cmd{placetable}, я могу написать: \quotation{{\tt Так же, как показано в \backslash labeltext\{table\} на следующей странице.} Этот текст в документе, где \cmd{mainlanguage} -- английский, будет содержать: \quotation{Так же, как показано в  \labeltext{table} на следующей странице ».

\startSmallPrint

Некоторые метки, которые можно переопределить с помощью \cmd{setuplabeltext}, по умолчанию пусты; например,\MyKey{chapter} или \MyKey{section}. Это связано с тем, что по умолчанию \ConTeXt\ не добавляет метки к командам секционирования. Если мы хотим изменить эту операцию по умолчанию, нам нужно только переопределить эти метки в преамбуле нашего документа, и поэтому, например, \cmd{setuplabeltext[chapter=Chapter\lettertilde]} увидит, что главам предшествует слово \quotation{Chapter}.

\stopSmallPrint

Наконец, важно отметить, что, хотя, как правило, в \ConTeXt\ команды, которые допускают несколько параметров, разделенных запятыми, в качестве аргумента, последний параметр может заканчиваться запятой, и ничего плохого не происходит. В \tex{setuplabeltext}, который генерирует ошибку при компиляции.

\stopsubsection

\startsubsection
  [title=Некоторые языковые команды]

\startsubsubsection
  [
    reference=sec:dates,
    title=Команды, связанные с датой,
  ]
  \PlaceMacro{currentdate}\PlaceMacro{date}\PlaceMacro{month}

\ConTeXt\ есть три команды, связанные с датой, которые выводят свой результат на активном языке во время выполнения. Это:

\startitemize

\item \tex{currentdate}: запускается без аргументов в документе, в котором основным языком является английский, возвращает системную дату в формате \quotation{Day Month Year} «День Месяц Год». Например: \quotation{11 сентября 2020 года}. Но мы также можем указать ему использовать другой формат (как это произошло бы в США и некоторых других частях англоязычного мира, которые следуют их системе размещения месяца перед днем, отсюда и печально известная дата, 9/11), или включать название дня недели (дня недели ({\tt weekday}), или включать только некоторые элементы даты (день, месяц, год {\tt day, month, year}).

Чтобы указать другой формат даты, \MyKey{dd} или \MyKey{day} представляют дни, \MyKey{mm} месяцы (в числовом формате), MyKey{month} месяцы в алфавитном формате строчными буквами и \MyKey{MONTH} в верхнем регистре. Что касается года, то \MyKey{yy} будет записывать только последние цифры, а \MyKey{year} или \MyKey{y} - все четыре. Если нам нужен какой-то разделительный элемент между компонентами даты, мы должны написать это прямо. Например

  \type{\currentdate[weekday, dd, month]} 

  when run on 9 September 2020 will write \quotation{Wednesday 9 September}.
  
\item \tex{date}: эта команда, запущенная без аргументов, выдает точно такой же результат, что и \cmd{currentdate}, то есть фактическая дата в стандартном формате. Однако в качестве аргумента может быть указана конкретная дата. Для этого даны два аргумента: с помощью первого аргумента мы можем указать день (\MyKey{d}), месяц (\MyKey{m}) и год (\MyKey{y}), соответствующие дате, которую мы хотим представить, а вторым аргументом (необязательным) мы можем указать формат представляемой даты. Например, если мы хотим знать, в какой день недели встречались Джон Леннон и Пол Маккартни, событие, которое, согласно Википедии, произошло 6 июля 1957 года, мы могли бы написать

  \type{\date[d=6, m=7, y=1957][weekday]}

  and so we would find out that such an historical event happened on a Saturday. 

\item \tex{month} принимает число в качестве аргумента и возвращает название месяца, соответствующего этому числу.
  
\stopitemize

\stopsubsubsection

\startsubsubsection
  [title=Команда \tex{translate}]
  \PlaceMacro{translate}

Команда translate поддерживает серию фраз, связанных с определенным языком, так что тот или иной будет вставлен в окончательный документ в зависимости от языка, активного в любой момент времени. В следующем примере команда translate используется для связывания четырех фраз с испанским и английским, которые сохраняются в буфере памяти (относительно среды {\tt buffer} см. \in{section}[sec:buffer]):

\starttyping
\startbuffer
  \starttabulate[|*{4}{lw(.25\textwidth)|}]
    \NC \translate[es=Su carta de fecha, en=Your letter dated]
    \NC \translate[es=Su referencia, en=Your reference]
    \NC \translate[es=Nuestra referencia, en=Our reference]
    \NC \translate[es=Fecha, en=Date] \NC\NR
  \stoptabulate
\stopbuffer
\stoptyping

так что если мы вставим {\em buffer} в ту точку документа, где активирован испанский, будут воспроизводиться испанские фразы, но если в той точке документа, где вставлен буфер, активирован английский, английские фразы будут вставлен. Таким образом:

%\startpacked
\language[es]  
\startbuffer
  \starttabulate[|*{4}{lw(.25\textwidth)|}]
    \NC \translate[es=Su carta de fecha, en=Your letter dated]
    \NC \translate[es=Su referencia, en=Your reference]
    \NC \translate[es=Nuestra referencia, en=Our reference]
    \NC \translate[es=Fecha, en=Date] \NC\NR
  \stoptabulate
\stopbuffer

\starttyping
\language[es]
\getbuffer
\stoptyping

будет генерировать

\example{\getbuffer}

в тоже время
\starttyping
\language[en]
\getbuffer
\stoptyping

будет генерировать

{\en\example{\getbuffer}}

%\stoppacked

\stopsubsubsection

\startsubsubsection
  [
    reference=sec:quote,
    title=Команды \tex{quote} и \tex{quotation},
  ]
  \PlaceMacro{quote}\PlaceMacro{quotation}

Одна из наиболее распространенных типографских ошибок в текстовых документах возникает, когда кавычки (одинарные или двойные) открываются, но не закрываются явно. Чтобы этого не произошло, \ConTeXt\ предоставляет команды \cmd{quote} и \cmd{quotation}, которые цитируют текст, являющийся их аргументом; \cmd{quote} будет использовать одинарные кавычки, а \cmd{quotation} будет использовать двойные кавычки.

Эти команды чувствительны к языку, поскольку они используют символ или набор команд по умолчанию для рассматриваемого языка, чтобы открывать и закрывать кавычки (см. \in{section}[sec:langconfig]); и поэтому, например, если мы хотим использовать испанский в качестве стиля по умолчанию для двойных кавычек - гильметов или шевронов (угловых скобок)), типичных для испанского, итальянского, французского языков, мы должны написать:

\type{\setuplanguage[es][leftquotation=«, rightquotation=»]}.

Однако эти команды не управляют вложенными кавычками; хотя мы можем создать утилиту, которая делает это, используя тот факт, что \cmd{quote} и \cmd{quote} являются фактическими приложениями того, что \ConTeXt\ вызывает {\em delimitedtext}, и что можно определить дальнейшие приложения с \PlaceMacro{definedelimitedtext}\cmd{definedelimitedtext}. Таким образом, следующий пример:

\starttyping
\definedelimitedtext
  [CommasLevelA]
  [left=«, right=»]

\definedelimitedtext
  [CommasLevelB]
  [left=“, right=”]

\definedelimitedtext
  [CommasLevelC]
  [left=`, right=']
\stoptyping

создаст три команды, которые позволят использовать до трех разных уровней цитирования. Первый уровень с боковыми кавычками, второй с двойными кавычками и третий с одинарными кавычками.

Конечно, если мы используем английский в качестве основного языка, то автоматически будут использоваться одинарные и двойные кавычки по умолчанию (фигурные, а не прямые, как вы найдете в этом документе!).
\stopsubsubsection

\stopsubsection

\stopsection

\stopchapter

\stopcomponent

%%% Local Variables:
%%% mode: ConTeXt
%%% mode: auto-fill
%%% coding: utf-8-unix
%%% TeX-master: "../introCTX.mkiv"
%%% End:
%%% vim:set filetype=context tw=72 : %%%
