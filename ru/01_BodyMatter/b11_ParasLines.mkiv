%%% File:       b11_ParasLines.mkiv
%%% Author:     Joaquín Ataz-López
%%% Begun:      August 2020
%%% Concluded:  August 2020
% Contenido: Эта глава более последовательна, чем предыдущая. Большая часть «TeXBook» посвящена объяснению вертикального пространства, а в ConTeXt an Excursion глава «Spacing» относится к вертикальному пространству. 
%
%%% Edited with: Emacs + AuTeX - and at times vim + context-plugin
%%%

\environment ../introCTX_env.mkiv

\startcomponent b11_ParasLines.mkiv

\startchapter
  [title={Параграфы, строки и\\ вертикальные пространства},
   bookmark={Paragraphs, lines and vertical space}]

\TocChap

Общий вид документа определяется в основном размером и компоновкой страниц, которые мы видели в \in{Chapter}[cap:pages], шрифтом, который мы выбрали, с которым мы работали в \in{Chapter}[sec:fontscol], а также другими вопросами, такими как межстрочный интервал, выравнивание абзацев, интервал между ними и т. д. В этой главе основное внимание уделяется этим другим вопросам.

\startsection
  [title={Параграфы и их характеристики}]

Абзац является основной единицей текста для \ConTeXt. Существует две процедуры, чтобы начать абзац:

\startitemize[n]

  \item Вставка одной или нескольких последовательных пустых строк в исходный файл.

  \item Команды \PlaceMacro{par}\tex{par} или \PlaceMacro{endgraf}\tex{endgraf}.

\stopitemize

Обычно используется первая из этих процедур, поскольку она проще и создает исходные файлы, которые легче читать и понимать. Вставка разрывов абзаца с помощью явной команды обычно выполняется только внутри макроса (см. \in{section}[sec:define]) или в ячейке таблицы (см.\in{section}[sec:tables]).

В хорошо набранном документе с типографской точки зрения важно, чтобы абзацы визуально выделялись друг от друга. Обычно это достигается двумя процедурами: небольшим отступом в первой строке каждого абзаца или небольшим увеличением пустого пространства между абзацами, а иногда и комбинацией обеих процедур, хотя в некоторых местах это не рекомендуется, поскольку считается типографически избыточным.

\startSmallPrint

Я не совсем согласен. Простой отступ первой строки не всегда достаточно визуально выделяет разделение между абзацами; но увеличение интервала, не сопровождающееся отступом, создает проблемы в случае абзаца, который начинается в верхней части страницы, и поэтому мы можем не знать, новый ли это абзац или продолжение предыдущей страницы. Комбинация обеих процедур избавляет от сомнений.

\stopSmallPrint

Давайте посмотрим, прежде всего, как достигается отступ строк и абзацев с помощью \ConTeXt.

\startsubsection
  [
    reference=sec:indentation,
    title={Автоматический отступ в первых строках абзацев},
  ]

По умолчанию автоматическая вставка небольшого отступа в первую строку абзаца отключена. Мы можем включить его, отключить снова и, когда он будет включен, указать степень отступа с помощью команды \PlaceMacro{setupindenting}\cmd{set\-up\-in\-den\-ting}, которая позволяет следующим значениям указать, следует ли включать отступы:

\startitemize[packed]

  \item {\tt\bf always}: все абзацы будут иметь отступ независимо от этого.

  \item {\tt\bf yes}: включить {\em normal} отступ абзаца. Некоторые абзацы, которым предшествует дополнительный вертикальный интервал, например, первый абзац разделов или абзацы, следующие за определенными средами, не будут иметь отступа.

  \item {\tt\bf no, not, never, none}:отключить автоматический отступ первой строки в абзацах.

\stopitemize

В случаях, когда мы включили автоматический отступ, мы также можем указать с помощью той же команды, какой отступ должен быть. Для этого мы можем явно использовать размер (например, 1,5 см) или символические слова \MyKey{small}, \MyKey{medium} и \MyKey{big}, которые указывают, что нам нужны маленькие, средние или большие отступы.

\startSmallPrint

В некоторых традициях набора текста (в том числе испанских) отступ по умолчанию составлял два квадрата. В типографии четырехугольник (первоначально \em{quadrat}) представлял собой металлическую прокладку, используемую при наборе текста печатными буквами. Позже этот термин был принят в качестве общего названия для двух общих размеров пространства в типографии, независимо от используемой формы набора текста. Квадрат em - это пространство шириной в один em; шириной в высоту шрифта (Википедия).  Таким образом, с буквой из 12 пунктов квадрат будет иметь ширину 12 пунктов и высоту 12 пунктов. \ConTeXt\ содержит две команды quad: \text{quad}, которая генерирует одно пространство, указанное выше, и \tex{qquad}, которое генерирует вдвое больше, но на основе используемого шрифта. Отступ в два квадрата с буквой из 11 пунктов будет составлять 22 балла, а с буквой из 12 пунктов - 24 балла.

\stopSmallPrint

Когда отступы включены, если мы не хотим, чтобы определенный абзац был с отступом, нам нужно использовать команду \PlaceMacro{noindentation}\tex{noindentation}.

\startSmallPrint

Обычно я включаю автоматический отступ в своих документах с помощью \cmd{set\-up\-in\-den\-ting[yes, big]}. Однако в этом документе я этого не делал, потому что, если бы был включен отступ, большое количество коротких предложений и примеров привело бы к визуально неопрятному виду страниц.

 
\stopSmallPrint

\stopsubsection

\startsubsection
  [title=Отступ специального абзаца]

Одной из графических процедур выделения абзаца является отступ либо справа, либо слева (или с обеих сторон) от абзаца. Это используется, например, для блока двойных кавычек.

\ConTeXt\ имеет среду, которая позволяет нам изменять отступ абзаца, чтобы выделить текст в абзаце. Это среда \MyKey{narrower}:


\PlaceMacro{startnarrower}\type{\startnarrower [Options] ... \stopnarrower}

где {\em Options} могут быть:

\startitemize

  \item {\tt\bf left}: отступ по левому краю.

  \item {\tt\bf Num*left}:сделает отступ для левого края, умножив {\em normal} отступ на {\em Num} (например, {\tt 2*left}).

  \item {\tt\bf right}: отступ по правому краю.

  \item {\tt\bf Num*right}: делает отступ для правого края, умножив {\em normal} отступ на {\em Num} (например, {\ tt 2*right}).

  \item {\tt\bf middle}: делает отступ по обоим краям. Это значение по умолчанию.

  \item {\tt\bf Num*middle}: делает отступ на обеих сторонах, умножая {\em normal} отступ на {\em Num}.

\stopitemize

При объяснении опций я упомянул {\em нормальный отступ}; это относится к величине отступа слева и справа, который \MyKey{narrower} применяет по умолчанию. Этот {\em amount} можно настроить с помощью \PlaceMacro{setupnarrower}\tex{setupnarrower}, который позволяет использовать следующие параметры конфигурации:

\startitemize[packed]

  \item {\tt\bf left}: величина отступа для левого края.

  \item {\tt\bf right}: величина отступа для правогг края.

  \item {\tt\bf middle}: величина отступа для обоих краев.

  \item {\tt\bf before}: команда, которую нужно запустить перед входом в среду.

  \item {\tt\bf after}: команда, которая будет запущена после существующей среды.

\stopitemize

Если мы хотим использовать разные конфигурации более узкой среды в нашем документе, мы можем присвоить каждому из них другое имя с помощью \PlaceMacro{Definenarrower}\type{\Definenarrower[Name] [Configuration]}

где {\em Name} - это имя, связанное с этой конфигурацией, а {\em Configuration} допускает те же значения, что и \tex{setupnarrower}.

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:verticalspace,
    title={Вертикальное пространство между параграфами},
  ]

\startsubsection
  [title=\tex{setupwhitespace}]

Как мы уже знаем из (\in{section}[sec:linebreaks]), для \ConTeXt\ не имеет значения, сколько последовательных пустых строк в исходном файле: одна или несколько пустых строк вставят один разрыв абзаца в итоговый документ. Чтобы увеличить расстояние между абзацами, не нужно добавлять лишнюю пустую строку в исходный файл. Вместо этого эта функция управляется командой \PlaceMacro{setupwhitespace}\tex{setupwhitespace}, которая допускает следующие значения:

\startitemize

  \item {\tt\bf none}: означает, что между абзацами не будет дополнительного вертикального пробела.

  \item {\tt\bf small, medium, big}: в этих вставках соответственно маленькое, среднее или большое вертикальное пространство. Фактический размер пространства, вставляемого этими значениями, зависит от размера шрифта.

  \item {\tt\bf line, halfline, quarterline}: измеряет дополнительное пустое пространство по отношению к высоте строк и вставляет дополнительную строку, половину строки или четверть строки соответственно.

  \item {\tt\bf DIMENSION}: устанавливает фактический размер пространства между абзацами. Например, \tex{setupwhitespace[5pt]}. 

\stopitemize

Как правило, не рекомендуется устанавливать точный размер в качестве значения для \tex{setupwhitespace}. Предпочтительно использовать символьные значения small, medium, big, line, halfline или четверть линии. Это так по двум причинам:

\startitemize

  \item Символьные значения являются эластичными размерами (см. \in{section}[sec:sizes]), что означает, что они имеют {\em нормальные} размеры, но допускается некоторое уменьшение или увеличение этого значения, чтобы помочь \ConTeXt\ при наборе страниц, для того, чтобы разрывы абзацев были эстетически похожи. Фиксированный размер разделения между абзацами затрудняет достижение хорошей разбивки на страницы для документа.

  \item Символьные значения small, medium, big и т. Д. Рассчитываются на основе размера шрифта, поэтому, если это изменится в определенных частях, это также изменит величину вертикального интервала между абзацами, и конечный результат всегда будет гармоничным. И наоборот, на фиксированное значение вертикального интервала не повлияют изменения размера шрифта, который обычно переводится в документ с плохо распределенным белым пространством (с эстетической точки зрения) и не в соответствии с правилами типографской настройки.

\stopitemize

Если для вертикального интервала между абзацами установлено значение, доступны две дополнительные команды: \PlaceMacro{nowhitespace}\tex{nowhitespace}, которая удаляет лишние пробелы между определенными абзацами, и \PlaceMacro{whitespace}\tex{whitespace}, которая делает противоположный. Однако эти команды нужны редко, потому что \ConTeXt\ сам достаточно хорошо управляет вертикальным интервалом между абзацами; особенно, если один из предопределенных размеров был вставлен в качестве значения, рассчитанного на основе текущего активного размера шрифта и интервала.

\startSmallPrint

Значение \tex{nowhitespace} очевидно. Но не обязательно \tex{whitespace}, потому что какой смысл упорядочивать интервалы по вертикали для определенных абзацев, учитывая, что интервал по вертикали уже обычно установлен \Conjecture для всех абзацев? Однако при написании расширенных макросов \tex{whitespace} может быть полезен в контексте цикла, который должен принимать решение на основе значения определенного условия. Это более или менее сложное программирование, и я не буду здесь вдаваться в подробности.

\stopSmallPrint

\stopsubsection

\startsubsection
  [title={Paragraphs with no extra vertical space between them}]

Если мы хотим, чтобы в определенных частях нашего документа были абзацы, не разделенные дополнительным вертикальным пространством, мы, конечно, можем изменить общую конфигурацию \tex{setupwhitespace}, но это в некотором смысле противоречит  философии \ConTeXt\, согласно которой общие команды конфигурации должны быть помещены исключительно в преамбулу исходного файла, чтобы обеспечить согласованный и легко изменяемый общий вид документов. ПОэтому, среда \MyKey{Packed}, общий синтаксис которой

\PlaceMacro{startpacked}\type{\startpacked [Space] ... \stoppacked}

где {\em Space} - необязательный аргумент, указывающий, какое расстояние по вертикали желательно между абзацами в среде. Если этот параметр не указан, дополнительное вертикальное пространство не будет применяться.

\stopsubsection

\startsubsection
  [title={Добавление дополнительного вертикального пространства в определенном месте документа}]

Если в определенной точке документа обычного вертикального интервала между абзацами недостаточно, мы можем использовать команду \PlaceMacro{blank}\tex{blank}. При использовании без аргументов \tex{blank} вставляет такое же количество вертикального пространства, какое было установлено с помощью \tex{setupwhitespace}. Но мы можем указать либо конкретный размер в квадратных скобках, либо одно из символьных значений, вычисленных из размера шрифта: маленький, средний или большой. Мы также можем умножить эти размеры на некоторое целое число и так далее, например, \tex{blank[3*medium]} вставит эквивалент трех средних разрывов строки. Мы также можем соединить два размера вместе. Например, \tex{blank [2*big,medium]} вставит два больших и средних разрыва.

Поскольку \tex{blank} предназначен для увеличения вертикального расстояния между абзацами, он не действует, если разрыв страницы вставляется между двумя абзацами, расстояние между которыми должно быть увеличено; и если мы вставим две или более команд \tex{blank} подряд, будет применяться только одна из них (та, в которой будет больше всего места для вставки). Команда \tex{blank}, помещенная после разрыва страницы, также не имеет никакого эффекта. Однако в этих случаях мы можем принудительно вставить вертикальный интервал, используя символическое слово \MyKey{force} в качестве параметра команды. Так, например, если мы хотим, чтобы заголовки глав в нашем документе отображались ниже по странице, чтобы общая длина страницы была меньше, чем остальные страницы (относительно частая типографская практика), мы должны писать в конфигурация команды \tex{chapter}, например:

\starttyping
\setuphead
  [chapter]
  [
    page=yes,
    before={\blank[4cm, force]},
    after={\blank[3*medium]}
  ]
\stoptyping

Эта последовательность команд гарантирует, что главы всегда начинаются с новой страницы, а метка главы перемещается на четыре сантиметра вниз. Без использования параметра \MyKey{force} это не сработает.

\stopsubsection

\startsubsection
  [title=\tex{setupblank} and \tex{defineblank}]
\PlaceMacro{setupblank}\PlaceMacro{defineblank}

Ранее я сказал, что \tex{blank}, используемый без аргументов, эквивалентен \tex{blank [big]}. Однако мы можем изменить это с помощью \tex{setupblank}, установив, например, \tex{setupblank[0.5cm]} или \tex{setupblank[medium]}. При использовании без аргументов \tex{setupblank} подстраивает значение под размер текущего шрифта.

Как и в случае с \tex{setupwhitespace}, пробел, вставленный \tex{blank}, когда его значение является одним из предопределенных символьных значений, является эластичным размером, допускающим некоторую корректировку. Мы можем изменить это с помощью \MyKey{fixed}, с возможностью позже восстановить значение по умолчанию с помощью (\MyKey{flexible}). Так, например, для текста в двойных столбцах рекомендуется установить \tex{setupblank [fixed, line]}, а при возврате к одиночному столбцу - \tex{setupblank[flexible, default]}.

С помощью \tex{defineblank} мы можем связать определенную конфигурацию с именем. Общий формат этой команды:

\type{\defineblank [Name] [Configuration]}

Как только наша конфигурация пустого пространства определена, мы можем использовать ее с помощью \tex{blank[ConfigurationName]}.

\stopsubsection

\startsubsection
  [title={Другие процедуры для достижения большего вертикального пространства}]

В \TeX\ команда, которая вставляет лишнее вертикальное пространство, - это \PlaceMacro{vskip}\tex{vskip}. Эта команда, как и почти все команды \TeX\, также работает в \ConTeXt\, но настоятельно не рекомендуется ее использовать, поскольку она мешает внутреннему функционированию некоторых макросов \ConTeXt. Вместо него предлагается использовать \PlaceMacro{godown}\tex{godown}, синтаксис которого:

\type{\godown[Измерение]}

где {\em Dimension} должно быть числом с десятичными знаками или без них, за которым следует единица измерения. Например, \tex{godown [5cm]} сместит страницу на 5 сантиметров вниз; хотя, если изменение страницы меньше этой суммы, \tex{godown} переместится только на следующую страницу. Точно так же \tex{godown} не будет иметь никакого эффекта в начале страницы, хотя мы можем {\em обмануть его}, написав, например, \quote{\cmd {\textvisiblespace\backslash godown [3cm]}}\footnote{Напомним, что мы используем в этом документе символ \quote{\textvisiblespace} для обозначения пустого места, когда нам важно его увидеть.} Который сначала вставит пробел, что будет означать, что мы уже не в начале страницы, а затем опустится на три сантиметра.

\startSmallPrint

Как мы знаем, \tex{blank} также допускает точное измерение в качестве аргумента. Следовательно, с точки зрения пользователя, написание \tex{blank [3cm]} или \tex{godown[3cm]} практически одно и то же. Однако между ними есть некоторые тонкие различия. Так, например, две последовательные команды \tex{blank} не могут быть накоплены, и когда это происходит, применяется только та, которая требует большего расстояния. С другой стороны, две или более команды \tex{godown} могут отлично накапливаться.

\stopSmallPrint

Другая довольно полезная команда \TeX\, использование которой не вызывает проблем в \ConTeXt, - это \PlaceMacro{vfill}\tex{vfill}. Эта команда вставляет гибкое вертикальное пустое пространство до низа страницы. Как будто команда {\em pushes} выталкиваетто, что написано после нее. Это позволяет получить интересные эффекты, например, как разместить определенный абзац внизу страницы, просто поставив перед ним \tex{vfill}. Теперь эффект \tex{vfill} трудно оценить, если его использование не сочетается с принудительными разрывами страниц, потому что нет смысла сдвигать абзац или строку текста вниз, если абзац по мере его роста растет вверх. Так, например, чтобы убедиться, что строка находится внизу страницы, мы должны написать:

\starttyping
\vfill
Line at the bottom
\page[yes]
\stoptyping

Как и все другие команды, которые вставляют вертикальный пробел, \tex{vfill} не действует в начале страницы. Но мы можем {\em обмануть его}, поставив перед ним принудительный пробел. Так, например:

\starttyping
\page[yes]
\ \vfill
Centre line
\vfill
\page[yes]
\stoptyping

будет вертикально центрировать фразу {центральная линия} на странице.

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:lines,
    title={Как \ConTeXt\ строит строки,\\ образующие абзацы},
  ]

Одна из основных задач системы набора текста - взять длинную строку слов и разделить ее на отдельные строки подходящего размера. Например, каждый абзац в этом тексте разделен на строки шириной 15 сантиметров, но автору не нужно было беспокоиться о таких деталях, поскольку \ConTeXt\ выбирает точки останова после рассмотрения каждого абзаца целиком, так что последние слова абзаца действительно может повлиять на деление первой линии. В результате пространство между словами во всем абзаце становится максимально равномерным.

\startSmallPrint

Это один из аспектов, в котором мы можем лучше всего отметить другой способ работы текстовых редакторов и лучшее качество, достигаемое с такими системами, как \ConTeXt. Поскольку текстовый процессор, когда он достигает конца строки и переходит к следующей, регулирует пробел в только что завершенной строке, чтобы включить выравнивание по правому краю. Это делается с каждой строкой, и в конце каждая строка в абзаце будет иметь различный интервал между словами. Это может вызвать очень плохой эффект (например, \quote{реки} пробелов, проходящих через текст). \ConTeXt, с другой стороны, обрабатывает абзац целиком и для каждой строки вычисляет, сколько точек останова допустимо, а также величину межсловного интервала, которая может возникнуть в результате разрыва строки. Поскольку точка останова строки влияет на потенциальные точки останова следующих строк, общее количество возможностей может быть очень большим; но это не проблема для \ConTeXt. Он примет окончательное решение на основе всего абзаца, гарантируя, что расстояние между словами в каждой строке будет {\em как можно более похожим}, что приводит к гораздо лучшему набранному абзацу; визуально более компактный.

\stopSmallPrint

Для этого \ConTeXt\ тестирует разные альтернативы и присваивает каждой из них значение плохой репутации  {\em badness} на основе её параметров. Они были созданы после глубокого изучения искусства книгопечатания. Наконец, изучив все возможности, \ConTeXt\ выбирает наименее неподходящий вариант (с наименьшим значением вредности). В общем, это работает достаточно хорошо, но неизбежно будут случаи, когда точки останова по строкам выбираются не из лучших или которые нам не кажутся лучшими. Поэтому иногда мы хотим сказать программе, что определенные места не являются хорошими точками останова. Тогда в других случаях мы захотим принудительно прервать работу в определенной точке.

\startsubsection
  [
    reference=sec:lettertilde,
    title={Использование зарезервированного символа \quote{{\tt\lettertilde}}},
  ]

Основными кандидатами на точки останова на строку, очевидно, являются пробелы между словами. Чтобы указать, что определенный пробел никогда не следует заменять разрывом строки, мы используем, как мы уже знаем, зарезервированный символ \quote{\lettertilde}, который \TEX\ называет {\em tie}, связывая два слова вместе.

Обычно рекомендуется использовать это неразрывное пространство в следующих случаях:

\startitemize[packed]

  \item Между частями, составляющими сокращение. Например, {\tt U\lettertilde S}.

  \item Между сокращениями и термином, к которому они относятся. Например, {\tt Dr\lettertilde Anne Ruben} or {\tt p.\lettertilde 45}.

  \item Между числами и связанным с ними термином. Например, {\tt Elizabeth\lettertilde II}, {\tt 45\lettertilde volumes}.

  \item Между цифрами и предшествующими или следующими за ними символами, если они не являются надстрочными индексами. Например, {\tt 73\lettertilde km}, {\tt \$\lettertilde 53}; however, {\tt 35'}.

  \item В процентах, выраженных словами. Например, {\tt  twenty\lettertilde per\lettertilde cent}.

  \item IВ группах чисел, разделенных пробелом. Например, {\tt 5\lettertilde 357\lettertilde 891}. Хотя в этих случаях предпочтительнее использовать так называемое тонкое пространство {\em thin space}, достигаемое в \ConTeXt\ с помощью команды \tex{,} и, следовательно, записью {\tt 5\backslash,357\backslash,891}.

  \item Чтобы аббревиатура не была единственным элементом в этой строке. Например:

  \starttyping
    There are sectors such as entertainment, communications media,
    commerce,~etc.
  \stoptyping

\stopitemize

К этим случаям {\sc Knuth} (отец \TEX) добавляет следующие рекомендации:

\startitemize[packed]

  \item  После сокращения, которое не находится в конце предложения.

  \item Относительно частей документа, таких как главы, приложения, рисунки и т. Д. Например, {\tt Chapter\lettertilde 12}.

  \item Между именем и инициалом второго имени лица или между инициалом имени и фамилией. Например, {\tt Donald\lettertilde E. Knuth}, {\tt A.\lettertilde
  Einstein}.

  \item  Между математическими символами в приложении к именам. Например,  {\tt dimension\lettertilde \$d\$}, {\tt width\lettertilde \$w\$}.

  \item Между последовательными символами. Например, {\tt \{1,\lettertilde 2, \backslash dots,\lettertilde \$n\$\}}.

  \item Когда число строго связано с предлогом. Например {\tt from 0 to\lettertilde 1}.

  \item  Когда математические символы выражаются словами. Например, {\tt equals\lettertilde a\lettertilde \$n\$}.

  \item В списках внутри абзаца. Например: {\tt (1)\lettertilde green, (2)\lettertilde red, (3)\lettertilde blue}.

\stopitemize

Много случаев? Без сомнения, типографское совершенство требует дополнительных усилий. Понятно, что если мы не хотим этого, нам необязательно применять эти правила, но знать их не помешает. Кроме того, - и здесь я говорю по собственному опыту - как только мы привыкаем применять их (или любой из них), это становится автоматическим. Это похоже на расстановку акцентов на словах, когда мы их пишем (что и нужно делать по-испански): для тех из нас, кто это делает, если мы привыкли писать их автоматически, нам больше не нужно писать слово с помощью акцента, чем для слова без акцента.

\stopsubsection

\startsubsection
  [title=Перенос слов]

За исключением языков, состоящих в основном из односложных слов, довольно сложно получить оптимальный результат, если точки останова на строке находятся только в пространстве между словами. Следовательно, \ConTeXt\ также анализирует возможность вставки разрыва строки между двумя слогами слова; и для этого важно, чтобы он знал язык, на котором написан текст, поскольку правила расстановки переносов различны для каждого языка. Таким образом, объясняется важность команды\tex{mainlanguage} в преамбуле документа.

Может случиться так, что \ConTeXt\ не смог правильно расставить слово через дефис. Иногда это может быть связано с тем, что собственные правила разделения слов мешают задаче (например, \ConTeXt\ никогда не разбивает слово на две части, если в этих частях нет минимального количества букв); или потому что слово неоднозначное. В конце концов, что \ConTeXt\ может сделать со словом  \quotation{объединенный в профсоюзы}? Это слово могло появиться во фразе вроде \quotation{объединенная рабочая сила}, но оно также могло появиться в тексте по химии как \quotation{объединенная частица} (т.е. неионизированная). А что, если \ConTeXt\ будет иметь дело со словом \quotation{непредумышленное убийство} в качестве последнего слова на странице перед разрывом страницы. Он может разделить слово как man-slaughter человеко-убийство (правильно), но он также может разделить его как смех человека mans-laughter (двусмысленно).

Какой бы ни была причина, если мы не удовлетворены тем, как слово было разделено, или оно неверно, мы можем изменить его, явно указав потенциальные точки, в которых слово может быть разделено, с помощью управляющего символа \tex{-}. Так, например, если \quotation{unionized} доставляет нам какие-либо проблемы, мы можем записать это в исходный файл как \MyKey{union\backslash-ised}; или если у нас возникла проблема с \quotation{manslaughter}, мы могли бы написать \MyKey{man\backslash-slaughter}.

Если проблемное слово используется в нашем документе несколько раз, то предпочтительнее показать, как оно должно быть расставлено через дефис в нашей преамбуле с помощью команды \PlaceMacro{hyphenation}\tex{hyphenation}: эта команда, которая предназначена для включения в преамбулу исходного файла, занимает одну или несколько слов (через запятую) в качестве аргумента, указывающих точки, в которых они могут быть разделены дефисом. Например:

\type{\hyphenation{union-ised, man-slaughter}}

Если слово, являющееся предметом этой команды, не содержит дефиса, то в результате слово никогда не будет расставлено через дефис. Того же эффекта можно добиться, используя команду \PlaceMacro{hbox}\tex{hbox}, которая создает неделимое горизонтальное поле вокруг слова, или \PlaceMacro{unhyphenated}\tex {unhyphenated}, предотвращающее перенос слова или слов, которые он принимает в качестве аргументов. Но в то время как \tex{hyphenation} действует глобально, \tex{hbox} и \tex{unhyphenated} действуют локально, что означает, что команда \tex{hyphenation} влияет на все вхождения в документ слов, включенных в ее аргумент; в отличие от \tex{hbox} или \tex{unhyphenated}, которые действуют только в том месте исходного файла, где они встречаются.

\startSmallPrint

Внутри системы расстановка переносов контролируется переменными \TeX\ \PlaceMacro{pretolerance}\tex{pretolerance} и \PlaceMacro{tolerance}\tex{tolerance}. Первый из них контролирует допустимость разделения, сделанного только на пустом пространстве. По умолчанию это 100, но если мы изменим его, например, на 10\,000, то \ConTeXt\ всегда будет считать приемлемым наличие разрыва строки, что не означает разделение слов по слогам, что означает, что {\em de facto}, мы убираем расстановку переносов по слогам. Если, например, мы должны установить значение \tex{pretolerance} на -1, мы бы заставили \ConTeXt\ каждый раз использовать перенос слов в конце строки.

Мы можем напрямую установить произвольное значение для \tex{pretolerance}, просто назначив это значение в нашем документе. Например:

  \type{\pretolerance=10000}

но мы также можем управлять этим значением с помощью значений \MyKey{lesshyphenation} и \MyKey{morehyphenation} в \tex{setupalign}. По этому поводу см. \in{section}[sec:setupalign].

\stopSmallPrint

\stopsubsection

\startsubsection
  [
    reference=sec:horizontaltolerance,
    title={Уровень допуска для разрывов строк},
  ]

При поиске возможных точек разрыва строки \ConTeXt\ обычно довольно строг, что означает, что он предпочитает, чтобы слово выходило за пределы правого поля, потому что оно не могло расставить его через дефис, и предпочитает не вставлять разрыв строки перед слово, если это приводит к слишком большому увеличению межсловного пространства в этой строке. Такое поведение по умолчанию обычно обеспечивает оптимальные результаты, и только в исключительных случаях некоторые линии немного выделяются с правой стороны. Идея состоит в том, что автор (или наборщик) просматривает эти исключительные случаи после того, как документ будет закончен, чтобы принять соответствующее решение, которое может быть командой \tex{break} перед словом, выходящим за пределы, или может также означать другую формулировку абзаца, так что что это слово меняет позицию в другом месте.

Однако в некоторых случаях низкая толерантность \ConTeXt\ может быть проблемой. В этих случаях мы можем сказать, что он более терпим с пробелами в строках. Для этого у нас есть команда \PlaceMacro{setuptolerance}\tex{setuptolerance}, позволяющая изменять уровень допуска при вычислении разрывов строк, который \ConTeXt\ вызывает \quotation{horizontal tolerance} (поскольку он влияет на горизонтальное пространство) и quotation{vertical tolerance} при расчете разрывов страниц. Мы поговорим об этом в \in{section}[sec:VerticalAlignment].

Горизонтальная толерантность (которая влияет на разрывы строк) по умолчанию установлена на значение \MyKey{verystrict}. Мы можем изменить это, установив в качестве альтернативы любое из следующих значений: \MyKey{strict}, \MyKey{tolerant}, \MyKey{verytolerant} или \MyKey{stretch}. Так, например,

\type{\setuptolerance[horizontal, verytolerant]}

сделает практически невозможным выход строки за правое поле, даже если это означает установление очень большого и неприглядного интервала между словами в строке.

\stopsubsection

\startsubsection
  [title={Принудительный разрыв строки в определенной точке}]

Чтобы вызвать разрыв строки в определенной точке, мы используем команды \PlaceMacro{break}\tex{break}, \PlaceMacro{crlf}\tex{crlf} или \PlaceMacro{\backslash}{\tt\backslash\backslash}. Первый из них, \tex{break}, вводит разрыв строки в том месте, где он расположен. Это, скорее всего, приведет к эстетической деформации строки, в которой размещена команда, с огромным количеством пробелов между словами в этой строке. Как видно из следующего примера, в котором команда \tex{break} в третьей строке (исходного фрагмента слева) приводит ко второй довольно уродливой строке (в отформатированном тексте справа).

\startDoubleExample

\starttyping
On the corner of the old quarter I saw him \emph{swagger} along like the\break tough guys do when they walk, hands always in their overcoat pockets, so no one can know which of them carries the dagger.
\stoptyping

On the corner of the old quarter I saw him {\em swagger} along like
the\break tough guys do when they walk, hands always in their overcoat
pockets, so no one can know which of them carries the dagger.

\stopDoubleExample

Чтобы избежать этого эффекта, мы можем использовать команды \cmd{\backslash} или \tex{crlf}, которые также вставляют принудительный разрыв строки, но они заполняют исходную строку достаточным количеством пустого места, чтобы выровнять ее по левому краю:

\startDoubleExample

\starttyping
On the corner of the old quarter I saw
him \emph{swagger} along like
the\\ tough guys do when they walk,
hands always in their overcoat pockets,
so no one can know which of them carries
the dagger.
\stoptyping

On the corner of the old quarter I saw him {\em swagger} along like the\\
tough guys do when they walk, hands always in their overcoat pockets, so no
one can know which of them carries the dagger.

\stopDoubleExample

На обычных строках {\em normal}, насколько мне известно, нет различий между  \cmd{\backslash} или \tex{crlf}; но в названии раздела есть разница:

\startitemize

  \item {\tt\bf\backslash\backslash} создает разрыв строки в теле документа, но не тогда, когда заголовок раздела переносится в оглавление.

  \item {\bf\tex{crlf}} создает разрыв строки, который применяется как в теле документа, так и при переносе заголовка раздела в оглавление.

\stopitemize

Разрыв строки не следует путать с разрывом абзаца. Разрыв строки просто завершает текущую строку и начинает следующую строку, но сохраняет нас в том же абзаце, поэтому разделение между исходной строкой и новой строкой будет определяться обычным интервалом внутри абзаца. Следовательно, есть только три сценария, в которых можно рекомендовать принудительный разрыв строки:

\startitemize

  \item В очень исключительных случаях, когда \ConTeXt\ не смог найти подходящий разрыв строки, так что линия выступает справа. В этих случаях (которые возникают очень редко, в основном, когда строка содержит неделимые {\em boxes} или {\em verbatim} текст [см. \in{section}[sec:verbatim]]), может быть полезно принудительно разрыв строки с помощью \tex{break} непосредственно перед словом, которое выступает за правое поле.

  \item  В абзацах, которые фактически состоят из отдельных строк, каждая из которых содержит информацию, не зависящую от информации в предыдущих строках, например, заголовок письма, в котором первая строка может содержать имя отправителя, вторая - получателя и третье свидание; или в тексте, где говорится об авторстве работы, где в одной строке указано имя автора, в другой - его должность или академическая должность и, возможно, в третьей строке указывается дата и т. д. В этих случаях разрыв строки должен быть принудительно выполнен с помощью символа \cmd{\backslash} или \tex{crlf} команд. Параграфы такого типа также часто выравниваются по правому краю.

  \item При написании стихов или подобных текстов для отделения одного стиха от другого. Хотя в последнем случае предпочтительнее использовать среду {\tt lines}, описанную в \in{section}[sec:startlines].

\stopitemize

\stopsubsection

\stopsection

\startsection
  [title=Межстрочный интервал]

Межстрочный интервал - это расстояние, разделяющее строки, составляющие абзац. \ConTeXt\ вычисляет это автоматически на основе фактического используемого шрифта и, прежде всего, на основе базового размера, установленного с помощью \tex{setupbodyfont} или \tex{switchtobodyfont}.

Мы можем влиять на межстрочное пространство с помощью команды \PlaceMacro{setupinterlinespace}\tex{setupinterlinespace}, которая допускает три различных вида синтаксиса:

\startitemize

  \item \tex{setupinterlinespace [..Interline space..]}, где {\em Interline space} это точное значение или символическое слово, которое назначает предварительно определенный межстрочный интервал:

  \startitemize

    \item Если это точное значение, это может быть размер (например, 15pt) или простое, целое или десятичное число (например, 1,2). В последнем случае число интерпретируется как \quotation{количество строк} на основе межстрочного интервала \ConTeXt\ по умолчанию.

    \item Когда это символическое слово, это может быть \MyKey{small}, \MyKey{medium} или \MyKey{big}, каждый из которых применяет малый, средний или большой межстрочный интервал соответственно, всегда на основе межстрочного интервала по умолчанию \ConTeXt\ будет применяться.

  \stopitemize

  \item \tex{setupinterlinespace [..,..=..,..]}. В этом режиме межстрочный интервал устанавливается путем явного изменения базовых показателей, с помощью которых ConTEXt вычисляет соответствующий межстрочный интервал. В этом режиме интервал устанавливается путем явного изменения мер, на основе которых ConTEXt вычисляет соответствующий интервал. Я ранее говорил, что межстрочный интервал рассчитывается на основе конкретного шрифта и его размера; но это было сделано для того, чтобы все было очень просто: на самом деле шрифт и его размер устанавливают определенные меры, на основе которых рассчитывается межстрочное пространство. Посредством этого подхода \tex{setupinterlinespace} эти меры изменяются, а следовательно, и межстрочное пространство. Фактические меры и значения, которыми можно манипулировать с помощью этой процедуры (смысл которых я не буду объяснять, потому что он выходит за рамки простого {\em введения}), следующие: {\tt line, height, depth, minheight, mindepth, distance, top,  bottom, stretch} и {\tt shrink}.

  \item \tex{setupinterlinespace [Name]}.В этом режиме мы устанавливаем или настраиваем особый и индивидуальный тип межстрочного интервала, ранее определенный с помощью \PlaceMacro{defineinterlinespace}\tex{defineinterlinespace}.

\stopitemize

С помощью

\type{\defineinterlinespace [Name] [Configuration]}

мы можем связать определенную конфигурацию межстрочного пространства с определенным именем, которое затем мы можем просто активировать в какой-то момент нашего документа с помощью \tex{setupinterlinespace[Name]}. Чтобы вернуться к нормальному межстрочному пространству, нам нужно будет написать \tex{setupinterlinespace[reset]}.

\stopsection

\startsection
  [title={Прочие вопросы, касающиеся строк}]

\startsubsection
  [
    reference=sec:startlines,
    title={Преобразование разрывов строк в исходном файле в разрывы строк в окончательном документе},
  ]

Как мы уже знаем (см. \in{section}[sec:linebreaks]), по умолчанию \ConTeXt\ игнорирует разрывы строк в исходном файле, которые он считает простыми пробелами, если нет двух или более последовательных разрывов строки, и в этом случае разрыв абзаца будет вставлен. Тем не менее, могут быть некоторые ситуации, в которых мы заинтересованы в соблюдении разрывов строк в исходном исходном файле, как они были помещены там, например, при написании стихов. Для этого \ConTeXt\ предлагает нам среду \MyKey{lines}, формат которой:

\PlaceMacro{startlines}\type{\startlines [Options] ... \stoplines}

где варианты могут быть, среди прочего, любыми из следующих:

\startitemize

  \item {\tt\bf space}: пробел: если для этого параметра установлено значение «включено» \MyKey{on}, в дополнение к соблюдению разрывов строк в исходном файле среда также будет учитывать пробелы в исходном файле, временно игнорируя правило поглощения.

  \item {\tt\bf before}:текст или команда для запуска перед входом в среду.

  \item {\tt\bf after}: Текст или команда для запуска после выхода из среды.

  \item {\tt\bf inbetween}: Текст или команда для запуска при входе в среду.

  \item {\tt\bf indenting}: Значение, указывающее, следует ли делать отступ абзацев в среде (см. \in{section}[sec:indentation]).

  \item {\tt\bf align}: Выравнивание линий в окружении (см. \in{section}[sec:alignment]).

  \item {\tt\bf style}: Команда стиля для применения в среде.

  \item {\tt\bf color}: Цвет для применения в среде.

\stopitemize

Так, например,

\startDoubleExample
\starttyping
  \startlines
    One-one was a race horse.
    Two-two was one too.
    One-one won one race.
    Two-two won one too.
  \stoplines
\stoptyping

  \startlines
    One-one was a race horse.
    Two-two was one too.
    One-one won one race.
    Two-two won one too.
  \stoplines
\stopDoubleExample

Мы также можем изменить способ работы среды по умолчанию с помощью \PlaceMacro{setuplines}\tex{setuplines} и, как и в случае со многими другими командами \ConTeXt, также можно присвоить имя определенной конфигурации этой среды. Мы делаем это с помощью команды \PlaceMacro{definelines}\tex{definelines}, синтаксис которой:

\type{\definelines [Name] [Configuration]}

где в качестве конфигурации мы можем включить те же параметры, которые были объяснены в целом для среды. После того, как мы определили нашу настроенную линейную среду, чтобы вставить ее, мы должны написать:

\type{\startlines[Name] ... \stoplines}

\stopsubsection

\startsubsection
  [
    reference=sec:linenumbering,
    title={Нумерация строк},
  ]

В некоторых типах текстов принято устанавливать некоторую нумерацию строк, например, в текстах по компьютерному программированию, где относительно часто фрагменты кода, предлагаемые в качестве примеров, имеют пронумерованные строки, или в стихах, критических редакциях и т.д. Для всех этих ситуаций \ConTeXt\ предлагает среду нумерации строк {\tt linenumbering}, формат которой

\PlaceMacro{startlinenumbering}\type{\startlinenumbering [Options] ... \stoplinenumbering}

Доступные варианты опций:

\startitemize

  \item {\tt\bf continue}: в случаях, когда несколько частей нашего документа требуют нумерации строк, эта опция видит, что нумерация возобновляется для каждой части (\MyKey{continue=no}, значение по умолчанию). С другой стороны, если нумерация строк предназначена для продолжения с того места, где была остановлена предыдущая часть, мы выбираем \MyKey{continue=yes}.

  \item {\tt\bf start}: указывает номер первой строки в тех случаях, когда мы не хотим, чтобы она была \quote{1} или чтобы она соответствовала предыдущему перечислению.

  \item {\tt\bf step}: все строки, включенные в среду, будут пронумерованы, но с помощью этой опции мы можем указать, что номер печатается только через определенные промежутки времени. В стихах, например, часто встречается, что число появляется только кратно 5 (стихи 5, 10, 15 ...).

\stopitemize

Все эти параметры могут быть указаны, как правило, для всех сред {\em lnumbering} в нашем документе с помощью \PlaceMacro{setuplinenumbering}\tex{setuplinenumbering}. Эта команда также позволяет нам настроить другие аспекты нумерации строк:

\startitemize

  \item {\tt\bf conversion}: Тип нумерации строк. Это может быть любой из описанных на \at{page}[Num:conversion] относительно нумерации глав и разделов.

  \item {\tt\bf style}: Команда (или команды), определяющая стиль нумерации строк (шрифт, размер, вариант ...).

  \item {\tt\bf color}: Цвет, которым будет напечатан номер строки.

  \item {\tt\bf location}:Где будет размещен номер строки. Это может быть любое из следующих значений: text, begin, end, default, left, right, inner,
  outer, inleft, inright, margin, inmargin.

  \item {\tt\bf distance}:  Расстояние между номером строки и самой строкой.

  \item {\tt\bf align}: Выравнивание номеров. Может быть: inner, outer, flushleft, flushright, left, right, middle or auto.

  \item {\tt\bf command}: Команда, которой перед печатью будет передан номер строки в качестве параметра.

  \item {\tt\bf width}: Ширина, зарезервированная для печати номера строки.

  \item {\tt\bf left, right, margin}:

\stopitemize

Мы также можем создавать различные настраиваемые конфигурации нумерации строк с помощью \PlaceMacro{definelinenumbering}\tex{definelinenumbering}, чтобы конфигурация была связана с именем:

\type{\definelinenumbering [Name] [Configuration]}

После того, как конкретная конфигурация была определена и связана с именем, мы можем использовать ее с

\type{\startlinenumbering [Name] ... \stoplinenumbering}

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:alignment,
    title={Горизонтальное и вертикальное выравнивание},
  ]

Командой, которая обычно управляет выравниванием текста, является \PlaceMacro{setupalign}\cmd{set\-up\-align}. Эта команда используется для управления как горизонтальным, так и вертикальным выравниванием.

\startsubsection
  [
    reference=sec:setupalign,
    title={Горизонтальное выравнивание},
  ]

Когда точная ширина строки текста не занимает всю возможную ширину, возникает проблема: что делать с результирующим пустым пространством. \footnote{Под {\em точной} шириной я подразумеваю ширину строки {\em до того}, как \ConTeXt\ настроит размер междусловного пространства для обеспечения выравнивания.} В этом отношении мы можем сделать три вещи:

\startitemize[n]

  \item Накапливайте пространство на одной из двух сторон линии: если мы накапливаем его на левой стороне, линия будет выглядеть немного сдвинутой {\em a little pushed} вправо, в то время как если мы накапливаем её на правой стороне, линия останется на левой стороне. В первом случае мы говорим о выравнивании по правому краю {\em right alignment}, а во втором - о выравнивании по левому краю {\em left alignment}. По умолчанию \ConTeXt\ применяет выравнивание по левому краю к последней строке абзацев.

Когда несколько последовательных линий выровнены слева, правая сторона нерегулярна; но когда выравнивание происходит справа, неровная сторона оказывается левой. Чтобы назвать параметры, которые выравнивают ту или иную сторону, \ConTeXt\ задает не сторону, где они выровнены, а сторону, где они неровные. Следовательно, опция {\tt flushright} приводит к выравниванию по левому краю, а {\tt flushleft} - к выравниванию по правому краю. В качестве сокращений от {\tt flushright} и {\tt flushleft} \tex {setupalign} также поддерживает значения {\tt right} и {\tt left}. Но {\bf внимание}: здесь значение слов обманчиво. Хотя {\em left} означает \quotation{left}, а {\em right} означает \quotation{right}, \tex{setupalign[left]} выравнивается по правому краю, а \tex{setupalign[right]} выравнивается по левый. Если читатель задается вопросом, почему был сделан этот комментарий, стоит процитировать \ConTeXt\ wiki: \quote{\ConTeXt\ использует опции flushleft и flushright. Правое и левое выравнивание происходит в обратном направлении от обычных направлений во всех командах, которые допускают вариант выравнивания, в смысле \quote{ragged left} и \quote{ragged right}. К сожалению, когда Ганс впервые писал эту часть \ConTeXt, он думал о выравнивании \quote{ragged right} и \quote{ragged left}, а не о \quote {flush left} и \quote{flush right}. И теперь, когда так было некоторое время, изменить его невозможно, потому что его изменение нарушит обратную совместимость со всеми существующими документами, которые его используют.}

В документах, подготовленных для двусторонней печати, помимо правого и левого полей есть также внутренние и внешние поля. Значения {\tt flushinner} (или просто {\tt inner}) и {\tt flushouter} (или просто {\tt outer}) устанавливают соответствующее выравнивание в этих случаях. 


  \item Распределите его по обоим полям. В результате линия будет отцентрирована. Параметр \tex{setupalign}, который делает это, -- {\tt middle}.


  \item Распределите его между всеми словами,составляющими строку, при необходимости увеличив межсловное пространство, чтобы строка стала точно такой же ширины, как и доступное для нее пространство. В этих случаях мы говорим об обоснованных линиях. Это также значение \ConTeXt\ по умолчанию, поэтому в \tex{setupalign} нет специальной опции для его установки. Однако, если мы изменили выравнивание по умолчанию, мы можем восстановить его с помощью  \tex{setupalign[reset]}.

\stopitemize

начение для параметра \tex{setupalign}, которое мы только что видели ({\tt right, flushright, left, flushleft, inner, flushinner, outer, flushouter} и {\tt middle}), может быть объединено с {\tt broad} (широким), что приведёт к несколько более грубому выравниванию.


\startSmallPrint

Два других возможных значения \tex{setupalign}, которые влияют на выравнивание по горизонтали, связаны с переносом слов в конце строки, потому что, будет ли это сделано или нет, зависит от того, будет ли точная мера строки больше или меньше; что, в свою очередь, влияет на оставшееся пустое пространство
  
Для этого \tex{setupalign} позволяет использовать большее значение расстановки переносов {\tt morehyphenation}, что заставляет \ConTeXt\ труднее находить точки останова на основе расстановки переносов, и меньше расстановки переносов {\tt lesshyphenation}, что дает противоположный эффект. При использовании \tex{setupalign[horizontal, morehyphenation]} оставшееся свободное пространство в строках будет уменьшено, и поэтому выравнивание будет менее заметным. Напротив, при \tex{setupalign[horizontal,lesshyphenation]}останется больше пустого пространства, и выравнивание будет более заметным.

\stopSmallPrint

\tex{setupalign}предназначен для включения в преамбулу и влияет на весь документ или для включения в определенный момент и влияет на все от этого момента до конца. Если мы хотим изменить выравнивание только одной или нескольких строк, мы можем использовать:

\startitemize

  \item Среда \MyKey{alignment}, предназначенная для воздействия на несколько строк. Имеет общий формат:

  \PlaceMacro{startalignment}\type{\startalignment [Options] ... \stopalignment}

  где {\em Options} любые из допустимых для \tex{setupalign}.

  \item Команды \PlaceMacro{leftaligned}\tex{leftaligned}, \PlaceMacro{midaligned}\tex{midaligned} или  \PlaceMacro{rightaligned}\tex{rightaligned} которые вызывают выравнивание по левому, центру или правому краю соответственно; и если мы хотим, чтобы последнее слово в абзаце (но только это, а не остальная часть строки) было выровнено по правому краю, мы можем использовать \PlaceMacro{wordright}\tex{wordright}. Все эти команды требуют, чтобы текст был заключен в фигурные скобки.

  \startSmallPrint

С другой стороны, обратите внимание, что если слова \MyKey{right} и \MyKey{left} в \tex{setupalign} вызывают выравнивание, противоположное тому, что предлагает название, то же самое не происходит с командами tex{leftaligned} и \tex{rightaligned}, которые вызывают именно тот вид выравнивания, который предлагает их название: {\tt left} налево и {\tt right} направа.

  \stopSmallPrint

\stopitemize

\stopsubsection

\startsubsection
  [
    reference={sec:VerticalAlignment},
    title={Вертикальное выравнивание},
  ]

Если горизонтальное выравнивание вступает в игру, когда ширина строки не занимает все доступное для нее пространство, вертикальное выравнивание влияет на высоту всей страницы: если точная {\em exact} высота текста страницы не занимает всю высоту, доступную для это, что нам делать с оставшимся пустым пространством? Мы можем сложить его вверху (\MyKey{height}), что означает, что текст на странице будет сдвинут вниз; мы можем сложить его внизу (\MyKey{bottom}) или распределить по абзацам(\MyKey{line}). Значение по умолчанию для вертикального выравнивания -- \MyKey{bottom}.

\subsubsubject{Вертикальный уровень допуска}

Таким же образом мы можем изменить уровень допуска \ConTeXt\ в отношении количества горизонтального пространства, допустимого в строке (горизонтальный допуск) с помощью \PlaceMacro{setuptolerance}\tex{setuptolerance}, мы также можем изменить его вертикальный допуск, то есть допуск на расстояние между абзацами больше, чем у \ConTeXt, по умолчанию считается разумным для хорошо набранной страницы. Возможные значения для вертикального допуска такие же, как и для горизонтального допуска: {\tt verystrict, strict, tolerant} and {\tt verytolerant}. Значение по умолчанию -- \tex{setuptolerance [vertical, strict]}.

\subsubsubject{Контроль над вдовами и сиротами (widows and orphans)}

Одним из аспектов, косвенно влияющих на вертикальное выравнивание, является контроль над вдовами и сиротами. Оба явления означают, что разрыв страницы приводит к тому, что одна строка абзаца оказывается изолированной на другой странице от остальной части абзаца. Это не считается типографически подходящим. Если строка, которая отделена от остального абзаца, является первой на странице, мы говорим о вдове {\em widowed line}; если строка, отделенная от абзаца, является последней на странице, то речь идет о потерянной строке {\em orphaned line}.

По умолчанию \ConTeXt\ не реализует элемент управления, гарантирующий, что эти строки не появятся. Но мы можем изменить это, изменив некоторые внутренние переменные \ConTeXt: \PlaceMacro{widowpenalty}\tex{widowpenalty} контролирует овдовевшие строки, а \PlaceMacro{clubpenalty}\tex{clubpenalty} контролирует потерянные строки. Таким образом, следующие положения в преамбуле к нашему документу обеспечат выполнение этого контроля:

\starttyping
\widowpenalty=10000
\clubpenalty=10000
\stoptyping

Выполнение этого элемента управления означает, что \ConTeXt\ не будет вставлять разрыв страницы, который отделяет первую или последнюю строку абзаца от страницы, на которой находится остальная часть. Это избегание будет более или менее строгим в зависимости от значения, которое мы присваиваем переменным. При значении 10 000, таком как в примере, управление будет абсолютным; со значением, например, 150, элемент управления будет не быть таким строгим, и иногда могут быть некоторые овдовевшие или осиротевшие строки, когда альтернатива хуже в типографских терминах.

\stopsubsection

\stopsection

\stopchapter

\stopcomponent

%%% Local Variables:
%%% mode: ConTeXt
%%% mode: auto-fill
%%% coding: utf-8-unix
%%% TeX-master: "../introCTX.mkiv"
%%% End:
%%% vim:set filetype=context tw=75 : %%%