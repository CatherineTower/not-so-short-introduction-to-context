%%% File:      b12_SpecialParas.mkiv
%%% Author:    Joaquín Ataz-López
%%% Begun:     July 2020
%%% Concluded: August 2020
%%% Contents:  Эта глава - большая последняя мешанина. Всё, что не могло быть четко расположено в другом месте, находится здесь. Я определился с окончательной структурой, когда писал эту главу, поскольку, когда начал работать с определенным материалом, я осознал, что его можно разместить в другом месте.
%%%
%%% Edited: Emacs + AuTeX - And at times vim + context-plugin
%%%

\environment ../introCTX_env.mkiv

\startcomponent b12_SpecialParas.mkiv

\startchapter
  [title={Специальные конструкции и абзацы}]

\TocChap

\startsection
  [title={Сноски и концевые примечания}]

Примечания - это \quotation{второстепенные текстовые элементы, используемые для различных целей, таких как разъяснение или расширение основного текста, предоставление библиографической ссылки на источники, включая цитаты, ссылки на другие документы или изложение значения текста}[{\em Libro de Estilo de la Lengua española} (Spanish Language Style Guide), p. 195].  Они особенно важны в текстах академического характера. Их можно разместить в разных местах на странице или в документе. Сегодня наиболее распространены те, которые расположены в конце страницы (поэтому они называются сносками); иногда они также располагаются на одном из полей (примечания на полях), в конце каждой главы или раздела или в конце документа (примечания). В особо сложных документах также могут быть разные серии примечаний: примечания автора, примечания переводчика, обновления и т.д. В частности, в критических редакциях аппарат заметок может стать довольно сложным, и лишь несколько систем набора могут его поддерживать. \ConTeXt\ -- одно из них. Для создания и настройки различных типов заметок доступно множество команд.

Чтобы объяснить это, полезно начать с указания различных элементов, которые могут быть включены в заметку:

\startitemize

\item {\em Mark} или {\em anchor} заметки: знак, помещаемый в тексте, чтобы указать, что с ним связана заметка. Не все типы примечаний имеют привязку {\em anchor}, связанную с ними, но когда она есть, эта привязка {\em anchor} появляется в двух местах: в той точке основного текста, к которой относится примечание, и в начале самого текста примечания. Наличие одинаковой отметки в обоих местах позволяет связать заметку с основным текстом.

\item {\em ID или идентификатор} заметки: буква, цифра или символ, который идентифицирует заметку и отличает её от других заметок. У некоторых заметок, например заметок на полях, может отсутствовать идентификатор. Когда это не так, идентификатор обычно совпадает с привязкой {\em anchor}.

  \startSmallPrint

Если мы будем думать исключительно о сносках, то не увидим разницы между тем, что я только что назвал ссылкой {\em reference mark}, и идентификатором {\em id}. Мы ясно видим разницу в других типах заметок: например, у линейных заметок есть id, но нет ссылки (reference mark).

  \stopSmallPrint

\item {\em Text} or {\em содержимое} заметки, всегда расположенные в другом месте на странице или в документе, чем команда, которая создает заметку и указывает её содержимое.

\item {\em Label}  Ярлык, связанный с примечанием, которое не отображается в окончательном документе, но позволяет нам обратиться к нему и получить его идентификатор в другом месте документа.

\stopitemize

\startsubsection
  [title=Типы заметок в \ConTeXt\ и связанные с ними команды]

В \ConTeXt\ есть различные типы заметок. На данный момент я лишь перечислю, описав их в общих чертах и предоставив информацию о командах, которые их генерируют. Позже я разовью первые две:

\startitemize

\item {\bf Сноски:} несомненно, самые популярные, поскольку для всех типов заметок принято называть сноски {\em footnotes}. Сноски представляют собой метку {\em mark} с идентификатором {\em id} заметки в том месте документа, где находится команда, и вставляют текст самой заметки в нижней части страницы, где появляется метка. Они создаются с помощью команды \tex{footnote}.

\item {\bf Endnotes:} Эти примечания, которые создаются с помощью команды \tex{endnote}, вставляются в то место в документе, где обнаружена отметка с идентификатором примечания; но содержимое заметки вставляется в другую точку документа, и вставка производится другой командой (\tex{placenotes}).

\item {\bf Margin notes:} Как следует из их названия, они написаны на полях текста, и в теле документа нет идентификатора или автоматически сгенерированной метки или привязки. Две основные команды (но не единственные), которые их создают, - это \tex{inmargin} и \tex{margintext}.

\item {\bf Line notes:} Тип примечания, типичный для сред, в которых строки нумеруются, например, в случае \tex{startlinenumbering ... \stoplinenumbering} (см. \in{section}[sec:linenumbering]). Примечание, которое обычно пишется внизу, относится к определенному номеру строки. Они создаются с помощью команды \PlaceMacro{lnenote}\tex{lnenote}, которая настраивается с помощью \PlaceMacro{setuplinenote}\tex{setuplinenote}. Эта команда не печатает {\em mark} в теле текста, но в самом примечании печатает номер строки, на которую ссылается примечание (используется как {\em ID}).

\stopitemize

Сейчас я буду развивать только первые два типа заметок:

\startitemize

\item Примечания на полях рассматриваются в другом месте (\in{section}[sec:margintext]).

\item Строчные заметки имеют узкоспециализированное использование (особенно в критических редакциях), и я считаю, что во вводном документе, подобном этому, читателю достаточно знать, что они существуют.

  \startSmallPrint

Тем не менее, для заинтересованного читателя я рекомендую видео (на испанском) с текстом (также на испанском) о критических редакциях в \ConTeXt, автором которых является Пабло Родригес. Он доступен по адресу \goto{эта ссылка}[url (http://www.ediciones-criticas.tk/)]. Это также очень полезно для понимания некоторых общих настроек заметок в целом.

  \stopSmallPrint

\stopitemize

\stopsubsection

\startsubsection
  [title=Внимательный взгляд на сноски и концевые сноски]
  \PlaceMacro{footnote}\PlaceMacro{endnote}

Синтаксис команд сносок и концевых сносок, а также имеющиеся у них механизмы конфигурации и настройки весьма схожи, поскольку на самом деле оба типа примечаний являются частными экземплярами более общей конструкции (заметок), другие экземпляры которой могут быть установлены с помощью команды \tex{Definenote}(см. \in{section}[sec:definenote]).

Синтаксис команды, создающей каждый из этих видов заметок, следующий:

\starttyping
\footnote[Label]{Text}
\endnote[Label]{Text}
\stoptyping

где

\startitemize

\item {\em Label} необязательный аргумент, который присваивает заметке метку, которая позволит нам ссылаться на неё в другом месте документа.

\item {\em Text} это содержание заметки. Он может быть сколь угодно длинным и включать в себя специальные абзацы и настройки, хотя следует отметить, что когда дело доходит до сносок, правильный макет страницы довольно затруднен в документах с обильными и чрезмерно длинными примечаниями.

  \startSmallPrint

В принципе, в тексте заметки можно использовать любую команду, которую можно использовать в основном тексте. Однако мне удалось убедиться, что определенные конструкции и символы, которые не создают никаких проблем в основном тексте, действительно вызывают ошибку компиляции, когда они встречаются в тексте заметки. Эти случаи я обнаружил во время тестирования, но никак не организовал их.

  \stopSmallPrint

\stopitemize

Когда аргумент {\em Label} использовался для установки метки для заметки, команда \PlaceMacro{note}\tex{note} позволяет нам получить идентификатор рассматриваемой заметки. Эта команда печатает ID заметки, связанной с этикеткой, которую она принимает в качестве аргумента в документе. Так, например:

\startDoubleExample
\switchtobodyfont[small]
\setupnotation[footnote][width=-1cm]
\vbox{\starttyping
Humpty Dumpty\footnote[humpty]{Probably the
best-known English nursery rhyme character}
sat on a wall, Humpty Dumpty\note[humpty]
had a great fall.\\
All the king's horses and
all the king's men Couldn't put
Humpty\note[humpty] together again
\stoptyping}

Humpty Dumpty\footnote[humpty]{Probably the best-known English nursery
rhyme character} sat on a wall,\\ Humpty Dumpty\note[humpty] had a great
fall.\\
All the king's horses and all the king's men\\
Couldn't put Humpty\note[humpty] together again

\stopDoubleExample

Основное различие между \tex{footnote}  и \tex{endnote} - это место, где появляется примечание:

\startdescription{\tex{footnote}}

Как правило, он печатает текст заметки внизу страницы, на которой расположена команда, так что появится метка заметки и её текст (или начало текста, если он должен быть растянут на две страницы) на той же странице. Для этого \ConTeXt\ внесёт необходимые корректировки при вёрстке страницы, вычислив пространство, необходимое для расположения заметки внизу страницы.

\startSmallPrint

Но в некоторых средах \tex{footnote} вставляет текст примечания не внизу самой страницы, а под средой. Это имеет место, например, в таблицах или в среде {\tt columns}. В этих случаях, если мы хотим, чтобы примечания внутри среды располагались внизу страницы, вместо \tex{footnote} мы должны использовать команду \tex{footnotetext} в сочетании с командой \tex{note}, упомянутый выше. Первый, который также поддерживает метку в качестве необязательного аргумента, печатает только текст примечания, но не метку. Но поскольку \tex{note} печатает только метку без текста, их комбинация позволяет нам разместить заметку в том месте, где мы хотим. Так, например, мы могли бы написать \tex{note [MyLabel]} в таблице или среде с несколькими столбцами, а затем, выйдя из этой среды, \type{\footnotetext[MyLabel]{Note text}}.

Другой пример использования \tex{footnotext} в сочетании с \tex{note} - это примечания внутри других примечаний. Например:

\startDoubleExample
%\switchtobodyfont[small]
\setupnotation[footnote][width=-1cm]
\starttyping
This%
\footnote{or this\note[noteB], if you prefer.}%
\footnotetext[noteB]
{or possibly even this one\note[noteC].}
\footnotetext[noteC]{could be something
entirely different.}
is a sentence with nested notes.
\stoptyping

This%
\footnote{or this\note[noteB], if you prefer.}%
\footnotetext[noteB]{or possibly even this\note[noteC].}\footnotetext[noteC]{could be something
entirely different.}
is a sentence with nested notes.

\stopDoubleExample

\stopSmallPrint

\stopdescription

\startdescription{\tex{endnote}}

печатает привязку заметки только в той точке исходного файла, где она расположена. Фактическое содержание заметки вставляется в другую точку документа с помощью другой команды (\PlaceMacro{placenotes}\tex{placenotes[endnote]}), которая в том месте, где она расположена, вставляет содержимое {\em all} концевой сноски документа (или рассматриваемой главы или раздела).

\stopdescription

\stopsubsection

\startsubsection
  [
    reference=sec:localfootnotes,
    title={Местные заметки},
  ]
  \PlaceMacro{startlocalfootnotes}\PlaceMacro{placelocalfootnotes}

Среда \tex{startlocalfootnotes} означает, что включенные в нее сноски считаются {\em local} примечаниями, а это означает, что их нумерация будет сброшена и содержимое примечаний не будет автоматически вставлено вместе с остальной частью заметки, но только в том месте документа, где найдена команда \tex{placelocalfootnotes}, которая может находиться или не находиться в среде.

\stopsubsection

\startsubsection
  [
    reference=sec:definenote,
    title={Создание и использование настраиваемых типов заметок},
  ]
  \PlaceMacro{definenote}

Мы можем создавать заметки особых типов с помощью команды \tex{Definenote}. Это может быть полезно в сложных документах, где есть примечания от разных авторов, или для разных целей, чтобы графически различать каждый из типов примечаний в нашем документе с помощью разного формата и другой нумерации.

Синтаксис \tex{Definenote} следующий:

\type{\definenote[Name][Model][Configuration]}

где

\startitemize

\item {\em Name} это имя, которое мы присваиваем нашему новому типу заметок.

\item {\em Model} это модель примечания, которая будет использоваться изначально. Это может быть {\tt footnote} или {\tt endnote}; в первом случае наша модель заметок будет работать как сноски, а во втором случае как концевые сноски, хотя для вставки их в документ мы бы не использовали \PlaceMacro{placenotes}\tex{placenotes[endnote]}, но \tex{placenotes[Name]} (имя, которое мы присвоили этим видам заметок).

  \startSmallPrint

Теоретически этот аргумент является необязательным, хотя в моих тестах некоторые заметки, созданные без него, не были видны, и у меня не хватило терпения выяснить, в чём причина.

  \stopSmallPrint

\item {\em Configuration} - необязательный второй аргумент, который позволяет нам отличать наш новый тип заметок от его модели: либо путём установки другого формата, либо другого типа нумерации, либо и того, и другого.

  \startSmallPrint

Согласно официальному списку команд \ConTeXt\ (см. \in{section}[sec:qrc-setup-en]) настройки, которые могут быть предоставлены при создании заметки нового типа, основаны на тех, которые могут быть предоставлены позже с помощью \tex{setupnote}. Однако, как мы вскоре увидим, на самом деле есть две возможные команды для настройки заметок: \tex{setupnote} и \cmd{setupnotation}. Поэтому я думаю, что предпочтительнее опустить этот аргумент при создании типа заметки, а затем настроить наши новые заметки с помощью соответствующих команд. По крайней мере, это легче объяснить.

  \stopSmallPrint

\stopitemize

Например, следующий элемент создаст новый тип заметки под названием \quote{BlueNote}, который будет похож на сноски, но его содержимое будет напечатано жирным шрифтом и синим цветом:

\starttyping
\definenote  [BlueNote] [footnote]
\setupnotation
  [BlueNote]
  [color=blue, style=bf]
\stoptyping

После того, как мы создали новый тип заметки, например {\em BlueNote} команда, позволяющая нам использовать его, будет доступна. В нашем примере это будет \tex{BlueNote}, синтаксис которого будет похож на \tex{footnote}:

\type{\BlueNote[Label]{Text}}

\stopsubsection

\startsubsection
  [title=Настройка примечаний]
  \PlaceMacro{setupnote}\PlaceMacro{setupnotation}

Настройка примечаний (сноски или концевые сноски, примечания, созданные с помощью \tex{Definenote}, а также строчные примечания, созданные с помощью \tex{lnenote}), достигается двумя командами: \tex{setupnote} и \tex{setupnotation}\footnote{\tex{setupnote} имеет 35 параметров конфигурации {\em direct} и 45 дополнительных параметров, унаследованных от \\ \tex{setupframed}; \tex{setupnotation} имеет 45 параметров прямой конфигурации и ещё 23, унаследованных от \PlaceMacro{setupcounter}\tex{setupcounter}. Поскольку эти параметры не задокументированы, и, хотя для многих из них мы можем определить их полезность по их названию, нам необходимо проверить, верна наша интуиция или нет; а также принимая во внимание, что многие из этих опций допускают ряд значений, и все они должны быть протестированы ... Вы увидите, что для того, чтобы написать это объяснение, мне пришлось провести довольно много тестов; и хотя сделать тест быстро, делать множество тестов медленно и скучно. Поэтому я надеюсь, что читатель простит меня, если я скажу вам, что помимо двух общих команд настройки для заметок, которые я упоминаю в основном тексте и на которых я сосредоточусь в следующем объяснении, я оставлю еще четыре потенциальных возможности настройки в объяснение:

  \startitemize

  \item \PlaceMacro{setupnotes}\tex{setupnotes} и \PlaceMacro{setupnotations}\tex{setupnotations}: Другими словами, то же имя, но во множественном числе. В вики говорится, что версия команды в единственном и множественном числе синонимичны, и я этому верю.

  \item \PlaceMacro{setupfootnotes}\tex{setupfootnotes} и \PlaceMacro{setupendnotes}\tex{setupendnotes}: Мы предполагаем, что это конкретные приложения для сносок и концевых сносок соответственно. Возможно, объяснить конфигурацию заметок на основе этих команд было бы проще, поскольку я не смог заставить работать первый вариант ({\tt numberconversion}), который я пробовал с \tex{setupfootnotes}, хотя я знаю, что другие параметры из этих команд действительно работают ... Мне было лень добавлять тесты, необходимые для включения этих двух команд, в объяснение многих тестов, которые мне уже пришлось сделать, чтобы написать то, что следует. \blank[small]

Но я придерживаюсь мнения (исходя из нескольких выполненных мной случайных тестов), что всё, что работает в этих двух командах, но чьё объяснение я опускаю, также работает в командах, для которых я даю пояснения.

  \stopitemize
}.  Синтаксис для обоих похож:

\starttyping
\setupnote[NoteType][Configuration]
\setupnotation[NoteType][Configuration]
\stoptyping

где {\em NoteType} относится к типу заметки, которую мы настраиваем ({\tt footnote}, {\tt endnote} или имя некоторого типа заметки, который мы сами создали), а {\em configuration} содержит конкретную конфигурацию параметров команды.

Проблема в том, что названия этих двух команд не очень ясно показывают, в чем разница между ними или что каждая настраивает; и тот факт, что многие параметры этих команд не задокументированы, также не сильно помогает. После долгого тестирования я не смог прийти к какому-либо выводу, который позволил бы мне понять, почему одни вещи настроены с одним, а другие с другим, \footnote{Есть страница в \goto{ \ConTeXt\ wiki} [url(https://wiki.contextgarden.net/Unexpected\_behavior)], которую я обнаружил случайно (поскольку он не предназначен специально для заметок), что говорит о том, что разница в том, что \tex{setupnotation} управляет текстом вставляемой заметки и \tex{setupnote} средой заметки, в которой она будет помещена (?). Но это несовместимо с тем фактом, что, например, ширина текста заметки (которая имеет отношение к его {\em вставке}) управляется параметром {\tt width} в \tex{setupnote}, а не параметром \tex{setupnotation} с тем же именем. Здесь контролируется ширина промежутка между меткой и текстом заметки.} За исключением того, что, возможно, из-за того, что я сделал выбор, чтобы заставить её работать, \tex{setupnotation} всегда влияет на текст заметки или идентификатор, который печатается с текстом примечания, а в \tex{setupnote} есть некоторые параметры, которые влияют на отметку для примечания, вставленного в основной текст.

Теперь я попытаюсь упорядочить то, что я узнал после проведения некоторых тестов с различными вариантами обеих команд. Я оставляю большинство вариантов для обоих в стороне, поскольку они не задокументированы, и я не смог сделать никаких выводов относительно того, для чего они предназначены или при каких условиях их следует использовать:

\startitemize

\starthead {\bf ID используемый для отметки:} Примечания всегда обозначаются номером. Здесь мы можем настроить: \stophead

  \startitemize

  \item {\em Первая цифра}: контролируется {\tt start} в \tex{setupnotation}.  Значение должно быть целым числом, и оно используется для начала подсчета заметок.

  \item {\em Система нумерации} Система нумерации, которая зависит от {\tt numberconversion} опции для \tex{setupnotation}. Значениями могут быть:

  \startitemize[packed]

  \item {\em A Арабские цифры}: {\tt n, N} или {\tt numbers}.

  \item {\em Римские цифры}: {\tt I, R, Romannumerals, i, r, romannumerals}. Первые три - это римские цифры в верхнем регистре, а последние три - в нижнем регистре.

  \item {\em Нумерация буквами}: {\tt A, Character, Characters, a, character, characters}в зависимости от того, хотим ли мы, чтобы буквы были в верхнем регистре (первые три опции) или в нижнем регистре (остальные).

  \item {\em Нумерация словами}. Другими словами, мы пишем слово, обозначающее число, и, например, \quote{3} становится \quote{three}. Возможны два метода. Параметр {\tt Words} записывает слова в верхнем регистре, а {\tt words} в нижнем регистре.

  \item {\em Нумерация символами.}: мы можем использовать четыре различных набора символов в зависимости от выбранной опции: {\tt set~0, set~1, set~2} или {\tt set~3}. На \at{page}[examples of conversion set] есть пример символов, используемых в каждой из этих опций.
  
  \stopitemize

\item {\em Событие, определяющее перезапуск нумерации заметок}: Это зависит от параметра {\tt way} в \tex{setupnotation}. Если значение равно {\tt bytext}, все примечания в документе будут пронумерованы последовательно без сброса нумерации. Когда это {\tt bychapter, bysection, bysubsection и т.д.}, Счетчик заметок будет сбрасываться каждый раз при изменении главы, раздела или подраздела, а когда это {\tt byblock}, он сбрасывает нумерацию каждый раз, когда мы меняем блоки в макроструктуре документа (см. \in{section}[sec:macrostructure]). Значение {\tt bypage} заставляет счетчик заметок перезапускаться при каждом изменении страницы.

  \stopitemize

\starthead {\bf Настройка метки примечания:} \stophead

  \startitemize

  \item Показывать это или нет: {\tt number} опция для \tex{setupnotation}.

  \item Размещение метки по отношению к тексту примечания: опция {\tt alternative} в \tex{setupnotation}: может принимать любое из следующих значений: {\tt left, inleft, leftmargin, right, inright, rightmargin, inmargin, margin, innermargin, outermargin, serried, hanging, top, command}.

  \item Формат маркировки в самой заметке: опция {\tt numbercommand} в \tex{setupnotation}.

  \item Формат маркировки в теле текста: опция {\tt textcommand} в \tex{setupnote}.

    \startSmallPrint

      Опции {\tt numbercommand} and {\tt textcommand} должны состоять из команды, которая принимает содержимое метки в качестве аргумента. Это может быть самоопределенная команда. Однако я обнаружил, что простые команды форматирования (\tex{bf}, \tex{it} и т.д.) работают, хотя они не являются командами, которые должны принимать аргумент.

\stopSmallPrint

  \item Расстояние между меткой и текстом (в самой заметке): параметры {\tt distance} и {\tt width} в \tex{setupnotation}. Мне не удалось обнаружить разницу (если она действительно есть) между использованием того или иного варианта.

  \item Наличие или отсутствие гиперссылки, позволяющей переходить между отметкой в основном тексте и отметкой в самой заметке: Опция {\tt interaction} в \tex{setupnote}. При {\tt yes} в качестве значения будет ссылка, а при {\tt no} не будет.

  \stopitemize

\starthead {\bf Настройка самого текста заметки.} \stophead

  Мы можем влиять на следующие аспекты:

  \startitemize

  \item Размещение: зависит от опции {\tt location} в \tex{setupnote}.

    \startSmallPrint

В принципе, мы уже знаем, что сноски помещаются внизу страницы ({\tt location=page}), а концевые сноски в том месте, где команда \tex{placenotes[endnote]} ({\tt location=text}) установлена, однако мы можем настроить эту функцию и установить сноски, например, как {\tt location=text}, что приведет к тому, что сноски будут работать так же, как концевые сноски, поэтому они появятся в том месте в документе, где \tex{placenotes[footnote]} найдена команда или специальная команда для сносок \tex{placefootnotes}. С помощью этой процедуры мы могли бы, например, распечатать заметки под абзацем, в котором они находятся.


    \stopSmallPrint

  \item Разделение абзацев между примечаниями: по умолчанию каждое примечание печатается в отдельном абзаце, но мы можем распечатать все примечания на одной странице в одном абзаце, установив для параметра {\tt paragraph} в \tex{setupnote} значение \MyKey{yes}.

  \item Стиль, в котором будет написан сам текст заметки: опция {\tt style} в \tex{setupnotation}.

  \item Размер букв: опция {\tt bodyfont} в \tex{setupnote}.

    \startSmallPrint

Эта опция предназначена только для случая, когда мы хотим вручную установить размер шрифта для сносок. Это почти никогда не бывает хорошей идеей, поскольку по умолчанию \ConTeXt\ регулирует размер шрифта сносок так, чтобы он был меньше основного текста, но с размером, {\em пропорциональным} размеру шрифта в основном тексте.

    \stopSmallPrint

  \item Левое поле для текстовой заметки: опция {\tt margin} в \tex{setupnotation}.

  \item Максимальная ширина: опция {\tt width} в \tex{setupnote}.

  \item Количество столбцов: опция {\tt n} в \tex{setupnote} определяет, что текст заметки будет в двух или более столбцах. Значение \quote{n} должно быть целым числом.

  \stopitemize

\item {\bf Пространство между заметками или между заметками и текстом:} тут возможны следующие опции:

  \startitemize

  \item опция {\tt rule} в \tex{setupnote} устанавливает будет ли линия между областью заметки и областью страницы с основным текстом. Тут возможны значения {\tt yes, on, no} и {\tt off}. Первые два включают линию, а последнее отключает её.

  \item {\tt before} в \tex{setupnotation}: команда или комнады, которые должны быть выполнены перед вставкой текста примечания. Служит для вставки дополнительных интервалов, разделительных линий между заметками и т.д.

\stopitemize

\stopitemize

\stopsubsection

\startsubsection
  [title={Временное исключение заметок при компиляции}]
  \PlaceMacro{notesenabledfalse}\PlaceMacro{notesenabledtrue}

Команды \tex{notesenabledfalse} и \tex{notesenabledtrue} сообщают \ConTeXt, что нужно включить или отключить компиляцию заметок соответственно. Эта функция может быть полезна, если мы хотим получить версию без примечаний, когда в документе есть многочисленные и обширные примечания. По моему личному опыту, например, когда я правлю докторскую диссертацию, то предпочитаю прочитать её сначала за один раз, без заметок, а затем прочесть повторно с включенными заметками.

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:multiplecolumns,
    title={Абзацы с несколькими столбцами},
  ]

Набор текста более чем в одном столбце -- это возможность, которая может быть установлена:


\startitemize[a]

\item Как общая особенность макета страницы.

\item Как особенность определенных конструкций, таких как, например, структурированные списки, сноски или концевые сноски.

\item Как функция, применяемая к определенным абзацам в документе.

\stopitemize

В любом из этих случаев большинство команд и сред будут работать идеально, даже если мы работаем с более чем одним столбцом. Однако есть некоторые ограничения; в основном по отношению к плавающим объектам в целом (см. \in{section}[sec:floating objects]) и таблицам в частности (\in{section}[sec:tables]), даже если они не являются плавающими.

Что касается количества разрешенных столбцов, то \ConTeXt\ не имеет теоретических ограничений. Однако необходимо учитывать физические ограничения:

\startitemize

\item Ширина бумаги: неограниченное количество столбцов требует неограниченной ширины бумаги (если документ должен быть распечатан) или экрана (если это документ, предназначенный для отображения на экране). На практике, принимая во внимание {\em обычную} ширину форматов бумаги, которые продаются и используются для изготовления книг, а также экранов компьютерных устройств, текст, состоящий из более чем четырех или пяти столбцов, трудно уместить.

\item Размер памяти компьютера: в справочном руководстве \ConTeXt\ указано, что в {\em обычных} системах (не особо мощных и не особо ограниченных в ресурсах) можно обрабатывать от 20 до 40 столбцов.

\stopitemize

В этом разделе я остановлюсь на использовании многоколоночного механизма в специальных абзацах или фрагментах, поскольку

\startitemize

\item  Несколько столбцов как вариант макета страницы уже обсуждались  (в \in{subsection}[sec:pages-columns]  и \in{section}[sec:pages-other-matters]).

\item Возможность, предлагаемая некоторыми конструкциями, такими как структурированные списки или сноски, набор текста более чем в одном столбце, обсуждается применительно к рассматриваемой конструкции или среде.

\stopitemize

\stopcolumns

\startsubsection
  [title={Среда \tex{startcolumns}}]
  \PlaceMacro{startcolumns}

Обычная процедура для вставки в документ фрагментов, состоящих из нескольких столбцов, заключается в использовании среды столбцов, формат которой:

\type{\startcolumns[Configuration] ... \stopcolumns}

где {\em Configuration} позволяет нам контролировать многие аспекты среды. Мы можем указывать желаемую конфигурацию каждый раз, когда вызываем среду, или адаптировать работу среды по умолчанию для всех вызовов среды, последнее должно быть достигнуто с помощью

\PlaceMacro{setupcolumns}\type{\setupcolumns[Configuration]}

В обоих случаях параметры конфигурации одинаковы. Наиболее важные из них, упорядоченные в соответствии с их функциями, следующие:

\startitemize

\item {\bf Параметры, управляющие количеством столбцов и расстоянием между ними:}

  \startitemize

  \item {\tt n}: контролирует количество столбцов. Если это не указано, будут созданы два столбца.

  \item {\tt nleft, nright}: эти параметры используются в двустороннем макете документа (см. \in{subsection}[sec:double-sided] of \in{section}[sec:pages-other-matters]), чтобы установить количество столбцов на левой (чётной) и правой (нёчетной) страницах соответственно.

  \item {\tt distance}: пространство между колонками.

  \item {\tt separator}: определяет, что отмечает разделение между столбцами. Это может быть {\tt space} -- пробел (значение по умолчанию) или {\tt rule} -- линия, в этом случае между столбцами будет создана линия. В случае, если между столбцами вставлена линия, это, в свою очередь, можно настроить с помощью следующих двух опций:

    \startitemize

    \item {\tt rulecolor}: цвет линий.

    \item {\tt rulethickness}: толщина линий.

    \stopitemize

  \item {\tt maxwidth}: максимальная ширина столбцов + расстояние между ними.

  \stopitemize

\item {\bf Параметры, управляющие распределением текста по столбцам:}

  \startitemize

  \item {\tt balance}: по умолчанию \ConTeXt\ {\em балансирует} столбцы, то есть распределяет текст между ними так, чтобы в них было примерно одинаковое количество текста. Однако мы можем установить эту опцию с \quotation{{\tt no}}, текст не будет начинаться в столбце, пока предыдущий не будет заполнен.

  \item {\tt direction}: определяет, в каком направлении текст распределяется между столбцами. По умолчанию соблюдается естественный порядок чтения (слева направо), но при выборе этой опции {\tt reverse} приводит к порядку справа налево.

  \stopitemize

\starthead {\bf Параметры, влияющие на набор текста в среде:} \stophead

  \startitemize

    \item {\tt tolerance}: текст, записанный более чем в одном столбце, означает, что ширина строки в столбце меньше, и, как объяснялось при описании механизма, который \ConTeXt\ использует для построения строк (\in{section}[sec:lines]), это затрудняет поиск оптимальных точек для вставки разрывов строк. Эта опция позволяет нам временно изменять горизонтальный допуск в среде (см. \in{section}[sec:horizontaltolerance]), чтобы облегчить набор текста.

    \item {\tt align}: контролирует горизонтальное выравнивание линий в среде. Может принимать любое из следующих значений: {\tt right, flushright, left, flushleft, inner, flushinner, outer, flushouter, middle} or {\tt broad}. Относительно значения этих параметров см.\in{section}[sec:setupalign].

    \item {\tt color}: указывает название цвета, которым будет написан текст в окружении.

\stopitemize

\stopitemize

\stopsubsection

\startsubsection
  [title={Параллельные абзацы}]
  \PlaceMacro{defineparagraphs}\PlaceMacro{setupparagraphs}

Конкретный вариант многоколоночной композиции - параллельные абзацы. В этом типе конструкции текст распределяется по двум столбцам (обычно, хотя иногда и более чем по двум), но ему не разрешается свободно перемещаться между ними, и вместо этого поддерживается строгий контроль над тем, что будет отображаться в каждом столбце. Это очень полезно, например, для создания документов, которые противопоставляют две версии текста, такие как новая и старая версия недавно измененного закона, или в двуязычных изданиях; или также написать глоссарии для определенных текстовых определений, где текст, который должен быть определен, появляется слева, а определение справа, и т.д.

Обычно мы используем механизм таблиц для обработки таких параграфов; но это связано с тем, что большинство текстовых процессоров не так мощны, как \ConTeXt, в котором есть команды \tex{defineparagraphs} и \tex{setupparagraphs}, которые создают этот тип абзаца с использованием механизма столбцов, который, хотя и имеет ограничения, более гибкий, чем механизм таблиц.

\startSmallPrint

Насколько мне известно, у этих абзацев нет особого названия. Я назвал их «параллельными абзацами», потому что мне кажется, что это более описательный термин, чем тот, который \ConTeXt\ использует для их обозначения: \quotation{{\em paragraphs}}.

\stopSmallPrint

Основная команда здесь \tex{defineparagraphs}, синтаксис которой:

\type{\defineparagraphs[Name][Configuration]}

где {\em Name} -- это имя, которое мы даем этой конструкции, а {\em Configuration} -- это функции, которые она будет иметь, которые также можно установить позже с помощью

\type{\setupparagraphs[Name][Column][Configuration]}

это {\em Name}, указанное при его создании, {\em Column} - это необязательный аргумент, позволяющий нам настроить конкретный столбец, а {\em Configuration} позволяет нам определить, как он работает на практике.

Например:

\starttyping
\defineparagraphs
  [MurciaFacts]
  [n=3, before={\blank},after={\blank}]

\setupparagraphs
  [MurciaFacts][1]
  [width=.1\textwidth, style=bold]

\setupparagraphs
  [MurciaFacts][2]
  [width=.4\textwidth]
\stoptyping

Приведенный выше фрагмент создаст среду с тремя столбцами под названием MurciaFacts, а затем установит, что первый столбец будет занимать 10 процентов ширины строки и будет выделен жирным шрифтом, а второй столбец будет занимать 40 процентов ширины строки. Поскольку третий столбец не настроен, он будет иметь оставшуюся ширину, то есть 50\%.

Как только среда будет создана, мы можем использовать её, чтобы написать краткую историю Murcia:

\vbox{\starttyping
  \startMurciaFacts
    825
  \MurciaFacts
    City of Murcia founded.
  \MurciaFacts
    The origins of the city of Murcia are uncertain, but there is evidence
    that it was ordered to be founded under the name of Madina (or Medina)
    Mursiya in the year 825 by the Emir of al-Àndalus Abderramán II,
    probably built over a much earlier settlement.
  \stopMurciaFacts
\stoptyping}

\defineparagraphs
  [MurciaFacts]
  [n=3, before={\blank},after={\blank}]

\setupparagraphs
  [MurciaFacts][1]
  [width=.1\textwidth, style=bold]

\setupparagraphs
  [MurciaFacts][2]
  [width=.4\textwidth]

\example{\startMurciaFacts
    825
  \MurciaFacts
    City of Murcia founded.
  \MurciaFacts
    The origins of the city of Murcia are uncertain, but there is evidence that it was ordered to be founded under the name of Madina (or Medina) Mursiya in the year 825 by the Emir of al-Àndalus Abderramán II, probably built over a much earlier settlement.
  \stopMurciaFacts}

Если бы мы хотели продолжить рассказ о Мурсии, для следующего события потребовался бы новый экземпляр среды (\tex{startMurciaFacts}), потому что с помощью этого механизма невозможно включить несколько строк {\em rows}.

Из только что приведенного примера я хотел бы выделить следующие детали:

\startitemize

\item После создания среды, скажем, с помощью\\ \tex{defineparagraphs[MaryPoppins]}, она становится нормальной средой, которая начинается с \tex{startMaryPoppins} и заканчивается \tex{stopMaryPoppins}.

\item Также создается команда \tex{MaryPoppins}, которая используется в среде, чтобы указать, когда следует изменить столбец.

\stopitemize

Что касается параметров конфигурации для параллельных абзацев (\tex{setupparagraphs}), я понимаю, что на этом этапе введения и с учетом только что приведенного примера читатель уже подготовлен к определению назначения каждого из вариантов, поэтому ниже я буду указывать только название и тип опций и, где это уместно, возможные значения. Однако помните, что \tex{setupparagraphs [Name] [Configuration]} устанавливает конфигурации, которые влияют на всю среду, в то время как  \tex{setupparagraphs [Name] [NumColumn] [Configuration]} применяет конфигурацию исключительно к указанному столбцу.

\startitemize[columns, three, packed]\switchtobodyfont[small]

\item {\tt n}: Number

\item {\tt before}: Command

\item {\tt after}: Command

\item {\tt width}: Dimension

\item {\tt distance}: Dimension

\item {\tt align}: Derived from \tex{setupalign}

\item {\tt inner}: Command

\item {\tt rule}: on off

\item {\tt rulethickness}: Dimension

\item {\tt rulecolor}: Rule colour

\item {\tt style}: Style Command

\item {\tt color}: Colour

\stopitemize

\startSmallPrint

Приведенный выше список опций не является полным; Я исключил из списка вариантов те, которые я обычно здесь не объясняю. Я также воспользовался тем фактом, что мы находимся в разделе, посвященном столбцам, чтобы показать список параметров в тройных столбцах, хотя я не делал этого ни с одной из команд, описанных в этом разделе, а с опцией {\tt columns} в среде {\tt itemize}, которой посвящен следующий раздел.

\stopSmallPrint

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:itemize,
    title={Структурированные списки},
  ]

Когда информация представлена упорядоченно, читателю легче её понять. Но если расположение также заметно визуально, то это подчеркивает для читателя тот факт, что здесь у нас есть структурированный текст. Вот почему существуют определенные {\em конструкции} или {\em механизмы}, которые пытаются выделить визуальное расположение текста, тем самым способствуя его структурированию. Из инструментов, которые \ConTeXt\ предоставляет автору для этой цели, наиболее важным из них, о котором идет речь в этом разделе, является среда {\tt itemize}, которая используется для разработки того, что мы могли бы назвать {\em структурированными списками}.

Списки состоят из последовательности {\em текстовых элементов}  (которые я буду называть {\em элементами}), каждому из которых предшествует символ, который помогает выделить его, отличая его от остальных, и который я буду называть «разделителем». Разделителем может быть цифра, буква или символ. Обычно (но не всегда) {\em элементы} являются абзацами, и список форматируется так, чтобы обеспечить {\em видимость} разделителя для каждого элемента; обычно с помощью выступа, который выделяет его \footnote{В типографике отступ, который применяется ко всем строкам абзаца, кроме первой, называется {\em висячим отступом}, который позволяет легко найти первое слово или символ абзаца.}. В случае {\em вложенных списков} отступ для каждого постепенно увеличивается. Язык HTML обычно вызывает списки, в которых разделителем является число или символ, которые последовательно увеличиваются, упорядоченные списки, что означает, что каждый элемент списка будет иметь другой разделитель, который позволит нам ссылаться на каждый элемент по его номеру или идентификатору; и даёт имена неупорядоченным спискам, в которых один и тот же символ или символ используется для каждого элемента в списке.

\ConTeXt\ автоматически управляет нумерацией или алфавитным порядком разделителя в нумерованных списках, а также отступами, которые должны иметь вложенные списки; и, в случае вложения неупорядоченных списков, он также следит за выбором другого символа или символа, который позволяет сразу различать уровень элемента {\em item} в списке в соответствии с символом, который ему предшествует.

\startSmallPrint

В справочнике написано, что максимальный уровень вложенности в списки -- 4, но я предполагаю, что так было в 2013 году, когда было написано руководство. Согласно моим тестам, кажется, что нет предела вложенности упорядоченных списков (в моих тестах я достиг до 15 уровней вложенности). В то время как для неупорядоченных списков, похоже, также нет предела в том смысле, что независимо от того, сколько вложений мы включаем, никаких ошибок генерироваться не будет; но для неупорядоченных списков \ConTeXt\ применяет символы по умолчанию только для первых девяти уровней вложенности.

В любом случае следует указать, что чрезмерное использование вложенности в списки может иметь эффект, противоположный тому, что мы намеревались сделать, а именно: читатель чувствует себя потерянным, неспособным найти каждый элемент в общей структуре списка. По этой причине я лично считаю, что, хотя списки являются мощным инструментом для структурирования текста, почти никогда не стоит выходить за пределы третьего уровня вложенности; и даже третий уровень следует использовать только в определенных случаях, когда мы можем это оправдать.

\stopSmallPrint

Общий инструмент для написания списков в \ConTeXt\ - это среда \tex{itemize}, синтаксис которой следующий:

\PlaceMacro{startitemize}\type{\startitemize[Options][Configuration] ... \stopitemize}

где два аргумента являются необязательными. Первый позволяет использовать в качестве содержимого символические имена, которым \ConTeXt\ присвоил точное значение; второй аргумент, который используется редко, позволяет присвоить определенные значения определенным переменным, которые влияют на функционирование среды.

\startsubsection
  [
    reference=sec:itemize_select-list-type,
    title={Выбор типа списка и разделителя между {\em элементами}},
  ]

\startsubsubsection
  [title={Неупорядоченные списки}]

По умолчанию список, созданный с помощью  {\tt itemize}, представляет собой неупорядоченный список, в котором разделитель будет автоматически выбран в зависимости от уровня вложенности:

\startitemize[packed, columns, two]\switchtobodyfont[small]

\sym{\convertnumber{set 0}{1}} Для первого уровня вложенности.

\sym{\convertnumber{set 0}{2}} Для второго уровня вложенности.

\sym{\convertnumber{set 0}{3}} Для третьего уровня вложенности.

\sym{\convertnumber{set 0}{4}} Для четвертого уровня вложенности.

\sym{\convertnumber{set 0}{5}} Для пятого уровня вложенности.

\sym{\convertnumber{set 0}{6}} Для шестого уровня вложенности.

\sym{\convertnumber{set 0}{7}} Для седьмого уровня вложенности.

\sym{\convertnumber{set 0}{8}} Для восьмого уровня вложенности.

\sym{\convertnumber{set 0}{9}} Для девятого уровня вложенности.

\stopitemize

Однако мы можем прямо указать, что мы хотим использовать символ, связанный с определенным уровнем, просто передав номер уровня в качестве аргумента. Таким образом, \tex{startitemize[4]} сгенерирует неупорядоченный список, в котором символ \triangleright\ будет использоваться в качестве разделителя, независимо от уровня вложенности списка.

Мы также можем изменить предопределенный символ для каждого уровня с помощью \PlaceMacro{definesymbol}\tex{definesymbol}:

\type{\definesymbol[Level]{Symbol associated with the level}}

Например:

\type{\definesymbol[1][\diamond]}

заставит первый уровень неупорядоченных списков использовать символ \diamond\. С помощью этой же команды мы можем назначить некоторые символы уровням вложенности выше девяти. Так, например,

\type{\definesymbol[10][\copyright]}

присвоит международный символ авторских прав: {\em copyright} уровню вложенности 10.

\stopsubsubsection

\startsubsubsection
  [title=Упорядоченные списки]

Чтобы сгенерировать упорядоченный список, нам нужно указать {\tt itemize} тип упорядочивания, который мы хотим

\startitemize[intro, packed, 2*broad, columns, three]
\switchtobodyfont[small]

\sym{{\bf n}} 1, 2, 3, 4, ...

\sym{{\bf m}} {\switchtobodyfont[antykwa]1, 2, 3, 4, ...}

\sym{{\bf g}} \alpha, \beta, \gamma, \delta, ...

\sym{{\bf G}} \Alpha, \Beta, \Gamma, \Delta, ...

\sym{{\bf a}} a, b, c, d, ...

\sym{{\bf A}} A, B, C, D, ...

\sym{{\bf KA}} \cap{a, b, c, d, ...}

\sym{}

\sym{{\bf r}} i, ii, iii, iv, ...

\sym{{\bf R}} I, II, III, IV, ...

\sym{{\bf KR}} \cap{i, ii, iii, iv, ...}

\stopitemize

Разница между {\tt n} и {\tt m} заключается в шрифте, используемом для представления числа: {\tt n} использует шрифт, включенный в этот момент, тогда как {\tt m} использует другой, более элегантный, почти каллиграфический шрифт.

\startSmallPrint

Я не знаю название шрифта, который использует {\tt m}, и поэтому в приведенном выше списке я не смог точно представить тип чисел, генерируемых этой опцией. Предлагаю читателям проверить это самим.

\stopSmallPrint

\stopsubsubsection

\stopsubsection

\startsubsection
  [
    reference=sec:itemize_item-type,
    title={Введение элементов в список},
  ]

Как правило, элементы в списке, созданном с помощью \tex{startitemize}, вводятся с помощью команды \PlaceMacro{item}\tex{item}, которая также имеет версию в форме среды, которая больше подходит для стиля Mark~IV:
\PlaceMacro{startitem}\tex{startitem ... \stopitem}.
 Таким образом, следующий пример:

\startDoubleExample
\starttyping
\startitemize[a, packed]
\startitem Первый элемент \stopitem
\startitem Второй элемент \stopitem
\startitem Третий элемент \stopitem
\stopitemize
\stoptyping

\startitemize[a, packed]
\startitem Первый элемент  \stopitem
\startitem Второй элемент \stopitem
\startitem Третий элемент \stopitem
\stopitemize
\stopDoubleExample

даст такой же результат как:

\startDoubleExample
\starttyping
\startitemize[a, packed]
\item Первый элемент
\item  Второй элемент
\item Третий элемент
\stopitemize
\stoptyping

\startitemize[a, packed]
\item Первый элемент
\item  Второй элемент
\item Третий элемент
\stopitemize

\stopDoubleExample

\tex{item} или \tex{startitem} это {\em общая} команда для добавления элемента в список. Наряду с этим есть следующие дополнительные команды, когда мы хотим добиться особого результата:

\startitemize[3*broad]

\sym{\PlaceMacro{head}\tex{head}} Эту команду следует использовать вместо \tex{item}, когда мы не хотим вставлять разрыв страницы после рассматриваемого элемента.

  \startSmallPrint

Распространенной конструкцией является включение вложенного списка или текстового блока непосредственно под элементом списка, так что элемент списка, в некотором смысле, функционирует как {\em title} заголовок подсписка или текстового блока. В этих случаях разрыв страницы между этим элементом и последующими абзацами не рекомендуется. Если мы используем \tex{head} вместо \tex{item} для ввода этих элементов, \ConTeXt\ ({\em постарается} насколько это возможно) не отделять такой элемент от следующего блока.

  \stopSmallPrint

\sym{\PlaceMacro{sym}\tex{sym}} The \type{\sym{Text}} команда вводит элемент, в котором текст, используемый в качестве аргумента \tex{sym}, используется как {\em разделитель}, а не число или символ. Этот список, например, состоит из элементов, вводимых с помощью \tex{sym} вместо \tex{item}.

\sym{\PlaceMacro{sub}\tex{sub}} Эта команда, которую следует использовать только в упорядоченных списках (где каждому элементу предшествует число или буква в алфавитной последовательности), заставляет вводимый с ним элемент сохранять номер предыдущего элемента и для указания того, что номер повторяется, и это не ошибка, слева напечатан знак \quote{+}. Это может быть полезно, если мы ссылаемся на предыдущий список, для которого мы предлагаем изменения, но где для ясности следует сохранить нумерацию исходного списка.

\sym{\PlaceMacro{mar}\tex{mar}} Эта команда сохраняет нумерацию элементов, но добавляет букву или символ в поле (которое передаётся ей в качестве аргумента в фигурных скобках). Я не совсем понимаю, насколько это полезно.

\stopitemize

Есть две дополнительные команды для ввода элементов, комбинация которых дает очень {\em интересные} эффекты, и, если можно так выразиться, я думаю, что лучше объяснить их на примере. \PlaceMacro{ran}\tex{ran} (сокращение от {\em range}) и \PlaceMacro{its}\tex{its}, сокращение от {\em items}. Первый принимает аргумент (в фигурных скобках), а второй повторяет символ, используемый в качестве разделителя в списке, x количество раз (по умолчанию 4 раза, но мы можем изменить это, используя параметр {\tt items}). В следующем примере показано, как эти две команды могут работать вместе для создания списка, имитирующего анкету:

\vbox{\starttyping
After reading the following introduction, answer the following questions:

\startitemize[5, packed][width=8em, distance=2em, items=5]
\ran{No \hss Yes}
\its I will never use \ConTeXt, it is too difficult.
\its I will only use it for writing big books.
\its I will always use it.
\its I like it so much I will call my next child \quotation{Hans}, as a tribute to Hans Hagen.
\stopitemize
\stoptyping}

%\startlocalfootnotes
\example{After reading this introduction, answer the following questions:

\startitemize[5, packed][width=8em, distance=2em, items=5]
\ran{No \hss Yes}
\its I will never use \ConTeXt, it is too difficult.
\its I will only use it for writing big books.
\its I will always use it.
\its I like it so much I will call my next child \quotation{Hans}, as a tribute to Hans Hagen.
\stopitemize
%\placelocalfootnotes
}
%\stoplocalfootnotes

\stopsubsection

\startsubsection
  [
    reference=sec:itemize_arg1,
    title={Базовая конфигурация списка},
  ]

Напомним, что \MyKey{itemize} допускает два аргумента. Мы уже видели, как первый аргумент позволяет нам выбрать нужный тип списка. Но мы также можем использовать его для указать другие характеристики списка; это делается с помощью следующих опций для \MyKey{itemize} в его первом аргументе:

\startitemize

\item {\tt columns}: этот параметр определяет, что список состоит из двух или более столбцов. После опции столбцов желаемое количество столбцов должно быть записано в виде слов, разделенных запятой: два, три, четыре, пять, шесть, семь, восемь или девять. {\tt Columns}, за которыми нет числа, дают два столбца.

\item {\tt intro}: эта опция пытается не отделять список разрывом строки от предшествующего абзаца.

\item {\tt continue}: в упорядоченных списках (числовых или алфавитных) эта опция заставляет список продолжать нумерацию с последнего пронумерованного списка. Если опция {\tt continue} используется, необязательно указывать, какой тип списка мы хотим, так как предполагается, что он будет таким же, как последний пронумерованный список.

\item {\tt packed}: это один из наиболее часто используемых вариантов. Его использование приводит к уменьшению вертикального расстояния между различными  {\em items} элементами в списке, насколько это возможно.

\item {\tt nowhite:} производит эффект, похожий на {\tt packed}, но более радикальный: он не только уменьшает вертикальное пространство между элементами, но также и вертикальное пространство между списком и окружающим текстом.

\item {\tt broad}: увеличивает горизонтальное пространство между разделителем элементов и текстом элемента. Пространство можно увеличить, умножив число на {\tt broad}, например, \type{\startitemize[2*broad]}.

\item {\tt serried}: убирает горизонтальное пространство между разделителем элементов и текстом.

\item {\tt intext}: убирает отступ.

\item {\tt text}: убирает отступ и уменьшает расстояние между элементами по вертикали.

\item {\tt repeat}: во вложенных списках нумерация дочернего уровня {\em повторяет} тот же уровень, что и предыдущий уровень. Таким образом, на первом уровне у нас будет: 1, 2, 3, 4; на втором уровне: 1.1, 1.2, 1.3 и т.д. Опция должна быть указана для внутреннего списка, а не для внешнего списка.

\item {\tt margin, inmargin}: по умолчанию разделитель списка печатается слева, но внутри самой текстовой области ({\tt atmargin}). Параметры {\tt margin} и {\tt inmargin} перемещают разделитель на поле.

\stopitemize

\stopsubsection

\startsubsection
  [
    reference=sec:itemize_arg2,
    title={Дополнительная настройка списка},
  ]

Второй аргумент, также необязательный, в \tex{startitemize} позволяет более детально и тщательно настраивать списки.

\startitemize

\item {\tt before, after}: команды, выполняемые перед запуском или после закрытия среды itemize соответственно.

\item {\tt inbetween}: команда, выполняемая между двумя элементами {\tt items}.

\item {\tt beforehead, afterhead}: команда, запускаемая до или после ввода элемента с помощью команды \tex{head} command.

\item {\tt left, right}: символ, печатаемый слева или справа от разделителя. Например, чтобы получить алфавитный список, в котором буквы заключены в круглые скобки, мы должны написать:

  \type{\startitemize[a][left=(, right=)]}

\item {\tt stopper}: указывает символ, который нужно написать после разделителя. Работает только в упорядоченных списках.

\item {\tt width, maxwidth}: ширина пространства, зарезервированного для разделителя и, следовательно, для отступа.

\item {\tt factor}: репрезентативное число коэффициента разделения между разделителем и текстом.

\item {\tt distance}: мера расстояния между разделителем и текстом.

\item {\tt leftmargin, rightmargin, margin}: поле, добавляемое слева (leftmargin) или справа (rightmargin) от элементов.

\item {\tt start}: номер, с которого будет начинаться нумерация элементов.

\item {\tt symalign, itemalign, align}: выравнивание элементов. Допускает те же значения, что и  \tex{setupalign}. {\tt symalign} контролирует выравнивание разделителя; {\tt itemalign} текст элемента и {\tt align} выравнивание обоих.

\item {\tt identing}: отступ первой строки в абзацах в среде. См. \in{section}[sec:indentation].

\item {\tt indentnext}: указывает, должен ли абзац после окружения иметь отступ или нет. Значения {\em yes, no} и {\tt auto}.


\item {\tt items}: в элементах, введенных как input с \tex{its}, указывает, сколько раз должен быть воспроизведен разделитель.

\item {\tt style, color; headstyle, headcolor; marstyle, marcolor; symstyle, symcolor}: эти параметры управляют стилем и цветом элементов при их вводе в среду с помощью команд \tex{item}, \tex{head}, \tex{mar} или \tex{sym}.

\stopitemize

\stopsubsection

\startsubsection
  [
    reference=sec:items command,
    title={Простые списки с помощью команды \tex{items}},
  ]
  \PlaceMacro{items}

Альтернативой среде {\tt itemize} для очень простых ненумерованных списков, где элементы не слишком большие, является команда \tex{items}, синтаксис которой:

\type{\items[Configuration]{Item 1, Item 2, ..., item n}}

Различные элементы, которые будет в списке, отделяются друг от друга запятыми. Например:

\startDoubleExample
\startframedtext[frame=off, before=, after=]
\starttyping
Graphics files can
have, among other things, the
following extensions:

\items{png, jpg, tiff, bmp}
\stoptyping
\stopframedtext

Graphics files can have, among other things, the following extensions:

\items{png, jpg, tiff, bmp}

\stopDoubleExample

Параметры конфигурации, поддерживаемые этой командой, являются подмножеством параметров {\tt itemize}, за исключением двух конкретных параметров для этой команды:

\startitemize

\item {\tt symbol}: этот параметр определяет тип создаваемого списка. Он поддерживает те же значения, которые используются для {\tt itemize}, чтобы выбрать какой-либо тип списка.

\item {\tt n}: эта опция указывает, от какого номера позиции будет разделитель.

\stopitemize

\stopsubsection

\startsubsection
  [
    reference=sec:setupitemize,
    title={Предварительное определение поведения списка и создание наших собственных типов списков},
  ]

В предыдущих разделах мы видели, как указать, какой тип списка нам нужен и какие характеристики он должен иметь. Но делать это каждый раз, когда вызывается список, неэффективно и обычно приводит к бессвязному документу, в котором каждый список имеет свой собственный внешний вид, но без другого внешнего вида, отвечающего каким-либо критериям.

Предпочтительный результат для этого:

\startitemize

\item Заранее определите {\em нормальное} поведение элементов  {\tt itemize} и \tex{items} в преамбуле документа.

\item Создавайте собственные индивидуальные списки. Например: список с алфавитной нумерацией, который мы хотим назвать {\em ListAlpha}, список, пронумерованный римскими цифрами ({\em ListRoman}) и т.д.

\stopitemize

Первого мы достигаем с помощью команд \tex{setupitemize} и \tex{setupitems}. Второй требует использования команды\PlaceMacro{defineitemgroup}\tex{defineitemgroup} или \PlaceMacro{defineitems}\tex{defineitems}. Первый создаст среду списка, аналогичную {\tt itemize}, а второй - команду, аналогичную {\tt items}.

\stopsubsection

\stopsection

\startsection
  [title={Описания и перечисления}]

Описания и перечисления - это две конструкции, которые позволяют согласованно набирать абзацы или группы абзацев, которые развивают, описывают или определяют фразу или слово.

\startsubsection
  [title={Описания}]

Для описаний мы различаем заголовок {\em title} и его объяснение или развитие. Мы можем создать новое описание с помощью:

\PlaceMacro{definedescription}\type{\definedescription [Name] [Configuration]}

где {\em Name}  -- это имя, под которым будет известна эта новая конструкция, а Configuration управляет тем, как будет выглядеть наша новая структура. После предыдущего оператора у нас будет новая команда и среда с выбранным нами именем. Таким образом:

\type{\definedescription [Concept]}

создаст команды:

\starttyping
  \Concept{Title}
  \startConcept {Title} ... \stopConcept
\stoptyping

Мы будем использовать команду для случая, когда пояснительный текст заголовка состоит только из одного абзаца, и среду для заголовков, описание которых занимает более одного абзаца. При использовании команды следующий за ней абзац будет считаться пояснительным текстом заголовка. Но когда используется среда, весь контент будет отформатирован с соответствующим отступом, чтобы было понятно, как оно соотносится с заголовком.

Например:

\starttyping
\definedescription
  [Concept]
  [alternative=left, width=1cm, headstyle=bold]

\Concept{Contextualise}

Place something in a certain context, or typeset a text with the typesetting system called \ConTeXt. The ability to correctly contextualise in any situation is considered a sign of intelligence and good sense.

\stoptyping

Это даст следующий результат:

\startcolor[red]

\definedescription
  [Concept]
  [alternative=left, width=3cm, headstyle=bold]

\Concept{Contextualise}

Place something in a certain context, or typeset a text with the typesetting system called \ConTeXt. The ability to correctly contextualise in any situation is considered a sign of intelligence and good sense.

\stopcolor

Как обычно бывает с \ConTeXt, внешний вид нашей новой конструкции может быть указан во время её создания с помощью аргумента {\em Configuration} или позже с помощью \tex{setupdescription}:

\PlaceMacro{setupdescription}\type{\setupdescription [Name] [Configuration]}

где {\em Name} это имя нашего нового описания, а {\em Configuration} определяет, как оно выглядит. Среди различных возможных вариантов конфигурации выделю:

\startitemize

\item {\tt alternative}: эта опция принципиально контролирует внешний вид конструкции. Он определяет размещение заголовка по отношению к его описанию. Возможные значения: {\tt left, right, inmargin, inleft, inright, margin, leftmargin, rightmargin, innermargin, outermargin, serried, hanging} их названия достаточно ясны, чтобы получить представление о результате, хотя, в случае сомнения, это лучше сделать тест, чтобы посмотреть, как это выглядит.

\item {\tt width}: управляет шириной поля, в котором будет написан заголовок. В зависимости от значения {\tt alternative} это расстояние также будет частью отступа, с которым написан пояснительный текст.

\item {\tt distance}: контролирует расстояние между заголовком и пояснением.

\item {\tt headstyle, headcolor, headcommand}: влияют на то, как будет выглядеть сам заголовок: Style ({\tt headstyle}) и color ({\tt headcolor}). С помощью headcommand мы можем указать команду, которой текст заголовка будет передан в качестве аргумента.
Например: {\tt headcommand=\backslash WORD} будет следить за тем, чтобы текст заголовка был в верхнем регистре.

\item {\tt style, color}: управляет внешним видом описательного текста заголовка.

\stopitemize

\stopsubsection

\startsubsection
  [title={Перечисления}]

Перечисления представляют собой пронумерованные текстовые элементы, структурированные на нескольких уровнях. Каждый элемент начинается с заголовка, который по умолчанию состоит из имени структуры и её номера, хотя мы можем изменить заголовок с помощью опции {\tt text}. Они очень похожи на описания, но отличаются тем, что:

\startitemize

\item Все элементы в перечислении имеют одинаковый заголовок.

\item Поэтому они отличаются друг от друга своей нумерацией.
\stopitemize

Эта структура может быть очень полезной, например, для написания формул, задач или упражнений в учебнике, обеспечивая их правильную нумерацию и единообразный формат.
Создаём перечисление с помощью

\PlaceMacro{defineenumeration}\type{\defineenumeration [Name] [Configuration]}

где {\em Name} это имя новой конструкции, а  {\em Configuration} определяет, как она будет выглядеть.

Итак, в следующем примере:

\starttyping
  \defineenumeration
    [Exercise]
    [alternative=top, before=\blank, after=\blank, between=\blank]
\stoptyping

Мы создали новую структуру под названием {\em Exercise}, и, как и в случае с перечислениями, у нас будут доступны следующие новые команды:

\starttyping
  \Exercise
  \startExercise
\stoptyping

Команда используется только для {\em упражнений} с одним абзацем и среда для{\em упражнений} с несколькими абзацами. Но поскольку перечисления могут иметь до четырех уровней глубины, также будут созданы следующие команды и среды:

\starttyping
  \subExercise
  \startsubExercise
  \stopsubExercise
  \subsubExercise
  \startsubsubExercise
  \stopsubsubExercise
  \subsubsubExercise
  \startsubsubsubExercise
  \stopsubsubsubExercise
\stoptyping

А для управления нумерацией используются следующие дополнительные команды:

\startitemize

\item \tex{setEnumerationName}:  устанавливает текущее значение нумерации.

\item \tex{resetEnumerationame}: устанавливает счетчик перечисления на ноль.

\item \tex{nextEnumerationName}: увеличивает счетчик перечисления на единицу.

\stopitemize

Внешний вид перечислений можно определить во время их создания или позже с помощью \tex{setupenumeration}, формат которого:

\PlaceMacro{setupenumeration}\type{\setupenumeration [Name] [Configuration]}.

Для каждого перечисления мы можем настроить каждый его уровень отдельно. Так, например, \tex{setupenumeration [subExercise] [Configuration]} повлияет на второй уровень перечисления под названием  \quotation{Exercise}.

Параметры и значения, настраиваемые с помощью  \tex{setupenumeration}, аналогичны тем, что указаны в \tex{setupdescription}.

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:FramesLines,
    title={Линии и рамки},
  ]

В справочном руководстве \ConTeXt\ говорится, что \TEX\ обладает огромными возможностями управления текстом, но очень слаб в управлении графической информацией. Хочу не согласиться: это правда, что для обработки строк и фреймов возможности \ConTeXt\ (на самом деле \TEX) не так велики, как когда дело доходит до набора текста. Но говорить о слабости системы в этом отношении, я думаю, будет натяжкой. Я не знаю ни одной функции с линиями и рамками, которые другие системы набора могут выполнять для документов, которые \ConTeXt\ не может создать. А если объединить \ConTeXt\ с MetaPost, или с TiKZ (в \ConTeXt\ для этого есть модуль расширения), то возможности ограничиваются только нашим воображением.

Однако в следующих разделах я ограничусь объяснением того, как создавать простые горизонтальные и вертикальные линии и рамки вокруг слов, предложений или абзацев.

\startsubsection
  [title={Простые линии}]

Самый простой способ нарисовать горизонтальную линию - использовать команду \PlaceMacro{hairline}\tex{hairline}, которая генерирует горизонтальную линию, занимающую всю ширину обычной текстовой строки.

В строке, где находится строка, созданная с помощью \tex{hairline}, не может быть никакого текста. Чтобы сгенерировать строку, способную сосуществовать с текстом в одной строке, нам нужна команда \PlaceMacro{thinrule}\tex{thinrule}. Эта вторая команда будет использовать всю ширину линии. Следовательно, в изолированном абзаце он будет иметь тот же эффект, что и \tex{hairline}, в то время как в противоположном случае \tex{thinrule} будет производить такое же горизонтальное расширение, что и \tex{hfill} (см.\in{section}[sec:horizontal space2]), но вместо заполнения горизонтального пространства с помощью пробелов (как и \tex{hfill}), он заполняет его линией.

\startDoubleExample
\starttyping
On the left\thinrule\\
\thinrule On the right\\
On both\thinrule sides\\
\thinrule centred\thinrule
\stoptyping

On the left\thinrule\\
\thinrule On the right\\
On both\thinrule sides\\
\thinrule centred\thinrule

\stopDoubleExample

С помощью команды\PlaceMacro{thinrules}\tex{thinrules} мы можем сгенерировать несколько строк. Например, \tex{thinrules[n=2]} будет генерировать две последовательные линии, каждая шириной нормальной линии. Строки, созданные с помощью \tex{thinrules}, также можно настроить либо при фактическом вызове команды, указав конфигурацию в качестве одного из её аргументов, либо, как правило, с помощью \tex{setupthinrules}. Конфигурация включает толщину линии ({\tt rulethickness}), её цвет ({\tt color}), цвет фона ({\tt background}), межстрочный интервал ({\tt interlinespace}) и т.д.

\startSmallPrint

Я оставлю ряд вариантов без объяснения причин. Читатель может ознакомиться с ними в {\tt setup-en.pdf} (см. \in{section}[sec:qrc-setup-en]). Некоторые варианты отличаются от других только нюансами (то есть между ними практически нет разницы), и я думаю, что читателю быстрее попытаться {\em увидеть} разницу, чем мне попытаться передать её словами. Например: толщина линии, которую я только что сказал, зависит от параметра {\tt rulethickness}. Но на это также влияют параметры  {\tt height} и {\tt depth}.

\stopSmallPrint

Строки меньшего размера можно создать с помощью команд\PlaceMacro{hl}\tex{hl} и \PlaceMacro{vl}\tex{vl}. Первый создает горизонтальную линию, а второй -- вертикальную. Оба принимают число в качестве параметра, который позволяет нам вычислить длину линии. В \tex{hl} число измеряет длину в {\em ems} (нет необходимости указывать единицу измерения в команде), а в \tex{vl} аргумент относится к текущей высоте строки.

Таким образом, \tex{hl[3]} генерирует горизонтальную линию в 3 ems, а \tex{vl[3]} генерирует вертикальную линию высотой, соответствующую трем линиям. Помните, что индикатор линейных размеров должен быть заключен между квадратными скобками, а не между фигурными скобками. В обеих командах аргумент необязателен. Если он не введен, предполагается значение 1.

\PlaceMacro{fillinline}\tex{fillinline} -- еще одна команда для создания горизонтальных линий точной длины. Она поддерживает больше настроек, в которых мы можем указать (или заранее определить с помощью \PlaceMacro{setupfillinlines}\tex{setupfillinlines} опцию {\tt width}) в дополнение к некоторым другим функциям.

Особенностью этой команды является то, что текст, который написан справа, будет помещен слева от строки, отделяя этот текст от строки необходимым пробелом, чтобы занять всю строку. Например:

\starttyping
\fillinline[width=6cm] Name
\stoptyping

будет генерировать

\startcolor[red]

\fillinline[width=6cm] {Name}

\stopcolor

\startSmallPrint

Я подозреваю, что эта странная операция связана с тем, что этот макрос был разработан для записи форм, в которых за текстом есть горизонтальная линия, на которой должно быть написано что-то \Conjecture. Фактически само название команды {\tt fillinline} означает заполнить строку.

\stopSmallPrint

Помимо ширины линии, мы можем настроить поле ({\tt margin}), расстояние ({\tt distance}), толщину ({\tt rulethickness}) и цвет ({\tt color}).
 \tex{fillinline} почти идентична \tex{fillinrules}, хотя эта команда позволяет нам вставить более одной строки (опция \MyKey{n}).

\type{\fillinrules [Configuration] {Text} {Text}}

где три аргумента необязательны.

\stopsubsection

\startsubsection
  [title={Строки, связанные с текстом}]

Хотя некоторые из команд, которые мы только что видели, могут генерировать строки, которые сосуществуют с текстом в одной строке, на самом деле эти команды сосредоточены на макете строки. Для написания строк, связанных с определенным текстом, в \ConTeXt\ есть команды:

\startitemize

\item которые генерируют текст между строками.

\item генерирующие строки под текстом (подчеркивание - underlining), над текстом (перекрытие - overlining) или сквозь него (зачеркивание - strikethrough).

\stopitemize


Чтобы сгенерировать текст между строками, обычно используется команда \PlaceMacro{textrule}\tex{textrule}. Эта команда рисует линию, пересекающую всю ширину страницы, и записывает текст, который она принимает в качестве параметра, слева (но не на полях). Например:

\startDoubleExample
\starttyping
\textrule{Example text}
\stoptyping
\

\textrule{Example text}

\stopDoubleExample

\startSmallPrint

Предполагается, что \tex{textrule} допускает необязательный первый аргумент с тремя возможными значениями: {\tt top}, {\tt middle} и \Doubt {\tt bottom}. Но после некоторых тестов мне так и не удалось выяснить, какой эффект производят такие варианты.

\stopSmallPrint

Подобно \tex{texrule}, есть среда \PlaceMacro{starttextrule}\tex{starttextrule}, которая, помимо вставки строки с текстом в начале среды, вставляет горизонтальную строку в конце. Формат этой команды:

\type{\starttextrule[Configuration]{Text on the line} ... \stoptextrule} %

И \tex{textrule}, и \text{starttextrule} можно сконфигурировать с помощью \PlaceMacro{setuptextrule}\tex{setuptextrule}.

Чтобы рисовать линии под текстом, над текстом или сквозь него, используются следующие команды:

\PlaceMacro{underbar}\PlaceMacro{underbars}\PlaceMacro{overbar}
\PlaceMacro{overbars}\PlaceMacro{overstrike}\PlaceMacro{overstrikes}
\starttyping
  \underbar{Text}
  \underbars{Text}
  \overbar{Text}
  \overbars{Text}
  \overstrike{Text}
  \overstrikes{Text}
\stoptyping

Как мы видим, для каждого типа строки (под, над или через текст) есть две команды. Версия команды в единственном числе рисует одну линию под, поверх или через весь текст, взятый в качестве аргумента, в то время как версия команды во множественном числе рисует линию только над словами, но не через пробел.

Эти команды несовместимы друг с другом, то есть две из них не могут применяться к одному и тому же тексту. Если мы попробуем, всегда будет преобладать последний. С другой стороны, \tex{underbar} может быть вложенным, подчеркивая то, что уже было подчеркнуто.

\startSmallPrint

  Справочное руководство указывает, что \tex{underbar} запрещает перенос слов в тексте, составляющих его аргумент. Мне неясно, относится ли это утверждение только к \tex{underbar} или к шести командам, которые мы исследуем.

\stopSmallPrint

\stopsubsection

\startsubsection
  [title={Слова или тексты в рамке}]

Чтобы окружить текст рамкой или сеткой, мы используем:

\startitemize

\item Команды \PlaceMacro{framed}\tex{framed} or \PlaceMacro{inframed}\tex{inframed} если текст относительно короткий и не занимает более одной строки.

\item Среда \PlaceMacro{startframedtext}\tex{startframedtext} предназначается для более длинных текстов.
\stopitemize

Разница между  \tex{framed} и \tex{inframed}  заключается в точке, из которой отрисовывается рамка. В \tex{frame} рамка нарисована сверху от идеальной линии, называемой базовой линией, на которую опираются буквы, но некоторые буквы проходят вниз. При \tex{inframed} рамка отрисовывается также вверх от самой низкой точки на линии. Например:

\startDoubleExample
\starttyping
Here there are \framed{two} good
\inframed{frames}.
\stoptyping

Here there are \framed{two} good
\inframed{frames}.

\stopDoubleExample

И текст в рамке, и текст в фреймах можно настроить с помощью \PlaceMacro{setupframed}\tex{setupframed}, а \tex{startframedtext} - с помощью \PlaceMacro{setupframedtext}\tex{setupframedtext}. Варианты настройки для обеих команд очень похожи. Они позволяют нам указать размеры рамки ({\tt height, width, depth}), форму углов ({\tt framecorner}), которые могут быть {\tt rectangular} или круглыми ({\tt round }), цвет рамки ({\tt framecolor}), толщина линии ({\tt framethickness}), выравнивание содержимого ({\tt align}), цвет текста ({\tt foregroundcolor}), цвет фона ( {\tt background} и {\tt backgroundcolor}) и т.д.

Для \tex{startframedtext} есть также явно странное свойство: {\tt frame=off}, из-за которого рамка не отрисовывается (хотя она все еще там, но невидима). Это свойство существует потому, что, поскольку рамка вокруг абзаца неделима, обычно весь абзац помещается в среду {\tt framedtext} с отключенным параметром рисования рамки, чтобы гарантировать, что в абзац не вставлены разрывы страниц.

Мы также можем создать индивидуальную версию этих команд с помощью \PlaceMacro{defineframed}\tex{defineframed} и \PlaceMacro{defineframedtext}\tex{defineframedtext}.

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:buffer,
    title={Другие среды и конструкции, представляющие интерес},
  ]

В \ConTeXt\ ещё существует много сред, о которых я даже не упоминал или только очень мимоходом. В качестве примера:

\startitemize

\item {\tt\bf buffer}\PlaceMacro{startbuffer}\PlaceMacro{getbuffer} {\em Buffers} - это фрагменты текста, хранящиеся в памяти для последующего повторного использования. {\em buffer} определяется где-то в документе с помощью \cmd{startbuffer[BufferName] ... \backslash stopbuffer} и может извлекаться сколько угодно часто в другом месте документа с помощью \tex{getbuffer[BufferName]}.


\item {\tt\bf chemical}\PlaceMacro{startchemical}

Эта среда позволяет нам помещать в неё химические формулы. Если \TeX\ выделяется, среди прочего, своей способностью правильно набирать текст с математическими формулами, с самого начала \ConTeXt\ стремился распространить эту способность на химические формулы, и у него есть среда, в которой команды и структуры разрешены для написание химических формул.

\item {\tt\bf combination}\PlaceMacro{startcombination}

Эта среда позволяет нам объединять несколько плавающих элементов на одной странице. Это особенно полезно для выравнивания различных подключенных внешних изображений в нашем документе.

\item {\tt\bf formula}\PlaceMacro{startformula}
  Это среда, предназначенная для набора математических формул.

\item {\tt\bf hiding}\PlaceMacro{starthiding}
 скрытие текста, хранящегося в этой среде, не будет скомпилировано и, следовательно, не появится в окончательном документе. Это полезно для временного отключения компиляции определенных фрагментов в исходном файле. То же самое достигается путем выделения одной или нескольких строк в качестве комментария. Но когда фрагмент, который мы хотим отключить, относительно длинный, более эффективным, чем пометка десятков или сотен строк исходного файла в качестве комментария, является вставка команды  \tex{starthiding} в начале фрагмента и \tex{stophiding} в конце.

\item {\tt\bf legend}\PlaceMacro{startlegend}
  В математическом контексте \TEX\ применяет другие правила, чтобы обычный текст не мог быть написан. Однако иногда формула сопровождается описанием используемых в ней элементов. Для этой цели существует среда \tex{startlegend}, которая позволяет нам помещать обычный текст в математический контекст.

\item {\tt\bf linecorrection}\PlaceMacro{startlinecorrection}
Обычно \ConTeXt\ правильно управляет вертикальным пространством между строками, но иногда строка может содержать что-то, из-за чего она выглядит неправильно. Это происходит в основном со строками, фрагменты которых заключены в рамку с помощью \tex{framed}. В таких случаях эта среда корректирует межстрочный интервал таким образом, чтобы абзац отображался правильно.

\item {\tt\bf mode}\PlaceMacro{startmode}
Эта среда предназначена для включения фрагментов в исходный файл, которые будут скомпилированы только в том случае, если активен соответствующий режим. Использование {\em modes} не является предметом этого введения, но это очень интересный инструмент, если мы хотим иметь возможность создавать несколько версий в разных форматах из одного исходного файла. Дополнительной средой к этой является \PlaceMacro{startnotmode}\tex{startnotmode}.

\item {\tt\bf opposite}\PlaceMacro{startopposite}
эта среда используется для набора текста, когда содержимое левой и правой страниц связано.

\item {\tt\bf quotation}\PlaceMacro{startquotation}
Очень похоже на среду {\tt narrower}, предназначенную для вставки умеренно длинных цитат. Среда гарантирует, что текст внутри будет заключен в кавычки, а поля увеличены, чтобы абзац с цитатой визуально выделялся на странице. Но следует отметить, что в соответствии с обычным стилем блочных кавычек на английском языке не должно быть открывающих и закрывающих кавычек, что делает эту команду или среду менее полезной.

\item {\tt\bf standardmakeup}\PlaceMacro{startstandardmakeup}
Эта среда предназначена для создания страниц с заголовком документа, что относительно часто встречается в академических документах определенной длины, таких как докторские диссертации, магистерские диссертации и т.д.

\stopitemize

Чтобы узнать о любой из этих сред (или других, которые я не упомянул), я предлагаю следующие шаги:

\startitemize[n]

\item Информацию о среде ищите в справочном руководстве \ConTeXt. В этом руководстве не упоминаются все среды; но в нём что-то говорится о каждом элементе в списке выше.

\item Напишите тестовый документ, в котором используется среда.

\item Найдите в официальном списке команд \ConTeXt\ (см. \in{section}[sec:qrc-setup-en]) параметры конфигурации для рассматриваемой среды, затем протестируйте их, чтобы точно увидеть что они делают.

\stopitemize

\stopchapter

\stopcomponent

%%% Local Variables:
%%% mode: ConTeXt
%%% mode: auto-fill
%%% coding: utf-8-unix
%%% TeX-master: "../introCTX.mkiv"
%%% End:
%%% vim:set filetype=context tw=75 : %%%
