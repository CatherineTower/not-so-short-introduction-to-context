%%% File:       b13_Floats
%%% Author:    Joaquín Ataz-López
%%% Begun:     August 2020
%%% Concluded: August 2020
%%% Contents:  Arriving at this chapter I was already tired of the
%%%            introduction. Hence, for example, there is only one
%%%            kind of table explained. Doing tables (in TeX, LaTeX or
%%%            ConTeXt) makes me lazier. The chpater's organisation
%%%            on the other hand is somewhat heterodox (I think)
%%%            It is clear to me, but I am not sure if the public
%%%            will think that what is an ingenious" círcle" for me
%%%            is no more than some powerful mental disorder!
%%% Edited with: Emacs + AuTeX - And at times vim + context-plugin
%%%

\environment ../introCTX_env.mkiv

\startcomponent b13_Floats.mkiv

\startchapter
  [title={Изображения, таблицы и другие плавающие объекты}]

\TocChap

Эта глава в основном посвящена плавающим объектам (поплавкам). Но, продолжая эту концепцию, он использует ее для объяснения двух типов объектов, которые не обязательно являются плавающими, хотя они часто настраиваются так, как если бы они были: внешние изображения и таблицы. Глядя на оглавление этой главы, можно подумать, что все это очень неаккуратно: сначала речь идет о плавающих объектах, затем идет речь об изображениях и таблицах, а в конце снова говорится о плавающих объектах. Причины такой неопрятности носят {\em педагогический характер}: изображения и таблицы можно объяснить, не слишком настаивая на том, что они обычно являются плавающими; и все же, когда мы начинаем их изучать, нам очень помогает обнаружить, что, к удивлению, мы уже знаем о двух плавающих объектах.

\startsection
  [
    reference=sec:floating objects,
    title={Что такое плавающие объекты и что они делают?},
  ]

Если бы документ содержал только {\em обычный} текст, разбить его на страницы было бы относительно просто: знание максимальной высоты текстовой области страницы достаточно, чтобы измерить высоту различных абзацев, чтобы знать, куда вставлять разрывы страниц. Проблема в том, что во многих документах есть объекты, фрагменты или неделимые блоки текста, такие как изображение, таблица, формула, абзац в рамке и т. Д.

Иногда эти объекты могут занимать большую часть страницы, что, в свою очередь, создает проблему, заключающуюся в том, что если вам нужно вставить их в определенную точку документа, они могут не поместиться на текущей странице и должны быть внезапно прерваны, оставляя большое пустое пространство внизу, так что рассматриваемый объект и текст, следующий за ним, перемещаются на следующую страницу. Однако правила хорошего набора указывают, что, за исключением последней страницы главы, на каждой странице должно быть одинаковое количество текста.

Поэтому рекомендуется избегать появления больших пустых вертикальных пространств; а плавающие {\em floating} объекты - главный механизм для достижения этого. «Плавающий объект»  \quotation{floating object} -- это объект, который не обязательно должен располагаться в определенной точке документа, но может {\em перемещаться} или {\em плавать} вокруг него. Идея состоит в том, чтобы позволить \ConTeXt\ выбрать лучшее место с точки зрения нумерации страниц для размещения таких объектов, даже разрешив им перейти на другую страницу; но всегда стараюсь не отходить слишком далеко от точки включения в исходный файл.

Следовательно, нет объектов, которые должны быть {\em как таковые}. Но есть объекты, которые иногда нужно будет поплавать. В любом случае решение остается за автором или лицом, отвечающим за набор, если это два разных человека.

Несомненно, возможность изменения точного размещения неделимого объекта очень облегчает задачу набора хорошо сбалансированных страниц; но проблема, связанная с этим, заключается в том, что, поскольку мы не знаем точно, где окажется такой объект во время написания оригинала, на него трудно ссылаться. Так, например, если я только что поместил в свой документ команду, которая вставляет изображение, и в следующем абзаце я хочу описать это и написать что-нибудь об этом, например: «Как вы можете видеть из предыдущего рисунка», когда рисунок {\em floats} вполне может быть размещен  {\em after} после того, что я только что написал, и в результате возникает несогласованность: читатель ищет изображение {\em before} перед текстом, который на него ссылается, и не может его найти, потому что после перемещения изображение закончилось после этого ссылка.

Это фиксируется с помощью {\em нумерации} плавающих объектов (после распределения их по категориям), так что вместо ссылки на изображение как \quotation{предыдущее изображение} или \quotation{следующее изображение}, мы будем ссылаться на него как \quotation{изображение 1.3}, поскольку мы можем использовать внутренний механизм ссылок \ConTeXt, чтобы гарантировать, что номер изображения всегда обновляется (см. \in{section}[sec:references]). С другой стороны, нумерация таких объектов упрощает создание их индекса (указатель таблиц, графиков, изображений, уравнений и т.д.). О том, как это сделать, см. (\in{section}[sec:lists]).

Механизм работы с плавающими объектами в \ConTeXt\ довольно сложен и временами настолько абстрактен, что может не сделать его подходящим для новичков. Поэтому в этой главе я начну с объяснения этого, используя два частных случая: изображения и таблицы. Затем я попытаюсь несколько обобщить, чтобы мы могли понять, как распространить этот механизм на другие типы объектов.

\stopsection

\startsection
  [title={Внешние изображения}]

Как читатель на данном этапе знает (поскольку это было объяснено в \in{section}[sec:ctx]), \ConTeXt\ отлично интегрирован с MetaPost и может генерировать изображения и графику, которые {\em запрограммированы} в большей части так же, как программируются преобразования текста. Существует также модуль расширения для \ConTeXt\ footnote{\ConTeXt\ extension modules, предоставляет ему дополнительные утилиты, но не включены в это введение.}, Который позволяет ему работать с TiKZ.\footnote{Это язык программирования графики, предназначенный для работы с системами на основе \TeX. Это \quotation{рекурсивная аббревиатура} из немецкого предложения \quotation{TiKZ ist keinen Zeichenprogramm}, что в переводе означает: \quotation{TiKZ не является программой для рисования}. Рекурсивные сокращения - это своего рода шутка программистов. Оставляя в стороне MetaPost (который я не знаю, как использовать), я считаю, что TiKZ - отличная система для программирования графики.} Но такие изображения не рассматриваются в этом введении (поскольку это, вероятно, заставит его длину удвоиться) . Здесь я имею в виду использование внешних изображений, которые находятся в файле на нашем жестком диске или загружаются непосредственно из Интернета с помощью \ConTeXt.

\startsubsection
  [title={Прямая вставка изображений}]
  \PlaceMacro{externalfigure}

Чтобы напрямую вставить изображение (не как плавающий объект), мы используем команду \tex{externalfigure}, синтаксис которой

\type{\externalfigure [Name] [Configuration]}

где

\startitemize

\item {\em Name} может быть либо именем файла, содержащего изображение, либо веб-адресом изображения, найденного в Интернете, либо символическим именем, которое мы ранее связали с изображением с помощью команды \PlaceMacro{useexternalfigure}\tex{useexternalfigure}, формат которой похож на \tex{externalfigure}, хотя он принимает первый аргумент с символическим именем, которое будет связано с рассматриваемым изображением.

\item {\em Configuration} -- необязательный аргумент, который позволяет нам применять определенные преобразования к изображению до того, как оно будет вставлено в наш документ. Мы рассмотрим этот аргумент более подробно в  \in{section}[sec:configimage].

\stopitemize

Допустимые форматы изображений: pdf, mps, jpg, png, jp2, jbig, jbig2, jb2, svg, eps, gif или tif. \ConTeXt\ может напрямую управлять восемью из них, в то время как остальные (svg, eps, gif или tif) необходимо преобразовать с помощью внешнего инструмента перед их открытием, который изменяется в соответствии с форматом и, следовательно, должен быть установлен в системе, чтобы \ConTeXt\ может работать с такими файлами.

\startSmallPrint

Среди форматов, поддерживаемых \tex{externalfigure}, есть также несколько видеоформатов. В частности: QuickTime (расширение .mov), Flash Video (расширение .flv) и MPeg ~ 4 (расширение .mp4). Но большинство проигрывателей PDF не знают, как обрабатывать файлы PDF со встроенным в них видео. Я не могу сказать много об этом, так как я не делал никаких тестов.

\stopSmallPrint

Нет необходимости указывать расширение файла: \ConTeXt\ будет искать файл с указанным именем и одним из расширений для известных форматов изображений. Если кандидатов несколько, сначала используется формат PDF, если он есть, а при его отсутствии - формат MPS (графика, генерируемая MetaPost). В отсутствие этих двух используется следующий порядок: jpeg, png, jpeg~2000, jbig и jbig2.

\startSmallPrint

Если фактический формат изображения не соответствует расширению файла, в котором оно хранится, \ConTeXt\ не сможет открыть его, если мы не укажем фактический формат изображения с помощью параметра {\tt method}.

\stopSmallPrint

Если изображение не размещается само по себе за пределами абзаца, а интегрировано в текстовый абзац, и его высота больше, чем межстрочный интервал, строка будет скорректирована так, чтобы изображение не перекрывало предыдущие строки, как в пример, который сопровождает эту строку \externalfigure[cow-brown][width = 2.5em].

По умолчанию \ConTeXt\ ищет изображения в рабочем каталоге, в его родительском каталоге и в родительском каталоге этого каталога. Мы можем указать местоположение каталога, содержащего изображения, с которыми мы будем работать, используя параметр {\tt directory} команды \tex{setupexternalfigures}, который добавит этот каталог к пути поиска. Если мы хотим, чтобы поиск выполнялся только в каталоге изображений, мы также должны установить опцию {\tt location}. Так, например, чтобы наш документ искал все нужные нам изображения в каталоге \MyKey{img}, мы должны написать:

\starttyping
  \setupexternalfigures
    [directory=img, location=global]
\stoptyping

\startSmallPrint

В параметре {\tt directory} в \tex{setupexternalfigures} мы можем включить более одного каталога, разделяя их запятыми; но в этом случае нам нужно заключить каталоги в фигурные скобки. Например, \MyKey{directory=\{img, \lettertilde/imágenes\}}.

В {\tt directory} мы всегда используем символ \quote{/} как разделитель между каталогами; в том числе в Microsoft Windows, операционная система которой использует \quote{\backslash} в качестве разделителя каталогов.

\stopSmallPrint

\tex{externalfigure} также может использовать изображения, размещенные в Интернете. Так, например, следующий фрагмент вставит логотип CervanTeX прямо из Интернета в документ. Это группа пользователей \TeX, говорящая по-испански: \footnote{Интернет-адреса очень длинные, и не так много места для отображения примера с двумя столбцами. Поэтому, чтобы правильно разместить порядок в левом столбце, я вставил разрыв строки в веб-адрес. Если кто-то захочет скопировать и вставить пример, он не сработает, если этот разрыв строки не будет удален.}

\startDoubleExample
\starttyping
\externalfigure
[http://www.cervantex.es/files/
cervantex/cervanTeXcolor-small.jpg]
\stoptyping

\externalfigure
[http://www.cervantex.es/files/cervantex/cervanTeXcolor-small.jpg]

\stopDoubleExample

\startSmallPrint

Когда документ, содержащий удаленный файл, сначала компилируется, он загружается с сервера и сохраняется в каталоге кэша LuaTeX. Этот кешированный файл используется при последующих компиляциях. Обычно удаленный образ загружается снова, если образ в кеше старше 1 дня. Чтобы изменить этот порог, см. \goto{\ConTeXt\ wiki}[url(https://wiki.contextgarden.net/Using_Graphics)].

\stopSmallPrint

Если \ConTeXt\ не находит изображение, которое следует вставить, ошибка не генерируется, но вместо изображения будет вставлен текстовый блок с информацией об изображении, которое должно туда попасть. Размер этого блока будет размером изображения (если известен \ConTeXt\) или, в противном случае, стандартным размером. Пример этого есть в \in{section}[sec:startcombination].

\stopsubsection

\startsubsection
  [
    reference=sec:placefigure,
    title={Вставка изображений с помощью \tex{placefigure}},
  ]
  \PlaceMacro{placefigure}

Изображения могут быть вставлены напрямую. Но предпочтительно делать это с помощью \tex{placefigure}. Эта команда вызывает \ConTeXt:

\startitemize

\item чтобы знать, что изображение вставляется, которое должно быть включено в список изображений в документе, который затем может быть использован, если мы хотим, для создания индекса изображений.

\item присвоить изображению номер, облегчая тем самым внутренние ссылки на него.

\item для добавления заголовка к изображению, создавая текстовый блок между изображением и его заголовком, что означает, что они не могут быть разделены.

\item для автоматической установки пустого пространства (по горизонтали и вертикали), необходимого для правильного просмотра изображения.

\item для размещения изображения в указанном месте, при необходимости обтекая его текстом.

\item преобразовать изображение в плавающий объект, если это возможно, с учетом его размера и местоположения. \footnote {Это последний мой вывод, учитывая, что среди вариантов размещения есть такие, как {\tt force} или \Conjecture {\tt split}, что противоречит истинному представлению о плавающем объекте.}

\stopitemize

\stopfigure

Синтаксис этой команды следующий:

\type{\placefigure[Options] [Label] {Title} {Image}}

Различные аргументы имеют следующие значения:

\startitemize

\item {\em Options} представляют собой набор указателей, которые обычно указывают, где разместить изображение. Поскольку эти параметры одинаковы в этой и других командах, я объясню их вместе позже (в \in{section}[sec:placingobjects]). Сейчас я буду использовать опцию {\tt here} в качестве примеров. Он сообщает \ConTeXt, что, насколько это возможно, он должен разместить изображение точно в том месте документа, где находится команда, которая его вставляет.

\item {\em Label} - это текстовая строка для внутренней ссылки на этот объект, чтобы мы могли ссылаться на него (см. \in{section}[sec:references]).

\item {\em Title} текст заголовка, добавляемый к изображению.

\item {\em Image} это команда, которая вставляет изображение.

\stopitemize

Например:

\starttyping
  \placefigure
    [here]
    [fig:texknuth]
    {\TeX\ logo and photo of {\sc Knuth}}
    {\externalfigure[https://i.ytimg.com/vi/8c5Rrfabr9w/maxresdefault.jpg]}
\stoptyping

  \placefigure
    [here]
    [fig:texknuth]
    {\TeX\ logo and photo of {\sc Knuth}}
    {
      \externalfigure
        [https://i.ytimg.com/vi/8c5Rrfabr9w/maxresdefault.jpg]
        [scale=600]
    }

Как мы видим в примере, при вставке изображения (что, кстати, было сделано непосредственно из изображения, размещенного в Интернете), есть некоторые изменения, касающиеся того, что происходит при прямом использовании команды \tex{externalfigure}. Добавляется вертикальное пространство, изображение центрируется и добавляется заголовок. Это {\em external} изменения, очевидные на первый взгляд. С внутренней точки зрения команда произвела и другие, не менее важные эффекты:

\startitemize

\item Прежде всего, изображение было вставлено в \quotation{список изображений}, который \ConTeXt\ поддерживает внутри для объектов, вставленных в документ. Это, в свою очередь, означает, что изображение появится в индексе изображений, который можно сгенерировать с помощью \tex{placelist [figure]} (см. \in{section}[sec:lists]), хотя есть две специальные команды для генерации индекс изображения, которые

  \PlaceMacro{placelistoffigures}\tex{placelistoffigures} or
  \PlaceMacro{completelistoffigures}\tex{completelistoffigures}.

\item Во-вторых, изображение было связано с меткой, которая была добавлена в качестве второго аргумента команды \tex{placefigure}, что означает, что с этого момента мы можем делать внутренние ссылки на него, используя эту метку (см. \in{section}[sec:references]).

\item Наконец, изображение стало плавающим, что означает, что если для набора текста (разбивки на страницы) его нужно было переместить, \ConTeXt\ изменит его размещение.

\stopitemize

На самом деле \tex{placefigure}, несмотря на свое название, используется не только для вставки изображений. С его помощью мы можем вставить что угодно, включая текст. Однако текст или другие элементы, вставленные в документ с помощью \tex{placefigure}, будут обрабатываться {\em, как если бы они были изображением}, даже если это не так; они будут добавлены в список изображений, находящихся под внутренним управлением \ConTeXt, и мы сможем применять преобразования, аналогичные тем, которые мы используем для изображений, такие как масштабирование или поворот, кадрирование и т. д. Таким образом, следующий пример:

\placefigure
  [here, force]
  [fig:testtext]
  {Using \backslash placefigure for text transformations}
  {\rotate[rotation=180]{\framed{\tfd Test text}}}

which is achieved as follows:

\starttyping
\placefigure
  [here, force]
  [fig:testtext]
  {Using \backslash placefigure for text transformations}
  {\rotate[rotation=180]{\framed{\tfd Test text}}}
\stoptyping

\stopsubsection

\startsubsection
  [title={Вставка изображений, интегрированных в текстовый блок}]

За исключением очень маленьких изображений, которые можно интегрировать в строку без слишком большого нарушения интервала между абзацами, изображения обычно вставляются в абзац, который содержит только они (или, другими словами, изображение можно рассматривать как абзац в своем абзаце). владеть правом). Если изображение вставлено с помощью \tex{placefigure} и его размер позволяет, в зависимости от того, что мы указали относительно его размещения (см. \in{section}[sec:placingobjects]), \ConTeXt\ разрешит текст из предыдущего и последующие абзацы обтекают изображение. Однако, если мы хотим гарантировать, что определенное изображение не будет отделено от определенного текста, мы можем использовать среду {\tt \PlaceMacro{startfiguretext}figuretext}, синтаксис которой следующий:

\starttyping
  \startfiguretext
    [Options]
    [Label]
    {Title}
    {Image}

    ... Text

  \stopfiguretext
\stoptyping

Аргументы среды точно такие же, как для \tex{placefigure}, и имеют то же значение. Но здесь варианты больше не варианты размещения плавающего объекта, а указания относительно интеграции изображения в абзац; так, например, \MyKey{left} здесь означает, что изображение будет размещено слева, а текст - вправо, а \MyKey{left, bottom} будет означать, что изображение должно быть размещено в нижнем левом углу. текста, связанного с ним.

The text written within the environment is what will flow around the image.

\stopsubsection

\startsubsection
  [
    reference=sec:configimage,
    title={Конфигурация и преобразование вставленных изображений},
  ]

\startsubsubsection
  [title={Параметры команды вставки, вызывающие некоторую трансформацию изображения}]
  \PlaceMacro{setupexternalfigures}

Последний аргумент в команде \tex{externalfigure} позволяет нам выполнять определенные настройки вставленного изображения. Мы можем внести эти корректировки:

\startitemize

\item Как правило, для вставки всех изображений в документ; или для вставки всех изображений из определенной точки. В этом случае мы выполняем настройку с помощью команды \tex{setupexternalfigures}.

\item Для конкретного изображения, которое мы хотим вставить в документ несколько раз. В этом случае настройка выполняется в последнем аргументе команды \tex{useexternalfigure}, которая связывает внешнюю фигуру с символическим именем.

\item В тот момент, когда мы вставляем конкретное изображение. В этом случае настройка выполняется в самой команде \tex{externalfigure}.

\stopitemize

Изменения изображения, которые могут быть достигнуты этим путем, следующие:

\startdescription{Изменение размера изображения.}

Мы можем сделать это:

\startitemize

\item {\em Назначив точную ширину или высоту}, что-то сделано с параметрами {\tt width} и {\tt height} соответственно; если регулируется только одно из двух значений, другое автоматически адаптируется для сохранения пропорции.

Мы можем назначить точную высоту или ширину или указать ее в процентах от высоты страницы или ширины строки. Например:

  \type{width=.4\textwidth}

  обеспечит ширину изображения, равную 40 \% от ширины линии.

\item {\em Масштабирование изображения}: опция {\tt xscale} масштабирует изображение по горизонтали; {\tt yscale} будет делать это по вертикали, а {\tt scale} будет делать это по горизонтали и вертикали. Эти три параметра предполагают, что число, представляющее коэффициент масштабирования, умноженное на 1000. То есть: {\tt scale=1000} оставит изображение в исходном размере, а {\tt scale=500} уменьшит его вдвое, а {\tt scale=2000} удвоит его размер.

Условное масштабирование, которое применяется только в том случае, если изображение превышает определенные размеры, достигается с помощью параметров {\tt maxwidth} и {\tt maxheight}, которые принимают размер. Например, {\tt maxwidth=.2\backslash textwidth} масштабирует изображение только в том случае, если его ширина превышает 20 \% от ширины линии.

\stopitemize

\stopdescription

\startdescription{Вращение изображения.}

Чтобы повернуть изображение, мы используем параметр {\tt orientation}, который принимает число, представляющее количество градусов поворота, которые будут применены. Вращение осуществляется против часовой стрелки.

  \startSmallPrint

Вики подразумевает, что вращение, которое может быть достигнуто с помощью этой опции, должно быть кратным 90 (90, 180 или 270), но для достижения другого вращения нам нужно будет использовать команду \tex{rotate}. Однако у меня не было проблем с применением поворота на 45 градусов к изображению только с {\tt orientation=45}, без необходимости использовать команду \tex{rotate}.

  \stopSmallPrint

\stopdescription

\startdescription{Обрамление изображения.}

Мы также можем окружить изображение рамкой, используя параметр {\tt frame=on}, и настроить его цвет ({\tt framecolor}), расстояние между рамкой и изображением ({\tt frameoffset}), толщину линии, которая рисует рамку ({\tt rulethickness}) или форму ее углов ({\tt framecorner}), которая может быть закругленной ({\tt round}) или прямоугольной.

\stopdescription

\startdescription{Другие настраиваемые аспекты изображений.}

 В дополнение к уже рассмотренным аспектам, которые подразумевают преобразование вставляемого изображения, с помощью \tex{setupexternalfigures} мы можем настроить другие аспекты, например, где искать изображение (параметр {\tt directory}), независимо от того, изображение следует искать только в указанном каталоге ({\tt location=global}) или должно ли оно также включать рабочий каталог и его родительские каталоги ({\tt location=local}), и будет ли изображение быть интерактивным ({\tt interaction}) и т.д.

\stopdescription

\stopsubsubsection

\startsubsubsection
  [title={Специальные команды для преобразования изображения}]

В \ConTeXt\ есть три команды, которые производят некоторое преобразование изображения и могут использоваться в сочетании с \tex{externalfigure}. Эти:

\startitemize

\item {\em Mirror image}: достигается с помощью команды \PlaceMacro{mirror}\tex{mirror}.

\item {\em Clipping}:  это достигается с помощью команды \PlaceMacro{clip}\tex{clip}, где ширина ({\tt width}), высота ({\tt height}), размеры горизонтального ({\tt hoffset}) и вертикального смещения заданы ({\tt voffset}). Например:

\starttyping
\clip
  [width=2cm, height=1cm, hoffset=3mm, voffset=5mm]
  {\externalfigure[logo.pdf]}
\stoptyping

\item {\em Rotation.}

Третья команда, способная применять преобразования к изображению, - это команда \PlaceMacro{rotate}\tex{rotate}. Его можно использовать вместе с \tex{externalfigure}, но обычно в этом нет необходимости, учитывая, что последний имеет, как мы видели, параметр {\ tt orientation}, который дает тот же результат.

\startSmallPrint

\stopSmallPrint

\stopitemize

Обычно эти команды используются с изображениями, но на самом деле они действуют на {\em box}. Вот почему мы можем применить их к любому тексту, просто заключив его в рамку (что команда делает автоматически), что даст любопытные эффекты, подобные следующему:

\startDoubleExample
\vbox{\starttyping
  \mirror{Test text}\\
  \rotate[rotation=20] {Test text}
\stoptyping}

\vbox{  \mirror{Test text}\\
  \rotate[rotation=20]
     {Test text}}

\stopDoubleExample

\stopsubsubsection

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:tables,
    title={Таблицы},
  ]

\startsubsection
  [title={Общие представления о таблицах и их размещении в документе}]

Таблицы - это структурированные объекты, которые содержат текст, формулы или даже изображения, расположенные в серии {\em cells}, которые позволяют нам графически увидеть взаимосвязь между содержимым каждой ячейки. Для этого информация организована в строки и столбцы: все данные (или записи) в одной строке имеют определенное отношение друг к другу, как и все данные (или записи) в одном столбце. Ячейка - это пересечение строки со столбцом, как показано в \in{figure}[fig:table].

\placefigure
  [right]
  [fig:table]
  {Image of a simple table}
  {\externalfigure[tablas_eng][width=.6\textwidth]}

Таблицы идеально подходят для отображения текста или данных, которые связаны друг с другом, потому что, поскольку каждая из них заблокирована в своей собственной ячейке, даже если ее содержимое или содержимое остальных ячеек изменяется, относительное положение одной по отношению к другим не изменится.

Из всех задач, связанных с набором текста, создание таблиц - единственная, которую, на мой взгляд, проще выполнить в графической программе (тип текстового процессора), чем в \ConTeXt. Потому что проще {\em нарисовать} таблицу (это то, что вы делаете в текстовом редакторе), чем {\em описать её}, что мы и делаем, когда работаем с \ConTeXt. Каждое изменение строки и столбца требует присутствия команды, а это означает, что реализация таблицы занимает гораздо больше времени, вместо того, чтобы просто указывать, сколько строк и столбцов мы хотим.

\ConTeXt\ имеет три различных механизма для создания таблиц; среда {\tt tabulate}, которая рекомендуется для простых таблиц и которая больше всего вдохновлена \TeX\ tables; так называемые {\em естественные таблицы}, вдохновленные таблицами HTML, подходящие для таблиц с особыми требованиями дизайна, где, например, не все строки имеют одинаковое количество столбцов; и так называемые {\em крайние таблицы}, явно основанные на XML и рекомендуемые для средних или длинных таблиц, занимающих более одной страницы. Из трех я объясню только первое. Естественные таблицы достаточно хорошо объяснены в \quotation{\ConTeXt\ Mark IV an excursion}, а для {\em крайних таблиц} есть документ о них в \suite- documentation.

Что-то похожее на то, что происходит с изображениями, происходит в таблицах: мы можем просто написать необходимые команды в некоторой точке документа, чтобы сгенерировать таблицу, и она будет вставлена именно в этом месте, или мы можем использовать \PlaceMacro{placetable}\tex{placetable}  команда для вставки таблицы. У этого есть некоторые преимущества:

\startitemize

\item \ConTeXt\ нумерует таблицу и добавляет ее в список таблиц, разрешая внутренние ссылки на таблицу (через ее нумерацию), включая ее в конечный индекс таблиц.

\item Мы получим гибкость в размещении таблиц в документе, что облегчит задачу разбиения на страницы.

\stopitemize
Формат \tex{placetable} аналогичен тому, который мы видели для \tex{placefigure} (см. \in{section}[sec:placefigure]):

\type{\placetable[Options] [Label] {Title} {table}}

Я обращаюсь к разделам\in{}[sec:placingobjects] и \in{}[sec:confcaptions] относительно опций, относящихся к размещению таблицы и настройке заголовка. Однако среди вариантов есть один, который, похоже, предназначен исключительно для столов. Это параметр \MyKey{split}, который, если установлен, разрешает \ConTeXt\ расширять таблицу на две или более страниц, и в этом случае таблица больше не может быть плавающим объектом.

В общем, мы можем установить конфигурацию для таблиц с помощью команды  \PlaceMacro{setuptables}\tex{setuptables}. Также, как и с изображениями, можно создать индекс таблиц с \PlaceMacro{placelistoftables}\tex{placelistoftables} или \PlaceMacro{completelistoftables}\tex{completelistoftables}. В связи с этим см. \in{section}[sec:variouslists].

\stopsubsection

\startsubsection
  [title={Простые таблицы со средой {\tt tabulate}}]
\PlaceMacro{starttabulate}

Самые простые таблицы - это те, которые создаются в среде {\em tabulate}, формат которой:

\vbox{\starttyping
  \starttabulate[Table column layout]
    ... % Table contents
    ...
    ...
  \stoptabulate
\stoptyping}

Если аргумент, взятый в квадратных скобках, описывает (в коде) количество столбцов в таблице и (иногда косвенно) указывает их ширину. Я говорю, что аргумент описывает дизайн {\em в коде}, потому что на первый взгляд он кажется очень загадочным: он состоит из последовательности символов, каждый из которых имеет особое значение. Я буду объяснять это понемногу и поэтапно, потому что я думаю, что так легче понять.

\startSmallPrint

Это типичный случай, когда огромное количество аспектов, которые мы можем настроить, означает, что нам нужно много текста для его описания. Кажется, это чертовски сложно. На самом деле для большинства таблиц, которые строятся на практике, достаточно пунктов 1 и 2. Остальные - это дополнительные возможности, о существовании которых полезно знать, но не обязательно знать для набора таблицы.

\stopSmallPrint

\startitemize[n]

\item {\bf Columns delimiter}: символ \MyKey{\|} используется для разделения столбцов таблицы. Так, например,\MyKey{[\|lT\|rB\|]}  будет описывать таблицу с двумя столбцами, один из которых будет иметь характеристики, связанные с индикаторами \MyKey{l} и \MyKey{T} ( которые мы увидим сразу после), а второй столбец будет иметь характеристики, связанные с \MyKey{r} и \MyKey{B}. Например, простая таблица из трех столбцов, выровненная по левому краю, будет описана как \MyKey{[\|l\|l\|l\|]}.

\item {\bf Определение основной природы ячеек в столбце:} Первое, что нужно определить, когда мы создаем нашу таблицу, - это то, хотим ли мы, чтобы содержимое каждой ячейки было записано в одной строке, или, наоборот, если текст любого столбца слишком длинный, мы хотим, чтобы наша таблица распределяла его по двум или более строкам. В среде {\tt tabulate} этот вопрос не решается ячейка за ячейкой, а считается характеристикой столбцов.

  \startitemize[a]

  \item {\em One line cells:} Если содержимое ячеек в столбце, независимо от их длины, должно быть записано в одной строке, мы должны указать выравнивание текста в столбце, который можно оставить (\MyKey{l}, из {\em left}), right (\MyKey{r}, from {\em right}) или по центру (\MyKey{c}, из {\em center}).

    \startSmallPrint
      В принципе, эти столбцы будут настолько широкими, насколько это необходимо, чтобы поместиться в самую широкую ячейку. Но мы можем ограничить ширину столбца с помощью спецификатора  \MyKey{w(Width)}. Например, \MyKey{[\|rw(2cm)\|c\|c\|]} будет описывать таблицу с двумя столбцами, первый из которых выровнен по правому краю и имеет точную ширину 2 сантиметра, а два других по центру и без ограничения ширины.

      Следует отметить, что ограничение ширины однострочных столбцов может привести к тому, что текст в одном столбце будет перекрывать текст в следующем столбце. Поэтому я советую, когда нам нужны столбцы фиксированной ширины, всегда используйте многострочные столбцы ячеек.

    \stopSmallPrint

  \item {\em Ячейки, которые при необходимости могут занимать более одной строки}: спецификатор \MyKey{p} генерирует столбцы, в которых текст в каждой ячейке будет занимать столько строк, сколько необходимо. Если мы просто укажем \MyKey{p}, ширина столбца будет равна всей доступной ширине. Но также можно указать \MyKey{p(Ширина)}, и в этом случае ширина будет точно указанной. Таким образом, следующие примеры:

\starttyping
\starttabulate[|l|r|p|]
\starttabulate[|l|p(4cm)|]
\starttabulate[|r|p(.6\textwidth)|]
\starttabulate[|p|p|p|]
\stoptyping

В первом примере будет создана таблица с тремя столбцами, первая и вторая из одной строки, выровненные по левому и правому краю соответственно, и третий, который займет оставшуюся ширину и высоту, необходимые для размещения всего ее содержимого. Во втором примере ширина второго столбца будет ровно четыре сантиметра, независимо от его содержания; но если он не умещается в этом пространстве, он займет более одной строки. В третьем примере ширина второго столбца вычисляется пропорционально максимальной ширине линии, а в последнем примере будет три столбца, ширина которых будет доступна в равных частях.

  \stopitemize

  \startSmallPrint

Обратите внимание, что в действительности, если ячейка является четырехугольником, спецификатор \MyKey{p} разрешает переменную высоту для ячеек в столбце в зависимости от длины текста.

  \stopSmallPrint

\item {\bf Добавление указаний к описанию столбца, касающемуся стиля и варианта шрифта, который будет использоваться}: после того, как основной характер столбца (ширина и высота, автоматические или фиксированные, ячеек) определен, мы все еще можем добавьте в описание содержимого столбца символ, представляющий {\em формат}, в котором он должен быть записан. Этими символами могут быть \MyKey{B} для полужирного шрифта, \MyKey{I} для курсива, \MyKey{S} для наклонного шрифта, \MyKey{R} для букв в римском стиле или \MyKey{T} для надписей в стиле {\em пишущей машинки}.

\starthead {\bf Другие дополнительные аспекты, которые могут быть указаны в описании столбцов таблицы}:\stophead

  \startitemize[1]

  \item {\em Столбцы с математическими формулами}: спецификаторы \MyKey{m} и \MyKey{M} включают математический режим в столбце без необходимости указывать его в каждой из его ячеек. Ячейки в этом столбце не могут содержать обычный текст.

    \startSmallPrint

Хотя \TeX, предшественник \ConTeXt, появился для набора любых математических задач, до сих пор я почти ничего не говорил о написании математики. В математическом режиме (который я не буду объяснять) \ConTeXt\ изменяет наши обычные правила и даже использует другие шрифты. Математический режим имеет две разновидности: один мы можем назвать {\em linear}, где формула помещается в строку, содержащую обычный текст (индикатор \MyKey{m}), и режим {\em complete maths}, который отображает формулы в среда, в которой нет обычного текста. Основное различие между двумя режимами в таблице заключается в основном в размере, в котором будет записана формула, а также в горизонтальном и вертикальном пространстве вокруг нее.

    \stopSmallPrint

  \item {\em Добавление дополнительных горизонтальных пробелов вокруг содержимого ячеек в столбце}: с помощью индикаторов \MyKey{in}, \MyKey{jn} и \MyKey{kn} мы можем добавить дополнительные пробелы слева от содержимое столбца (\MyKey{in}) справа (\MyKey{jn}) или по обе стороны (\MyKey{kn}). Во всех трех случаях \MyKey{n} представляет собой число, на которое нужно умножить пробел, который обычно остается без одного из этих спецификаторов (по умолчанию среднее значение равно {\em em}). Так, например, \MyKey{\|j2r\|} будет указывать на то, что мы столкнулись со столбцом, который будет выровнен по правому краю и в котором нам нужно пустое пространство шириной 1 {\em em}.

  \item {\em Добавление текста до или после содержимого каждой ячейки в столбце}. Спецификаторы  {\tt b\{Text\}} и {\tt a\{Text\}} приводят к тому, что текст между фигурными скобками записывается до (\MyKey{b}, от {\em before}) или после (\MyKey{a}, от {\em after}) содержимого ячейки.

  \item {\em Применение команды форматирования ко всему столбцу}. Указанные ранее индикаторы \MyKey{B}, \MyKey{I}, \MyKey{S}, \MyKey{R} \MyKey{T} не охватывают все возможности форматирования: например, нет индикатора для маленьких заглавных букв, или для {\em sans serif}, или который влияет на размер шрифта. С помощью индикатора \MyKey{f \backslash Command} мы можем указать команду форматирования, которая автоматически применяется ко всем ячейкам в столбце. Например,\MyKey{\|lf\backslash sc\|} наберет содержимое столбца маленькими заглавными буквами.

  \item {\em Применение любой команды ко всем ячейкам в столбце}. Наконец, индикатор \MyKey{h\backslash Command} применит указанную команду ко всем ячейкам в столбце.

\stopitemize

\stopitemize

В \in{table}[tbl:examplestabulate] показаны некоторые примеры строк спецификации формата таблицы.

\placetable
  [here]
  [tbl:examplestabulate]
  {Некоторые примеры того, как указать формат столбцов в {\tt tabulate}}
{\starttabulate[|lT|p(.6\textwidth)|]
\HL
\NC{\bf\rm Спецификатор формата}
\NC{\bf Значение}
\NR
\HL
\NC \|l\|
\NC Создает столбец, ширина которого автоматически выравнивается по левому краю.
\NR
\NC \|rB\|
\NC Создает столбец, ширина которого автоматически выравнивается по правому краю и выделяется жирным шрифтом.
\NR
\NC \|cIm\|
\NC Создает столбец для математического содержания. По центру и курсивом.
\NR
\NC \|j4cb\{---\}\|
\NC TЭтот столбец будет иметь содержимое по центру, он будет начинаться с длинного тире (-) и добавит 2 пробела справа.
\NR
\NC \|l\|p(.7\tex{textwidth})\|
\NC  генерирует два столбца: первый выравнивается по левому краю и имеет автоматическую ширину. Второй занимает 70% от общей ширины линии.
\NR
\HL
\stoptabulate}

После того, как таблица была спроектирована, необходимо ввести ее содержимое. Чтобы объяснить, как это сделать, я начну с описания того, как должна быть заполнена таблица, где у нас есть линии, разделяющие строки и столбцы:

\startitemize

\item Мы всегда начинаем с рисования горизонтальной линии. В таблице это делается с помощью команды \PlaceMacro{HL}\tex{HL}  (от {\em Horizontal Line}).

\item Затем мы пишем первую строку: в начале каждой ячейки мы должны указать, что начинается новая ячейка и что необходимо провести вертикальную линию. Это делается с помощью команды \PlaceMacro{VL}\tex{VL} (от {\em Vertical Line}). Итак, мы начинаем с этой команды и записываем содержимое каждой ячейки. Каждый раз, когда мы меняем ячейки, мы повторяем команду \tex{VL}.

\item В конце строки мы явно указываем, что новая строка будет запущена с помощью команды  \PlaceMacro{NR}\tex{NR} (от {\em Next Row}). После этого мы повторяем \tex{HL}, чтобы нарисовать новую горизонтальную линию.

\item И так, одну за другой, записываем все строки таблицы. Когда мы закончим, мы добавим дополнительно команду \tex{NR} и еще одну команду \tex{HL}, чтобы закрыть сетку нижней горизонтальной линией.

\stopitemize

Если мы не хотим рисовать сетку таблицы, мы удаляем команды \tex{HL} и заменяем команды \tex{VL} на \PlaceMacro{NC}\tex{NC} (из {\em New Column}).

Это не особенно сложно, когда мы разбираемся в этом, хотя, когда мы смотрим на исходный код таблицы, трудно понять, как она будет выглядеть. В  \in{table}[tbl:tablecommands] мы видим команды, которые можно (и нужно) использовать в таблице. Некоторые из них я не объяснил, но думаю, что приведенного мной описания достаточно.

\placetable
  [here, force]
  [tbl:tablecommands]
  {Команды, используемые в таблице}
{\starttabulate[|l|p(.6\textwidth)|]
\HL
\NC {\bf Команда}
\NC {\bf Значение}
\NR
\HL
\NC \tex{HL}
\NC Вставляет горизонтальную линию
\NR
\NC \tex{NC}
\NC Начинает новый столбец
\NR
\NC \tex{NR}
\NC Начинает новую строку
\NR
\NC \tex{VL}
\NC Вставляет вертикальную линию, ограничивающую столбец (используется вместо \tex{NC})
\NR
\NC \PlaceMacro{NN}\tex{NN}
\NC Начинает столбец в математическом режиме (используется вместо \tex{NC})
\NR
\NC \PlaceMacro{TB}\tex{TB}
\NC Добавляет дополнительное вертикальное пространство между двумя рядами
\NR
\NC \PlaceMacro{NB}\tex{NB}
\NC  Указывает, что следующая строка начинает неделимый блок, внутри которого не может быть разрыва страницы
\NR
\HL
\stoptabulate}

А теперь в качестве примера расскажу код, которым была написана \in{table}[tbl:tablecommands].

\starttyping
\placetable
  [here]
  [tbl:tablecommands]
  {Команды, используемые в таблице}
{\starttabulate[|l|p(.6\textwidth)|]
\HL
\NC {\bf Команда}
\NC {\bf Значение}
\NR
\HL
\NC \tex{HL}
\NC Вставляет горизонтальную линию
\NR
\NC \tex{NC}
\NC Начинает новый столбец
\NR
\NC \tex{NR}
\NCНачинает новую строку
\NR
\NC \tex{VL}
\NC Вставляет вертикальную линию, ограничивающую столбец (используется вместо \tex{NC})
\NR
\NC \tex{NN}
\NC Начинает столбец в математическом режиме (используется вместо \tex{NC})
\NR
\NC \tex{TB}
\NC Добавляет дополнительное вертикальное пространство между двумя рядами
\NR
\NC \tex{NB}
\NC Указывает, что следующая строка начинает неделимый блок, внутри которого не может быть разрыва страницы
\NR
\HL
\stoptabulate}
\stoptyping

Читатель заметит, что в целом я использовал одну (или две) строки текста для каждой ячейки. В реальном исходном файле я бы использовал только строку текста для каждой ячейки; в этом примере я разделил слишком длинные строки. Использование одной строки в ячейке облегчает мне запись таблицы, потому что я пишу содержимое каждой ячейки без команд разделения строк или столбцов. Когда все написано, я выбираю текст из таблицы и прошу свой текстовый редактор вставлять  \quotation{\tex{NC }}  в начало каждой строки. После этого каждые две строки (поскольку в таблице два столбца) я вставляю строку, которая добавляет команду \tex{NR}, потому что каждые два столбца начинают новую строку. Наконец, вручную я вставляю команды \tex{HL} в те точки, где я хочу, чтобы появилась горизонтальная линия. На то, чтобы описать это, у меня уходит больше времени, чем на то, чтобы сделать это!

Но также посмотрите, как в таблице мы можем использовать обычные команды \ConTeXt. В частности, в этой таблице мы постоянно используем \tex{tex}, что объясняется в \in{section}[sec:verbatim].

\stopsubsection

\stopsection

\startsection
  [title={Общие аспекты изображений, таблиц и других плавающих объектов}]

Мы уже знаем, что изображения и таблицы не обязательно должны быть плавающими объектами, но они являются хорошими кандидатами на это, хотя они должны быть вставлены в документ с помощью команд \tex{placefigure} или \tex{placetable}. В дополнение к этим двум командам и с той же структурой в \ConTeXt\ у нас есть команда \PlaceMacro{placechemical}\tex{placechemical} (для вставки химикатов в формулы), команда \PlaceMacro{placegraphic}\tex{placegraphic} (для вставки графики) и команду \PlaceMacro{placeintermezzo}\tex{placeintermezzo} для вставки структуры, которая \ConTeXt\ вызывает {\em Intermezzo} и которая, как я подозреваю, относится к фрагментам текста во фреймах. Все эти команды, в свою очередь, являются конкретными приложениями более общей команды \PlaceMacro{placefloat}\tex{placefloat}, синтаксис которой следующий:

\type{\placefloat [Name] [Options] [Label] {Title} {Contents}}

Обратите внимание, что \tex{placefloat} идентичен \tex{placefigure} и \tex{placetable}, за исключением первого аргумента, который в \tex{placefloat} принимает имя плавающего объекта. Это потому, что {\em каждого типа плавающего объекта можно вставить в документ двумя разными командами}: \tex{placefloat[TypeName]} или \tex{placeTypeName}. Другими словами: \tex{placefloat[figure]} и \tex{placefigure} - это одна и та же команда, точно так же, как \tex{placefloat[table]} - это та же команда, что и \tex{placetable}.

Поэтому с этого момента я буду говорить о \tex{placefloat}, но учтите, что все, что я говорю, также применимо к \tex{placefigure} или \tex{placetable}, которые являются конкретными приложениями указанной команды.

Аргументы \tex{placefloat}:

\startitemize

\item {\em Name}. относится к рассматриваемому плавающему объекту. Это может быть какой-то заранее определенный плавающий объект ({\tt figure, table, chemical, intermezzo}) или плавающий объект, созданный нами с помощью \tex{definefloat} (см. \in{section}[sec:definefloat]).

\item {\em Options}. Набор символических слов, которые говорят \ConTeXt\, как следует вставить объект. Подавляющее большинство из них ссылаются на {\em where}, чтобы вставить его. Мы увидим это в следующем разделе.

\item {\em Label}. Метка для будущих внутренних ссылок на этот объект.

\item {\em Title}. Текст заголовка, который будет добавлен к объекту. Относительно его конфигурации см. \in{section}[sec:confcaptions].

\item {\em Contents}. Это, конечно, зависит от типа объекта. Для изображений обычно используется команда \tex{externalimage}; для таблиц - команды, которые будут создавать таблицу; для {\em intermezzi} - фрагмент текста в рамке; и т.п.

\stopitemize

Первые три аргумента, заключенные в квадратные скобки, необязательны. Последние два (заключенные в фигурные скобки) являются обязательными, хотя могут быть пустыми. Так, например:

\cmd{placefloat\{\}\{\}} вставит

\placefloat{}{}

в документ.

\startitemize

{\bf Примечание:} Мы видим, что \ConTeXt\ считал, что вставляемый объект был изображением, поскольку он был пронумерован как изображение и включен в список \Conjecture images. Это заставляет меня предположить, что изображения являются плавающими объектами по умолчанию.

\stopitemize

\startsubsection
  [
    reference=sec:placingobjects,
    title={Параметры вставки плавающих объектов},
  ]

Аргумент {\em Options} в \tex{placefigure}, \tex{placetable} и \tex{placefloat} управляет различными аспектами вставки этих типов объектов. В основном это место на странице, куда будет вставлен объект. Здесь поддерживаются несколько значений, каждое из которых имеет различную природу:

\startitemize

\item Некоторые места вставки устанавливаются по отношению к элементам страницы ({\tt top, bottom inleft, inright, inmargin, margin, leftmargin, rightmargin, leftedge, rightedge, innermargin, inneredge, outeredge, inner, outer}). Конечно, это должен быть объект, который может уместиться в той области, где он предназначен для размещения, и для этого элемента должно быть зарезервировано место в макете страницы. Об этом см. раздел  \in{}[sec:page-elements] и \in{}[sec:pagelayout].

\item Другие возможные места вставки больше связаны с текстом, окружающим объект, и указывают, где следует разместить объект, чтобы текст обтекал его. По сути, значения {\tt left} и {\tt right}.

\item Параметр {\tt here} интерпретируется как рекомендация сохранить объект в той точке исходного файла, где он расположен. Эта {\em рекомендация} не будет соблюдаться, если это не разрешено требованиями к разбиению на страницы. Это указание усиливается, если мы добавляем параметр {\tt force}, который означает именно это: принудительно вставить объект в этой точке. Обратите внимание, что при принудительной вставке в определенной точке объект больше не будет плавающим.

\item Другие возможные варианты относятся к странице, на которую должен быть вставлен объект: \MyKey{page} вставляет его на новую страницу; \MyKey{opposite} вставляет его на страницу напротив текущей; \MyKey{leftpage} на четной странице; \MyKey{rightpage} на нечетной странице.

\stopitemize

Есть некоторые варианты, не связанные с расположением объекта.
Из их:

\startitemize

\item {\tt none}: Эта опция подавляет заголовок.

\item {\tt split}: Эта опция позволяет объекту занимать более одной страницы. Конечно, это должен быть объект, который делится по своей природе, например, таблица. Когда этот параметр используется и объект разбит, его нельзя больше назвать плавающим.

\stopitemize

\stopsubsection

\startsubsection
  [
    reference=sec:confcaptions,
    title={Настройка заголовков плавающих объектов},
  ]

Если мы не используем параметр \MyKey{none} в \tex{placefloat}, по умолчанию плавающие объекты связаны с заголовком, состоящим из трех элементов:

\startitemize

\item Имя типа рассматриваемого объекта. Это имя в точности соответствует типу объекта; поэтому, если, например, мы определяем новый плавающий объект с именем \quotation{последовательность} и вставляем \quotation{последовательность} как плавающий объект, заголовок будет \quotation{Последовательность 1}. Просто напишите название объекта с заглавной буквы.

  \startSmallPrint

Несмотря на то, что только что было сказано, если основным языком документа не является английский, английское имя для предопределенных объектов, таких как, например, объекты \MyKey{figure} или \MyKey{table}, будет переведено; Так, например, объект \MyKey{figure} в документах на испанском языке называется \MyKey{Figura}, а объект \MyKey{table} называется \MyKey{Tabla}. Эти испанские имена для предопределенных объектов можно изменить с помощью \tex{setuplabeltext}, как описано в \in{section}[sec:labels].

  \stopSmallPrint

\item Его номер. По умолчанию объекты пронумерованы по главам, поэтому первой таблицей в главе 3 будет таблица \quote{3.1}.

\item Его содержимое. Введен как аргумент \tex{placefloat}.

\stopitemize

С помощью\PlaceMacro{setupcaptions}\tex{setupcaptions} или \PlaceMacro{setupcaption}\tex{setupcaption[Object]} мы можем изменить систему нумерации и внешний вид самого заголовка. Первая команда повлияет на все заголовки всех объектов, а вторая повлияет только на заголовок определенного типа объекта:

\startitemize

\item Что касается системы нумерации, она контролируется параметрами {\tt number}, {\tt way}, {\tt prefixsegments} и {\tt numberconversion}:

  \startitemize

  \item {\tt number} может принимать значения {\tt yes}, {\tt no} или {\tt none} и определяет, будет ли число или нет.

  \item {\tt way} указывает, будет ли нумерация последовательной по всему документу ({\tt way=bytext}), или она будет возобновляться в начале каждой главы ({\tt way=bychapter}) или раздела ({\tt way=bysection}). В случае перезапуска целесообразно согласовать значение этой опции с опцией {\tt prefixsegments}.

  \item {\tt prefixsegments} указывает, будет ли у номера префикс {\em} и какой он будет. Таким образом, {\tt prefixsegments=chapter} заставляет количество объектов всегда начинаться с номера главы, в то время как {\tt prefixsegments=section} будет предшествовать номеру объекта с номером раздела.

  \item {\tt numberconversion} управляет типом нумерации. Значения для этого параметра могут быть: арабскими цифрами.
    (\MyKey{numbers}), lower case (\MyKey{a},
    \MyKey{characters}), upper case (\MyKey{A},
    \MyKey{Characters}), small caps \MyKey{KA}), upper case Roman numerals (\MyKey{I}, \MyKey{R},
    \MyKey{Romannumerals}), lower case (\MyKey{i},
    \MyKey{r}, \MyKey{romannumerals} or small caps
    (\MyKey{KR})).

  \stopitemize

\item Внешний вид самого заголовка регулируется множеством опций. Я перечислю их, но для подробного объяснения значения каждого из них я обращаюсь к \in{section}[sec:titlestyle], где объясняется управление внешним видом команд секционирования, поскольку параметры в основном такой же. Рассматриваемые варианты:

  \startitemize

  \item Чтобы контролировать формат всех элементов заголовка,
    {\tt style, color, command}.

  \item Чтобы управлять форматом только имени типа объекта:
    {\tt headstyle, headcolor, headcommand, headseparator}.

  \item Для управления только форматом нумерации: {\tt numbercommand}.

  \item Чтобы управлять только форматом самого заголовка:
    {\tt textcommand}.

  \stopitemize

\item Мы также можем контролировать другие аспекты, такие как расстояние между различными элементами, составляющими заголовок, ширину заголовка, его размещение по отношению к объекту и т. Д. Здесь я ссылаюсь на информацию в \goto{\ConTeXt\ wiki}[url(wiki)] относительно параметров, которые можно настроить с помощью этой команды.

\stopitemize

\stopsubsection

\startsubsection
  [
    reference=sec:startcombination,
    title={Комбинированная вставка двух и более объектов},
  ]

Чтобы вставить в документ два или более разных объекта, чтобы \ConTeXt\ удерживал их вместе и работал с ними как с одним объектом, у нас есть среда \PlaceMacro{startcombination}\tex{startcombination}, синтаксис которой:

\type{\startcombination[Ordering] ... \stopcombination}

где {\em Ordering} указывает, как объекты должны быть упорядочены: если все они должны быть упорядочены по горизонтали, {\em Ordering} указывает только количество объектов, которые необходимо объединить. Но если мы хотим объединить объекты в две или более строк, нам нужно будет указать номер объекта в строке, затем количество строк и разделить оба числа символом *. Например:

\starttyping
\startcombination[3*2]
  {\externalfigure[test1]}
  {\externalfigure[test2]}
  {\externalfigure[test3]}
  {\externalfigure[test4]}
  {\externalfigure[test5]}
  {\externalfigure[test6]}
\stopcombination
\stoptyping

что приведет к следующему выравниванию изображений.

\startcombination[3*2]
  {\externalfigure[test1]}
  {\externalfigure[test2]}
  {\externalfigure[test3]}
  {\externalfigure[test4]}
  {\externalfigure[test5]}
  {\externalfigure[test6]}
\stopcombination

В предыдущем примере изображения, которые я объединил, на самом деле не существуют, поэтому вместо изображений \ConTeXt\ сгенерировал текстовые поля с информацией о них.

С другой стороны, посмотрите, как каждый элемент, объединяемый в  \tex{startcombination}, заключен в фигурные скобки.

Фактически,  \tex{startcombination} позволяет нам не только соединять и выравнивать изображения, но и любые блоки, такие как текст внутри среды\tex{startframedtext}, таблицы и т.д. Чтобы настроить комбинацию, мы можем использовать команду \tex{setupcombination}, а также мы можем создавать предварительно сконфигурированные комбинации, используя \PlaceMacro{definecombination}\tex{definecombination}.

\stopsubsection

\startsubsection
  [title={Общая конфигурация плавающих объектов}]

Мы уже видели, что с помощью  \tex{placefloat} мы можем контролировать местоположение вставляемого плавающего объекта и некоторые другие детали. Также возможно настроить:

\startitemize

\item  Глобальные характеристики конкретного типа плавающего объекта. Это делается с помощью  \PlaceMacro{setupfloat}\cmd{setupfloat[Название типа плавающего объекта]}.

\item  Глобальные характеристики всех плавающих объектов в нашем документе. Это делается с помощью \PlaceMacro{setupfloats}\tex{setupfloats}.

\stopitemize

Помните, что так же, как \tex{placefloat[figure]} эквивалентен \tex{placefigure}, \tex{setupfloat[figure]} эквивалентен \tex{setupfigures}, а \tex{setupfloat[table]} эквивалентен \tex{setuptables}.

Что касается настраиваемых параметров для них, я отсылаю к официальному списку команд \ConTeXt\ (\in{section}[sec:qrc-setup-en]).

\stopsubsection

\startsection
  [
    reference=sec:definefloat,
    title={Определение дополнительных плавающих объектов},
  ]
  \PlaceMacro{definefloat}

Команда \tex{definefloat} позволяет нам определять наши собственные плавающие объекты. Её синтаксис:

\type{\definefloat [Singular name] [Plural name] [Configuration]}

Где аргумент {\em Configuration} является необязательным аргументом, который позволяет нам уже указывать конфигурацию этого нового объекта во время его создания.
Мы также можем сделать это позже с помощью \tex{setupfloat[Name in the singular]}.

Поскольку мы заканчиваем наше введение этим разделом, я собираюсь воспользоваться им, чтобы немного глубже погрузиться в кажущиеся джунгли {\em jungle} команд \ConTeXt, которые, однажды понятые, не так уж похожи на джунгли {\em jungle}, но, на самом деле, вполне рациональны.

Давайте начнем с того, что спросим себя, что на самом деле представляет собой плавающий объект для \ConTeXt, и ответим, что это объект со следующими характеристиками:

\startitemize

\item Что у него есть определенная свобода в том, что касается его расположения на странице.

\item С ним связан список  {\em list}, который позволяет ему пронумеровать такие типы объектов и, в конечном итоге, создать их индекс.

\item Что у него есть заголовок

\item Что, когда объект действительно может плавать, он должен рассматриваться как неотделимая единица, то есть (в терминологии \TEX) {\em заключенный в рамку}.

\stopitemize

Другими словами, плавающий объект фактически состоит из трех элементов: самого объекта, связанного с ним списка и заголовка. Для управления самим объектом нам нужна только одна команда для установки его местоположения и другая для вставки объекта в документ; для настройки аспектов списка достаточно общих команд управления списком, а для настройки аспектов заголовка - общих команд управления заголовком.

И здесь проявляется гениальность \ConTeXt: простая команда для управления плавающими объектами (\tex{setupfloats}) и простая команда для вставки плавающих объектов: \tex{placefloat} можно было бы спроектировать: но \ConTeXt\ делает следующее:

\startitemize[n]

\item Создайте команду, чтобы связать имя с определенной конфигурацией плавающего объекта. Это команда \text{define float}, которая на самом деле связывает не одно имя, а два имени, одно в единственном числе и одно во множественном числе.

\item Создайте вместе с командой глобальной конфигурации плавающих объектов команду, которая позволяет нам настраивать только определенный тип объекта: \tex{setupfloat[Object]}.

\item Добавьте к команде определения местоположения плавающего объекта (\tex{placefloat}) аргумент, который позволяет нам различать тот или иной тип: (\tex{placefloat[Object]}).

\item Создавайте команды, включая имя объекта, для всех действий плавающего объекта. Некоторые из этих команд (которые на самом деле являются клонами других более общих команд) будут использовать имя объекта в единственном числе, а другие будут использовать его во множественном числе.

\stopitemize

Поэтому, когда мы создаем новый плавающий объект и сообщаем \ConTeXt\ его имя в единственном и множественном числе, \ConTeXt:
\startitemize

\item Резервирует место в памяти для хранения конкретной конфигурации этого типа объекта.

\item Создает новый список с единственным именем этого типа объекта, поскольку со списком связаны плавающие объекты.

\item Создает новый вид «заголовка», связанный с этим новым типом объекта, чтобы поддерживать настраиваемую конфигурацию этих заголовков.

\item И, наконец, он создает группу новых команд, специфичных для этого нового типа объекта, имя которого фактически является синонимом более общей команды.

\stopitemize

В \in{table}[tbl:floatcommands] мы можем видеть команды, которые автоматически создаются при определении нового плавающего объекта, а также более общие команды, синонимами которых они являются:

\placetable
  [here]
  [tbl:floatcommands]
  {Команды, которые автоматически создаются при создании нового плавающего объекта}
{\switchtobodyfont[small]
\starttabulate[|lT|lT|lT|]
\HL
\NC{\bf\rm Команда}
\NC{\bf\rm Синоним}
\NC{\bf\rm Пример}
\NR
\HL
\NC\backslash completelistof<PluralName>
\NC\backslash completelist[PluralName]
\NC\backslash completelistoffigures
\NR
\NC\backslash place<SingularName>
\NC\backslash placefloat[SingularName]
\NC\backslash placefigure
\NR
\NC\backslash placelistof<PluralName>
\NC\backslash placelist[PluralName]
\NC\backslash placelistoffigures
\NR
\NC\backslash setup<SingularName>
\NC\backslash setupfloat[SingularName]
\NC\backslash setupfigure
\NR
\HL
\stoptabulate
}

\startSmallPrint

Фактически, создаются некоторые дополнительные команды, которые являются синонимами предыдущих, и, поскольку я не включил их в объяснение главы, я исключил их из таблицы \in{table}[tbl:floatcommands]: \tex{start<NameSingular>}, \tex{start<NameSingular>text} и \tex{startplace<NameSingular>}.

\stopSmallPrint

Я использовал команду, используемую для изображений, в качестве примера команд, созданных при определении нового плавающего объекта; и я сделал это, потому что изображения, такие как таблицы и остальные числа с плавающей запятой, предопределенные \ConTeXt, являются фактическими случаями  \tex{definefloat}:

\starttyping
\definefloat[chemical][chemicals]
\definefloat[figure][figures]
\definefloat[table][tables]
\definefloat[intermezzo][intermezzi]
\definefloat[graphic][graphics]
\stoptyping

Наконец, мы видим, что в действительности \ConTeXt\ никоим образом не управляет каким-либо материалом, включенным в каждый конкретный плавающий объект; предполагается, что это работа автора. Вот почему мы также можем вставлять текст с помощью команд \tex{placefigure} или \tex{placetable}. Однако текст, вводимый с помощью \ placefigure, включается в список изображений, а если вводится с помощью \tex{placetable}, в список таблиц.

\stopsection

\stopchapter

\stopcomponent

%%% Local Variables:
%%% mode: ConTeXt
%%% mode: auto-fill
%%% coding: utf-8-unix
%%% TeX-master: "../introCTX.mkiv"
%%% End:
%%% vim:set filetype=context tw=75 : %%%
